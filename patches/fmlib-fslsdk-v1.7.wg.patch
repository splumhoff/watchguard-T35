WatchGuard patches to sources for fmlib-fslsdk-v1.7 as of
Thu May 26 11:28:31 PDT 2022
The patches shown here have been applied to source .tar.gz 
files supplied with the WatchGuard Open Source Archive.

==========================================================================
--- fmlib-fslsdk-v1.7/src/Makefile.orig	2022-05-26 11:28:30.970977909 -0700
+++ fmlib-fslsdk-v1.7/src/Makefile	1969-12-31 16:00:00.000000000 -0800
@@ -1,171 +0,0 @@
-#==============================================================================
-# Copyright 2010-2012 Freescale Semiconductor, Inc
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions are met:
-#       * Redistributions of source code must retain the above copyright
-# 	notice, this list of conditions and the following disclaimer.
-#       * Redistributions in binary form must reproduce the above copyright
-# 	notice, this list of conditions and the following disclaimer in the
-# 	documentation and/or other materials provided with the distribution.
-#       * Neither the name of Freescale Semiconductor nor the
-# 	names of its contributors may be used to endorse or promote products
-# 	derived from this software without specific prior written permission.
-#
-#
-# ALTERNATIVELY, this software may be distributed under the terms of the
-# GNU General Public License ("GPL") as published by the Free Software
-# Foundation, either version 2 of that License or (at your option) any
-# later version.
-#
-# This software is provided by Freescale Semiconductor "as is" and any
-# express or implied warranties, including, but not limited to, the implied
-# warranties of merchantability and fitness for a particular purpose are
-# disclaimed. In no event shall Freescale Semiconductor be liable for any
-# direct, indirect, incidental, special, exemplary, or consequential damages
-# (including, but not limited to, procurement of substitute goods or services;
-# loss of use, data, or profits; or business interruption) however caused and
-# on any theory of liability, whether in contract, strict liability, or tort
-# (including negligence or otherwise) arising in any way out of the use of
-# this software, even if advised of the possibility of such damage.
-#==============================================================================
-
-# WARNING!
-# Although invoking the all, archive targets in this Makefile from a Yocto-like
-# environment may succeed, you will end up with N different libraries that are
-# actually being built using the same compiler flags, i.e. the CFLAGS from the
-# environment. That is because Yocto builds the fm-lib for various platforms
-# one at a time, by invoking only the corresponding libfm-<arch>.a, then
-# install-<arch> targets for each platform that it's currently configured for.
-
-# Set this as appropriate for local builds
-CROSS_COMPILE?=powerpc-linux-gnu-
-
-# You must set KERNEL_SRC or the <DESTDIR, PREFIX> pair
-# before invoking this Makefile as standalone
-KERNEL_SRC?=$(DESTDIR)$(PREFIX)
-
-# These should be inherited from the environment with which Yocto invokes us,
-# but in case not, then here we're making sure that we're actually using
-# the cross-tools, and NOT the native ones:
-ifeq ($(CC),cc)
-CC=$(CROSS_COMPILE)gcc
-endif
-
-ifeq ($(AR),ar)
-AR=$(CROSS_COMPILE)ar
-endif
-
-INSTALL?=install
-
-LIB_DEST_DIR?=$(PREFIX)/lib
-
-# Add any collateral files that need to be included in the archive, here:
-FM_LIB_DOCFILES=COPYING INSTALL README
-
-# Don't touch these!
-FM_LIB_YOCTO_STAGING=$(KERNEL_SRC)/include/linux/fmd
-FM_IOCTL_INC?=$(KERNEL_SRC)/include/uapi/linux/fmd
-FM_LIB_INC?=./include/fmd
-FM_LIB_SRCDIR=./src
-FM_LIB_INCLUDE:=$(FM_IOCTL_INC) \
-		$(FM_IOCTL_INC)/Peripherals \
-		$(FM_IOCTL_INC)/integrations \
-		$(FM_LIB_INC) \
-		$(FM_LIB_INC)/Peripherals \
-		$(FM_LIB_INC)/integrations \
-		$(FM_LIB_YOCTO_STAGING) \
-		$(FM_LIB_YOCTO_STAGING)/Peripherals \
-		$(FM_LIB_YOCTO_STAGING)/integrations
-
-# These flags need to be passed to the compiler in any circumstance:
-EXTRA_CFLAGS=-DNCSW_LINUX -fPIC -shared -mlongcall
-
-# CFLAGS to use during out-of-Yocto (i.e. "local") build:
-LOCAL_CFLAGS=-O2 -g0 -Wall \
-	     -fexpensive-optimizations -frename-registers \
-	     -fomit-frame-pointer -maix-struct-return \
-	     -D__STDC_LIMIT_MACROS $(EXTRA_CFLAGS)
-
-
-%.a: %.o
-	@(echo "(AR) $(@)")
-	@($(AR) rcsv $@ $^)
-
-libfm-ppce500mc.o: EXTRA_CFLAGS+=-DP4080
-libfm-ppc32e5500.o libfm-ppc64e5500.o: EXTRA_CFLAGS+=-DP5020
-libfm-ppc32e6500.o libfm-ppc64e6500.o: EXTRA_CFLAGS+=-DB4860
-libfm-ppc32e5500-fmv3.o libfm-ppc64e5500-fmv3.o: EXTRA_CFLAGS+=-DB4860
-libfm-ppce500v2.o: EXTRA_CFLAGS+=-DP1023
-
-libfm-ppc32e5500-fmv3.o: CFLAGS?=-m32 -mhard-float -mcpu=e5500  $(LOCAL_CFLAGS)
-libfm-ppc64e5500-fmv3.o: CFLAGS?=-m64 -mhard-float -mcpu=e5500  $(LOCAL_CFLAGS)
-libfm-ppce500mc.o:  CFLAGS?=-m32 -mhard-float -mcpu=e500mc $(LOCAL_CFLAGS)
-libfm-ppc32e5500.o: CFLAGS?=-m32 -mhard-float -mcpu=e5500  $(LOCAL_CFLAGS)
-libfm-ppc64e5500.o: CFLAGS?=-m64 -mhard-float -mcpu=e5500  $(LOCAL_CFLAGS)
-libfm-ppce500v2.o:  CFLAGS?=-m32 -msoft-float -mcpu=8548   $(LOCAL_CFLAGS)
-libfm-ppc32e6500.o: CFLAGS?=-m32 -mhard-float -mcpu=e6500  $(LOCAL_CFLAGS)
-libfm-ppc64e6500.o: CFLAGS?=-m64 -mhard-float -mcpu=e6500  $(LOCAL_CFLAGS)
-libfm-ppce500v2.o:  CFLAGS?=-m32 -msoft-float -mcpu=8548   $(LOCAL_CFLAGS)
-
-CFLAGS+=$(EXTRA_CFLAGS) -isystem $(KERNEL_SRC)/include
-
-
-all: libfm-ppc32e5500.a libfm-ppc64e5500.a libfm-ppce500mc.a \
-		libfm-ppce500v2.a libfm-ppc64e6500.a libfm-ppc32e6500.a \
-		libfm-ppc32e5500-fmv3.a libfm-ppc64e5500-fmv3.a
-
-libfm-ppc32e5500.o libfm-ppc64e5500.o libfm-ppce500mc.o libfm-ppce500v2.o \
-		libfm-ppc32e6500.o libfm-ppc64e6500.o \
-		libfm-ppc32e5500-fmv3.o libfm-ppc64e5500-fmv3.o: \
-		$(FM_LIB_SRCDIR)/fm_lib.c $(wildcard $(addsuffix /*.h,$(FM_LIB_INCLUDE)))
-	@(echo "(CC)  $@")
-	@(echo "$(CC) $(CFLAGS) $(addprefix -I,$(FM_LIB_INCLUDE)) -c -o $@ $<" > .$@.cmd)
-	@($(CC) $(CFLAGS) $(addprefix -I,$(FM_LIB_INCLUDE)) -c -o $@ $<)
-
-archive: all .version
-	@(echo "Creating tarball for fmlib...")
-	@(tar -czf fm-lib-bi.tar.gz . \
-		--transform "s,\\.\\(.*\\),fm-lib\\1," \
-		--exclude=Makefile --exclude=.version --exclude-vcs --exclude=*.tar.gz)
-
-install-%: %.a
-	@(echo "Installing...")
-	@($(INSTALL) -d $(DESTDIR)$(LIB_DEST_DIR))
-	@($(INSTALL) $< $(DESTDIR)$(LIB_DEST_DIR))
-	@(ln -s $< $(DESTDIR)$(LIB_DEST_DIR)/libfm.a)
-	@(cp -r -p ./include $(DESTDIR)$(PREFIX))
-	@($(INSTALL) -d $(DESTDIR)$(PREFIX)/share/doc/fm-lib)
-	@($(INSTALL) $(FM_LIB_DOCFILES) $(DESTDIR)$(PREFIX)/share/doc/fm-lib)
-
-targets help:
-	@(echo)
-	@(echo "make all: build libraries for all platforms (local build)")
-	@(echo)
-	@(echo "make archive: build tarball with fm libraries")
-	@(echo)
-	@(echo "make libfm-<arch>.a (e.g. \"make libfm-ppce500mc.a\"):")
-	@(echo "	build library for specific platform <arch>")
-	@(echo)
-	@(echo "The available make libfm-<arch>.a targets are:")
-	@(echo "	libfm-ppce500mc.a		(P2, P3, P4)")
-	@(echo "	libfm-ppc32e5500.a		(P5 - 32b)")
-	@(echo "	libfm-ppc64e5500.a		(P5 - 64b)")
-	@(echo "	libfm-ppc32e6500.a		(B4/T4 - 32b)")
-	@(echo "	libfm-ppc64e6500.a		(B4/T4 - 64b)")
-	@(echo "	libfm-ppc32e5500-fmv3.a		(t1040 - 32b)")
-	@(echo "	libfm-ppc64e5500-fmv3.a		(t1040 - 64b)")
-	@(echo "	libfm-ppce500v2.a		(P1023)")
-	@(echo)
-	@(echo "make install-libfm-<arch> (e.g. \"make install-libfm-ppce500mc\"):")
-	@(echo "	install the library and headers to the location specified by DESTDIR, PREFIX")
-	@(echo)
-	@(echo "Please also mind the fact that the environment for invoking 'make' with this Makefile")
-	@(echo "needs also contain certain required variables, most notably KERNEL_SRC!")
-	@(echo)
-
-clean:
-	@(echo "Cleaning...")
-	@(rm -rf *.a *.o *.d .*.o.cmd)
-
-.PHONY: targets help clean
--- fmlib-fslsdk-v1.7/src/include/fmd/ncsw_ext.h.orig	2022-05-26 11:28:30.986977256 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/ncsw_ext.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,437 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          ncsw_ext.h
-
- @Description   General NetCommSw Standard Definitions
-*//***************************************************************************/
-
-#ifndef __NCSW_EXT_H
-#define __NCSW_EXT_H
-
-#include <types_ext.h>
-
-#define WRITE_BLOCK                 IOMemSet32
-#define COPY_BLOCK                  Mem2IOCpy32
-
-#define PTR_TO_UINT(_ptr)           ((uintptr_t)(_ptr))
-#define UINT_TO_PTR(_val)           ((void*)(uintptr_t)(_val))
-
-#define PTR_MOVE(_ptr, _offset)     (void*)((uint8_t*)(_ptr) + (_offset))
-
-
-#define WRITE_UINT8_UINT24(arg, data08, data24) WRITE_UINT32(arg,((uint32_t)(data08)<<24)|((uint32_t)(data24)&0x00FFFFFF))
-#define WRITE_UINT24_UINT8(arg, data24, data08) WRITE_UINT32(arg,((uint32_t)(data24)<< 8)|((uint32_t)(data08)&0x000000FF))
-
-/* Little-Endian access macros */
-
-#define WRITE_UINT16_LE(arg, data) \
-        WRITE_UINT16((arg), SwapUint16(data))
-
-#define WRITE_UINT32_LE(arg, data) \
-        WRITE_UINT32((arg), SwapUint32(data))
-
-#define WRITE_UINT64_LE(arg, data) \
-        WRITE_UINT64((arg), SwapUint64(data))
-
-#define GET_UINT16_LE(arg) \
-        SwapUint16(GET_UINT16(arg))
-
-#define GET_UINT32_LE(arg) \
-        SwapUint32(GET_UINT32(arg))
-
-#define GET_UINT64_LE(arg) \
-        SwapUint64(GET_UINT64(arg))
-
-/* Write and Read again macros */
-#define WRITE_UINT_SYNC(size, arg, data)    \
-    do {                                    \
-        WRITE_UINT##size((arg), (data));    \
-        CORE_MemoryBarrier();               \
-    } while (0)
-
-#define WRITE_UINT8_SYNC(arg, data)     WRITE_UINT_SYNC(8, (arg), (data))
-
-#define WRITE_UINT16_SYNC(arg, data)    WRITE_UINT_SYNC(16, (arg), (data))
-#define WRITE_UINT32_SYNC(arg, data)    WRITE_UINT_SYNC(32, (arg), (data))
-
-#define MAKE_UINT64(high32, low32)      (((uint64_t)high32 << 32) | (low32))
-
-
-/*----------------------*/
-/* Miscellaneous macros */
-/*----------------------*/
-
-#define UNUSED(X) (X=X)
-
-#define KILOBYTE            0x400UL                 /* 1024 */
-#define MEGABYTE            (KILOBYTE * KILOBYTE)   /* 1024*1024 */
-#define GIGABYTE            ((uint64_t)(KILOBYTE * MEGABYTE))   /* 1024*1024*1024 */
-#define TERABYTE            ((uint64_t)(KILOBYTE * GIGABYTE))   /* 1024*1024*1024*1024 */
-
-#undef  NO_IRQ
-#define NO_IRQ              (-1)
-#define NCSW_MASTER_ID      (0)
-
-/* Macro for checking if a number is a power of 2 */
-#define POWER_OF_2(n)   (!((n) & ((n)-1)))
-
-/* Macro for calculating log of base 2 */
-#define LOG2(num, log2Num)      \
-    do                          \
-    {                           \
-        uint64_t tmp = (num);   \
-        log2Num = 0;            \
-        while (tmp > 1)         \
-        {                       \
-            log2Num++;          \
-            tmp >>= 1;          \
-        }                       \
-    } while (0)
-
-#define NEXT_POWER_OF_2(_num, _nextPow) \
-do                                      \
-{                                       \
-    if (POWER_OF_2(_num))               \
-        _nextPow = (_num);              \
-    else                                \
-    {                                   \
-        uint64_t tmp = (_num);          \
-        _nextPow = 1;                   \
-        while (tmp)                     \
-        {                               \
-            _nextPow <<= 1;             \
-            tmp >>= 1;                  \
-        }                               \
-    }                                   \
-} while (0)
-
-/* Ceiling division - not the fastest way, but safer in terms of overflow */
-#define DIV_CEIL(x,y)   (((x)/(y)) + ((((((x)/(y)))*(y)) == (x)) ? 0 : 1))
-
-/* Round up a number to be a multiple of a second number */
-#define ROUND_UP(x,y)   ((((x) + (y) - 1) / (y)) * (y))
-
-/* Timing macro for converting usec units to number of ticks.   */
-/* (number of usec *  clock_Hz) / 1,000,000) - since            */
-/* clk is in MHz units, no division needed.                     */
-#define USEC_TO_CLK(usec,clk)       ((usec) * (clk))
-#define CYCLES_TO_USEC(cycles,clk)  ((cycles) / (clk))
-
-/* Timing macros for converting between nsec units and number of clocks. */
-#define NSEC_TO_CLK(nsec,clk)       DIV_CEIL(((nsec) * (clk)), 1000)
-#define CYCLES_TO_NSEC(cycles,clk)  (((cycles) * 1000) / (clk))
-
-/* Timing macros for converting between psec units and number of clocks. */
-#define PSEC_TO_CLK(psec,clk)       DIV_CEIL(((psec) * (clk)), 1000000)
-#define CYCLES_TO_PSEC(cycles,clk)  (((cycles) * 1000000) / (clk))
-
-/* Min, Max macros */
-#define MIN(a,b)    ((a) < (b) ? (a) : (b))
-#define MAX(a,b)    ((a) > (b) ? (a) : (b))
-#define IN_RANGE(min,val,max) ((min)<=(val) && (val)<=(max))
-
-#define ABS(a)  ((a<0)?(a*-1):a)
-
-#if !(defined(ARRAY_SIZE))
-#define ARRAY_SIZE(arr)   (sizeof(arr) / sizeof((arr)[0]))
-#endif /* !defined(ARRAY_SIZE) */
-
-
-/* possible alignments */
-#define HALF_WORD_ALIGNMENT     2
-#define WORD_ALIGNMENT          4
-#define DOUBLE_WORD_ALIGNMENT   8
-#define BURST_ALIGNMENT         32
-
-#define HALF_WORD_ALIGNED       0x00000001
-#define WORD_ALIGNED            0x00000003
-#define DOUBLE_WORD_ALIGNED     0x00000007
-#define BURST_ALIGNED           0x0000001f
-#ifndef IS_ALIGNED
-#define IS_ALIGNED(n,align)     (!((uint32_t)(n) & (align - 1)))
-#endif /* IS_ALIGNED */
-
-
-#define LAST_BUF        1
-#define FIRST_BUF       2
-#define SINGLE_BUF      (LAST_BUF | FIRST_BUF)
-#define MIDDLE_BUF      4
-
-#define ARRAY_END       -1
-
-#define ILLEGAL_BASE    (~0)
-
-#define BUF_POSITION(first, last)   state[(!!(last))<<1 | !!(first)]
-#define DECLARE_POSITION static uint8_t state[4] = { (uint8_t)MIDDLE_BUF, (uint8_t)FIRST_BUF, (uint8_t)LAST_BUF, (uint8_t)SINGLE_BUF };
-
-
-/**************************************************************************//**
- @Description   Timers operation mode
-*//***************************************************************************/
-typedef enum e_TimerMode
-{
-    e_TIMER_MODE_INVALID = 0,
-    e_TIMER_MODE_FREE_RUN,    /**< Free run - counter continues to increase
-                                   after reaching the reference value. */
-    e_TIMER_MODE_PERIODIC,    /**< Periodic - counter restarts counting from 0
-                                   after reaching the reference value. */
-    e_TIMER_MODE_SINGLE       /**< Single (one-shot) - counter stops counting
-                                   after reaching the reference value. */
-} e_TimerMode;
-
-
-/**************************************************************************//**
- @Description   Enumeration (bit flags) of communication modes (Transmit,
-                receive or both).
-*//***************************************************************************/
-typedef enum e_CommMode
-{
-    e_COMM_MODE_NONE        = 0,    /**< No transmit/receive communication */
-    e_COMM_MODE_RX          = 1,    /**< Only receive communication */
-    e_COMM_MODE_TX          = 2,    /**< Only transmit communication */
-    e_COMM_MODE_RX_AND_TX   = 3     /**< Both transmit and receive communication */
-} e_CommMode;
-
-/**************************************************************************//**
- @Description   General Diagnostic Mode
-*//***************************************************************************/
-typedef enum e_DiagMode
-{
-    e_DIAG_MODE_NONE = 0,       /**< Normal operation; no diagnostic mode */
-    e_DIAG_MODE_CTRL_LOOPBACK,  /**< Loopback in the controller */
-    e_DIAG_MODE_CHIP_LOOPBACK,  /**< Loopback in the chip but not in the
-                                     controller; e.g. IO-pins, SerDes, etc. */
-    e_DIAG_MODE_PHY_LOOPBACK,   /**< Loopback in the external PHY */
-    e_DIAG_MODE_EXT_LOOPBACK,   /**< Loopback in the external line (beyond the PHY) */
-    e_DIAG_MODE_CTRL_ECHO,      /**< Echo incoming data by the controller */
-    e_DIAG_MODE_PHY_ECHO        /**< Echo incoming data by the PHY */
-} e_DiagMode;
-
-/**************************************************************************//**
- @Description   Possible RxStore callback responses.
-*//***************************************************************************/
-typedef enum e_RxStoreResponse
-{
-      e_RX_STORE_RESPONSE_PAUSE     /**< Pause invoking callback with received data;
-                                         in polling mode, start again invoking callback
-                                         only next time user invokes the receive routine;
-                                         in interrupt mode, start again invoking callback
-                                         only next time a receive event triggers an interrupt;
-                                         in all cases, received data that are pending are not
-                                         lost, rather, their processing is temporarily deferred;
-                                         in all cases, received data are processed in the order
-                                         in which they were received. */
-    , e_RX_STORE_RESPONSE_CONTINUE  /**< Continue invoking callback with received data. */
-} e_RxStoreResponse;
-
-
-/**************************************************************************//**
- @Description   General Handle
-*//***************************************************************************/
-typedef void *      t_Handle;   /**< handle, used as object's descriptor */
-
-/**************************************************************************//**
- @Description   MUTEX type
-*//***************************************************************************/
-typedef uint32_t    t_Mutex;
-
-/**************************************************************************//**
- @Description   Error Code.
-
-                The high word of the error code is the code of the software
-                module (driver). The low word is the error type (e_ErrorType).
-                To get the values from the error code, use GET_ERROR_TYPE()
-                and GET_ERROR_MODULE().
-*//***************************************************************************/
-typedef uint32_t    t_Error;
-
-/**************************************************************************//**
- @Description   General prototype of interrupt service routine (ISR).
-
- @Param[in]     handle - Optional handle of the module handling the interrupt.
-
- @Return        None
- *//***************************************************************************/
-typedef void (t_Isr)(t_Handle handle);
-
-/**************************************************************************//**
- @Anchor        mem_attr
-
- @Collection    Memory Attributes
-
-                Various attributes of memory partitions. These values may be
-                or'ed together to create a mask of all memory attributes.
- @{
-*//***************************************************************************/
-#define MEMORY_ATTR_CACHEABLE           0x00000001
-                                        /**< Memory is cacheable */
-#define MEMORY_ATTR_QE_2ND_BUS_ACCESS   0x00000002
-                                        /**< Memory can be accessed by QUICC Engine
-                                             through its secondary bus interface */
-
-/* @} */
-
-
-/**************************************************************************//**
- @Function      t_GetBufFunction
-
- @Description   User callback function called by driver to get data buffer.
-
-                User provides this function. Driver invokes it.
-
- @Param[in]     h_BufferPool        - A handle to buffer pool manager
- @Param[out]    p_BufContextHandle  - Returns the user's private context that
-                                      should be associated with the buffer
-
- @Return        Pointer to data buffer, NULL if error
- *//***************************************************************************/
-typedef uint8_t * (t_GetBufFunction)(t_Handle   h_BufferPool,
-                                     t_Handle   *p_BufContextHandle);
-
-/**************************************************************************//**
- @Function      t_PutBufFunction
-
- @Description   User callback function called by driver to return data buffer.
-
-                User provides this function. Driver invokes it.
-
- @Param[in]     h_BufferPool    - A handle to buffer pool manager
- @Param[in]     p_Buffer        - A pointer to buffer to return
- @Param[in]     h_BufContext    - The user's private context associated with
-                                  the returned buffer
-
- @Return        E_OK on success; Error code otherwise
- *//***************************************************************************/
-typedef t_Error (t_PutBufFunction)(t_Handle h_BufferPool,
-                                   uint8_t  *p_Buffer,
-                                   t_Handle h_BufContext);
-
-/**************************************************************************//**
- @Function      t_PhysToVirt
-
- @Description   Translates a physical address to the matching virtual address.
-
- @Param[in]     addr - The physical address to translate.
-
- @Return        Virtual address.
-*//***************************************************************************/
-typedef void * t_PhysToVirt(physAddress_t addr);
-
-/**************************************************************************//**
- @Function      t_VirtToPhys
-
- @Description   Translates a virtual address to the matching physical address.
-
- @Param[in]     addr - The virtual address to translate.
-
- @Return        Physical address.
-*//***************************************************************************/
-typedef physAddress_t t_VirtToPhys(void *addr);
-
-/**************************************************************************//**
- @Description   Buffer Pool Information Structure.
-*//***************************************************************************/
-typedef struct t_BufferPoolInfo
-{
-    t_Handle            h_BufferPool;   /**< A handle to the buffer pool manager */
-    t_GetBufFunction    *f_GetBuf;      /**< User callback to get a free buffer */
-    t_PutBufFunction    *f_PutBuf;      /**< User callback to return a buffer */
-    uint16_t            bufferSize;     /**< Buffer size (in bytes) */
-
-    t_PhysToVirt        *f_PhysToVirt;  /**< User callback to translate pool buffers
-                                             physical addresses to virtual addresses  */
-    t_VirtToPhys        *f_VirtToPhys;  /**< User callback to translate pool buffers
-                                             virtual addresses to physical addresses */
-} t_BufferPoolInfo;
-
-
-/**************************************************************************//**
- @Description   User callback function called by driver when transmit completed.
-
-                User provides this function. Driver invokes it.
-
- @Param[in]     h_App           - Application's handle, as was provided to the
-                                  driver by the user
- @Param[in]     queueId         - Transmit queue ID
- @Param[in]     p_Data          - Pointer to the data buffer
- @Param[in]     h_BufContext    - The user's private context associated with
-                                  the given data buffer
- @Param[in]     status          - Transmit status and errors
- @Param[in]     flags           - Driver-dependent information
- *//***************************************************************************/
-typedef void (t_TxConfFunction)(t_Handle    h_App,
-                                uint32_t    queueId,
-                                uint8_t     *p_Data,
-                                t_Handle    h_BufContext,
-                                uint16_t    status,
-                                uint32_t    flags);
-
-/**************************************************************************//**
- @Description   User callback function called by driver with receive data.
-
-                User provides this function. Driver invokes it.
-
- @Param[in]     h_App           - Application's handle, as was provided to the
-                                  driver by the user
- @Param[in]     queueId         - Receive queue ID
- @Param[in]     p_Data          - Pointer to the buffer with received data
- @Param[in]     h_BufContext    - The user's private context associated with
-                                  the given data buffer
- @Param[in]     length          - Length of received data
- @Param[in]     status          - Receive status and errors
- @Param[in]     position        - Position of buffer in frame
- @Param[in]     flags           - Driver-dependent information
-
- @Retval        e_RX_STORE_RESPONSE_CONTINUE - order the driver to continue Rx
-                                               operation for all ready data.
- @Retval        e_RX_STORE_RESPONSE_PAUSE    - order the driver to stop Rx operation.
- *//***************************************************************************/
-typedef e_RxStoreResponse (t_RxStoreFunction)(t_Handle  h_App,
-                                              uint32_t  queueId,
-                                              uint8_t   *p_Data,
-                                              t_Handle  h_BufContext,
-                                              uint32_t  length,
-                                              uint16_t  status,
-                                              uint8_t   position,
-                                              uint32_t  flags);
-
-
-typedef struct t_Device {
-    uintptr_t   id;         /**< the device id */
-    int         fd;         /**< the device file descriptor */
-    t_Handle    h_UserPriv;
-    uint32_t    owners;
-} t_Device;
-
-#endif /* __NCSW_EXT_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/std_ext.h.orig	2022-05-26 11:28:30.986977256 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/std_ext.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,47 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          std_ext.h
-
- @Description   General Standard Definitions
-*//***************************************************************************/
-
-#ifndef __STD_EXT_H
-#define __STD_EXT_H
-
-
-#include "types_ext.h"
-#include "ncsw_ext.h"
-
-
-#endif /* __STD_EXT_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/types_ext.h.orig	2022-05-26 11:28:30.986977256 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/types_ext.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,106 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          types_ext.h
-
- @Description   General types Standard Definitions
-*//***************************************************************************/
-
-#ifndef __TYPES_EXT_H
-#define __TYPES_EXT_H
-
-#if defined(NCSW_LINUX)
-#include "types_linux.h"
-
-#elif defined(NCSW_LINUX_USD)
-#include "types_linux_usd.h"
-
-#elif defined(NCSW_VXWORKS)
-#include "types_vxworks.h"
-
-#elif defined(__GNUC__) && defined(__cplusplus)
-#include "types_bb_gpp.h"
-
-#elif defined(__GNUC__)
-#include "types_bb_gcc.h"
-
-#elif defined(__ghs__)
-#include "types_ghs.h"
-
-#else
-#include "types_dflt.h"
-#endif /* defined (__ROCOO__) */
-
-static __inline__ void TypesChecker(void)
-{
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(push,1)
-#endif /* defined(__MWERKS__) && ... */
-     _Packed struct strct {
-        __volatile__ int vi;
-    } _PackedType;
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(pop)
-#endif /* defined(__MWERKS__) && ... */
-    size_t          size = 0;
-    bool            tr = TRUE, fls = FALSE;
-    struct strct    *p_Struct = NULL;
-    physAddress_t   addr = 0x100;
-
-    tr          = fls;
-    p_Struct    = p_Struct;
-    size++;
-    if (tr) size++;
-
-    WRITE_UINT8(*((uint8_t*)((size_t)(addr))),
-                 GET_UINT8(*((uint8_t*)((size_t)(addr)))));
-
-    WRITE_UINT8(*((uint8_t*)((size_t)(UINT8_MAX))),
-                 GET_UINT8(*((uint8_t*)((size_t)(UINT8_MAX)))));
-    WRITE_UINT16(*((uint16_t*)((size_t)(UINT16_MAX))),
-                 GET_UINT16(*((uint16_t*)((size_t)(UINT16_MAX)))));
-    WRITE_UINT32(*((uint32_t*)((size_t)(UINT32_MAX))),
-                 GET_UINT32(*((uint32_t*)((size_t)(UINT32_MAX)))));
-    WRITE_UINT64(*((uint64_t*)((size_t)(UINT64_MAX))),
-                 GET_UINT64(*((uint64_t*)((size_t)(UINT64_MAX)))));
-    WRITE_UINT8(*((uint8_t*)((size_t)(INT8_MAX))),
-                 GET_UINT8(*((uint8_t*)((size_t)(INT8_MIN)))));
-    WRITE_UINT16(*((uint16_t*)((size_t)(INT16_MAX))),
-                 GET_UINT16(*((uint16_t*)((size_t)(INT16_MIN)))));
-    WRITE_UINT32(*((uint32_t*)((size_t)(INT32_MAX))),
-                 GET_UINT32(*((uint32_t*)((size_t)(INT32_MIN)))));
-    WRITE_UINT64(*((uint64_t*)((size_t)(INT64_MAX))),
-                 GET_UINT64(*((uint64_t*)((size_t)(INT64_MIN)))));
-}
-
-#endif /* __TYPES_EXT_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/net_ext.h.orig	2022-05-26 11:28:30.986977256 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/net_ext.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,429 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          net_ext.h
-
- @Description   This file contains common and general netcomm headers definitions.
-*//***************************************************************************/
-#ifndef __NET_EXT_H
-#define __NET_EXT_H
-
-#include "std_ext.h"
-
-
-typedef uint8_t headerFieldPpp_t;
-
-#define NET_HEADER_FIELD_PPP_PID                        (1)
-#define NET_HEADER_FIELD_PPP_COMPRESSED                 (NET_HEADER_FIELD_PPP_PID << 1)
-#define NET_HEADER_FIELD_PPP_ALL_FIELDS                 ((NET_HEADER_FIELD_PPP_PID << 2) - 1)
-
-
-typedef uint8_t headerFieldPppoe_t;
-
-#define NET_HEADER_FIELD_PPPoE_VER                      (1)
-#define NET_HEADER_FIELD_PPPoE_TYPE                     (NET_HEADER_FIELD_PPPoE_VER << 1)
-#define NET_HEADER_FIELD_PPPoE_CODE                     (NET_HEADER_FIELD_PPPoE_VER << 2)
-#define NET_HEADER_FIELD_PPPoE_SID                      (NET_HEADER_FIELD_PPPoE_VER << 3)
-#define NET_HEADER_FIELD_PPPoE_LEN                      (NET_HEADER_FIELD_PPPoE_VER << 4)
-#define NET_HEADER_FIELD_PPPoE_SESSION                  (NET_HEADER_FIELD_PPPoE_VER << 5)
-#define NET_HEADER_FIELD_PPPoE_PID                      (NET_HEADER_FIELD_PPPoE_VER << 6)
-#define NET_HEADER_FIELD_PPPoE_ALL_FIELDS               ((NET_HEADER_FIELD_PPPoE_VER << 7) - 1)
-
-#define NET_HEADER_FIELD_PPPMUX_PID                     (1)
-#define NET_HEADER_FIELD_PPPMUX_CKSUM                   (NET_HEADER_FIELD_PPPMUX_PID << 1)
-#define NET_HEADER_FIELD_PPPMUX_COMPRESSED              (NET_HEADER_FIELD_PPPMUX_PID << 2)
-#define NET_HEADER_FIELD_PPPMUX_ALL_FIELDS              ((NET_HEADER_FIELD_PPPMUX_PID << 3) - 1)
-
-#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF            (1)
-#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_LXT            (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 1)
-#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_LEN            (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 2)
-#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_PID            (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 3)
-#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_USE_PID        (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 4)
-#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_ALL_FIELDS     ((NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 5) - 1)
-
-
-typedef uint8_t headerFieldEth_t;
-
-#define NET_HEADER_FIELD_ETH_DA                         (1)
-#define NET_HEADER_FIELD_ETH_SA                         (NET_HEADER_FIELD_ETH_DA << 1)
-#define NET_HEADER_FIELD_ETH_LENGTH                     (NET_HEADER_FIELD_ETH_DA << 2)
-#define NET_HEADER_FIELD_ETH_TYPE                       (NET_HEADER_FIELD_ETH_DA << 3)
-#define NET_HEADER_FIELD_ETH_FINAL_CKSUM                (NET_HEADER_FIELD_ETH_DA << 4)
-#define NET_HEADER_FIELD_ETH_PADDING                    (NET_HEADER_FIELD_ETH_DA << 5)
-#define NET_HEADER_FIELD_ETH_ALL_FIELDS                 ((NET_HEADER_FIELD_ETH_DA << 6) - 1)
-
-#define NET_HEADER_FIELD_ETH_ADDR_SIZE                 6
-
-typedef uint16_t headerFieldIp_t;
-
-#define NET_HEADER_FIELD_IP_VER                         (1)
-#define NET_HEADER_FIELD_IP_DSCP                        (NET_HEADER_FIELD_IP_VER << 2)
-#define NET_HEADER_FIELD_IP_ECN                         (NET_HEADER_FIELD_IP_VER << 3)
-#define NET_HEADER_FIELD_IP_PROTO                       (NET_HEADER_FIELD_IP_VER << 4)
-
-#define NET_HEADER_FIELD_IP_PROTO_SIZE                  1
-
-typedef uint16_t headerFieldIpv4_t;
-
-#define NET_HEADER_FIELD_IPv4_VER                       (1)
-#define NET_HEADER_FIELD_IPv4_HDR_LEN                   (NET_HEADER_FIELD_IPv4_VER << 1)
-#define NET_HEADER_FIELD_IPv4_TOS                       (NET_HEADER_FIELD_IPv4_VER << 2)
-#define NET_HEADER_FIELD_IPv4_TOTAL_LEN                 (NET_HEADER_FIELD_IPv4_VER << 3)
-#define NET_HEADER_FIELD_IPv4_ID                        (NET_HEADER_FIELD_IPv4_VER << 4)
-#define NET_HEADER_FIELD_IPv4_FLAG_D                    (NET_HEADER_FIELD_IPv4_VER << 5)
-#define NET_HEADER_FIELD_IPv4_FLAG_M                    (NET_HEADER_FIELD_IPv4_VER << 6)
-#define NET_HEADER_FIELD_IPv4_OFFSET                    (NET_HEADER_FIELD_IPv4_VER << 7)
-#define NET_HEADER_FIELD_IPv4_TTL                       (NET_HEADER_FIELD_IPv4_VER << 8)
-#define NET_HEADER_FIELD_IPv4_PROTO                     (NET_HEADER_FIELD_IPv4_VER << 9)
-#define NET_HEADER_FIELD_IPv4_CKSUM                     (NET_HEADER_FIELD_IPv4_VER << 10)
-#define NET_HEADER_FIELD_IPv4_SRC_IP                    (NET_HEADER_FIELD_IPv4_VER << 11)
-#define NET_HEADER_FIELD_IPv4_DST_IP                    (NET_HEADER_FIELD_IPv4_VER << 12)
-#define NET_HEADER_FIELD_IPv4_OPTS                      (NET_HEADER_FIELD_IPv4_VER << 13)
-#define NET_HEADER_FIELD_IPv4_OPTS_COUNT                (NET_HEADER_FIELD_IPv4_VER << 14)
-#define NET_HEADER_FIELD_IPv4_ALL_FIELDS                ((NET_HEADER_FIELD_IPv4_VER << 15) - 1)
-
-#define NET_HEADER_FIELD_IPv4_ADDR_SIZE                 4
-#define NET_HEADER_FIELD_IPv4_PROTO_SIZE                1
-
-
-typedef uint8_t headerFieldIpv6_t;
-
-#define NET_HEADER_FIELD_IPv6_VER                       (1)
-#define NET_HEADER_FIELD_IPv6_TC                        (NET_HEADER_FIELD_IPv6_VER << 1)
-#define NET_HEADER_FIELD_IPv6_SRC_IP                    (NET_HEADER_FIELD_IPv6_VER << 2)
-#define NET_HEADER_FIELD_IPv6_DST_IP                    (NET_HEADER_FIELD_IPv6_VER << 3)
-#define NET_HEADER_FIELD_IPv6_NEXT_HDR                  (NET_HEADER_FIELD_IPv6_VER << 4)
-#define NET_HEADER_FIELD_IPv6_FL                        (NET_HEADER_FIELD_IPv6_VER << 5)
-#define NET_HEADER_FIELD_IPv6_HOP_LIMIT                 (NET_HEADER_FIELD_IPv6_VER << 6)
-#define NET_HEADER_FIELD_IPv6_ALL_FIELDS                ((NET_HEADER_FIELD_IPv6_VER << 7) - 1)
-
-#define NET_HEADER_FIELD_IPv6_ADDR_SIZE                 16
-#define NET_HEADER_FIELD_IPv6_NEXT_HDR_SIZE             1
-
-#define NET_HEADER_FIELD_ICMP_TYPE                      (1)
-#define NET_HEADER_FIELD_ICMP_CODE                      (NET_HEADER_FIELD_ICMP_TYPE << 1)
-#define NET_HEADER_FIELD_ICMP_CKSUM                     (NET_HEADER_FIELD_ICMP_TYPE << 2)
-#define NET_HEADER_FIELD_ICMP_ID                        (NET_HEADER_FIELD_ICMP_TYPE << 3)
-#define NET_HEADER_FIELD_ICMP_SQ_NUM                    (NET_HEADER_FIELD_ICMP_TYPE << 4)
-#define NET_HEADER_FIELD_ICMP_ALL_FIELDS                ((NET_HEADER_FIELD_ICMP_TYPE << 5) - 1)
-
-#define NET_HEADER_FIELD_ICMP_CODE_SIZE                 1
-#define NET_HEADER_FIELD_ICMP_TYPE_SIZE                 1
-
-#define NET_HEADER_FIELD_IGMP_VERSION                   (1)
-#define NET_HEADER_FIELD_IGMP_TYPE                      (NET_HEADER_FIELD_IGMP_VERSION << 1)
-#define NET_HEADER_FIELD_IGMP_CKSUM                     (NET_HEADER_FIELD_IGMP_VERSION << 2)
-#define NET_HEADER_FIELD_IGMP_DATA                      (NET_HEADER_FIELD_IGMP_VERSION << 3)
-#define NET_HEADER_FIELD_IGMP_ALL_FIELDS                ((NET_HEADER_FIELD_IGMP_VERSION << 4) - 1)
-
-
-typedef uint16_t headerFieldTcp_t;
-
-#define NET_HEADER_FIELD_TCP_PORT_SRC                   (1)
-#define NET_HEADER_FIELD_TCP_PORT_DST                   (NET_HEADER_FIELD_TCP_PORT_SRC << 1)
-#define NET_HEADER_FIELD_TCP_SEQ                        (NET_HEADER_FIELD_TCP_PORT_SRC << 2)
-#define NET_HEADER_FIELD_TCP_ACK                        (NET_HEADER_FIELD_TCP_PORT_SRC << 3)
-#define NET_HEADER_FIELD_TCP_OFFSET                     (NET_HEADER_FIELD_TCP_PORT_SRC << 4)
-#define NET_HEADER_FIELD_TCP_FLAGS                      (NET_HEADER_FIELD_TCP_PORT_SRC << 5)
-#define NET_HEADER_FIELD_TCP_WINDOW                     (NET_HEADER_FIELD_TCP_PORT_SRC << 6)
-#define NET_HEADER_FIELD_TCP_CKSUM                      (NET_HEADER_FIELD_TCP_PORT_SRC << 7)
-#define NET_HEADER_FIELD_TCP_URGPTR                     (NET_HEADER_FIELD_TCP_PORT_SRC << 8)
-#define NET_HEADER_FIELD_TCP_OPTS                       (NET_HEADER_FIELD_TCP_PORT_SRC << 9)
-#define NET_HEADER_FIELD_TCP_OPTS_COUNT                 (NET_HEADER_FIELD_TCP_PORT_SRC << 10)
-#define NET_HEADER_FIELD_TCP_ALL_FIELDS                 ((NET_HEADER_FIELD_TCP_PORT_SRC << 11) - 1)
-
-#define NET_HEADER_FIELD_TCP_PORT_SIZE                  2
-
-
-typedef uint8_t headerFieldSctp_t;
-
-#define NET_HEADER_FIELD_SCTP_PORT_SRC                  (1)
-#define NET_HEADER_FIELD_SCTP_PORT_DST                  (NET_HEADER_FIELD_SCTP_PORT_SRC << 1)
-#define NET_HEADER_FIELD_SCTP_VER_TAG                   (NET_HEADER_FIELD_SCTP_PORT_SRC << 2)
-#define NET_HEADER_FIELD_SCTP_CKSUM                     (NET_HEADER_FIELD_SCTP_PORT_SRC << 3)
-#define NET_HEADER_FIELD_SCTP_ALL_FIELDS                ((NET_HEADER_FIELD_SCTP_PORT_SRC << 4) - 1)
-
-#define NET_HEADER_FIELD_SCTP_PORT_SIZE                 2
-
-typedef uint8_t headerFieldDccp_t;
-
-#define NET_HEADER_FIELD_DCCP_PORT_SRC                  (1)
-#define NET_HEADER_FIELD_DCCP_PORT_DST                  (NET_HEADER_FIELD_DCCP_PORT_SRC << 1)
-#define NET_HEADER_FIELD_DCCP_ALL_FIELDS                ((NET_HEADER_FIELD_DCCP_PORT_SRC << 2) - 1)
-
-#define NET_HEADER_FIELD_DCCP_PORT_SIZE                 2
-
-
-typedef uint8_t headerFieldUdp_t;
-
-#define NET_HEADER_FIELD_UDP_PORT_SRC                   (1)
-#define NET_HEADER_FIELD_UDP_PORT_DST                   (NET_HEADER_FIELD_UDP_PORT_SRC << 1)
-#define NET_HEADER_FIELD_UDP_LEN                        (NET_HEADER_FIELD_UDP_PORT_SRC << 2)
-#define NET_HEADER_FIELD_UDP_CKSUM                      (NET_HEADER_FIELD_UDP_PORT_SRC << 3)
-#define NET_HEADER_FIELD_UDP_ALL_FIELDS                 ((NET_HEADER_FIELD_UDP_PORT_SRC << 4) - 1)
-
-#define NET_HEADER_FIELD_UDP_PORT_SIZE                  2
-
-typedef uint8_t headerFieldUdpLite_t;
-
-#define NET_HEADER_FIELD_UDP_LITE_PORT_SRC              (1)
-#define NET_HEADER_FIELD_UDP_LITE_PORT_DST              (NET_HEADER_FIELD_UDP_LITE_PORT_SRC << 1)
-#define NET_HEADER_FIELD_UDP_LITE_ALL_FIELDS            ((NET_HEADER_FIELD_UDP_LITE_PORT_SRC << 2) - 1)
-
-#define NET_HEADER_FIELD_UDP_LITE_PORT_SIZE             2
-
-typedef uint8_t headerFieldUdpEncapEsp_t;
-
-#define NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC         (1)
-#define NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST         (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 1)
-#define NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN              (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 2)
-#define NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM            (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 3)
-#define NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI              (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 4)
-#define NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM     (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 5)
-#define NET_HEADER_FIELD_UDP_ENCAP_ESP_ALL_FIELDS       ((NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 6) - 1)
-
-#define NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SIZE        2
-#define NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI_SIZE         4
-
-#define NET_HEADER_FIELD_IPHC_CID                       (1)
-#define NET_HEADER_FIELD_IPHC_CID_TYPE                  (NET_HEADER_FIELD_IPHC_CID << 1)
-#define NET_HEADER_FIELD_IPHC_HCINDEX                   (NET_HEADER_FIELD_IPHC_CID << 2)
-#define NET_HEADER_FIELD_IPHC_GEN                       (NET_HEADER_FIELD_IPHC_CID << 3)
-#define NET_HEADER_FIELD_IPHC_D_BIT                     (NET_HEADER_FIELD_IPHC_CID << 4)
-#define NET_HEADER_FIELD_IPHC_ALL_FIELDS                ((NET_HEADER_FIELD_IPHC_CID << 5) - 1)
-
-#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE           (1)
-#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_FLAGS          (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 1)
-#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_LENGTH         (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 2)
-#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_TSN            (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 3)
-#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_ID      (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 4)
-#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_SQN     (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 5)
-#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_PAYLOAD_PID    (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 6)
-#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_UNORDERED      (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 7)
-#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_BEGGINING      (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 8)
-#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_END            (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 9)
-#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_ALL_FIELDS     ((NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 10) - 1)
-
-#define NET_HEADER_FIELD_L2TPv2_TYPE_BIT                (1)
-#define NET_HEADER_FIELD_L2TPv2_LENGTH_BIT              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 1)
-#define NET_HEADER_FIELD_L2TPv2_SEQUENCE_BIT            (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 2)
-#define NET_HEADER_FIELD_L2TPv2_OFFSET_BIT              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 3)
-#define NET_HEADER_FIELD_L2TPv2_PRIORITY_BIT            (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 4)
-#define NET_HEADER_FIELD_L2TPv2_VERSION                 (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 5)
-#define NET_HEADER_FIELD_L2TPv2_LEN                     (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 6)
-#define NET_HEADER_FIELD_L2TPv2_TUNNEL_ID               (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 7)
-#define NET_HEADER_FIELD_L2TPv2_SESSION_ID              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 8)
-#define NET_HEADER_FIELD_L2TPv2_NS                      (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 9)
-#define NET_HEADER_FIELD_L2TPv2_NR                      (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 10)
-#define NET_HEADER_FIELD_L2TPv2_OFFSET_SIZE             (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 11)
-#define NET_HEADER_FIELD_L2TPv2_FIRST_BYTE              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 12)
-#define NET_HEADER_FIELD_L2TPv2_ALL_FIELDS              ((NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 13) - 1)
-
-#define NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT           (1)
-#define NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH_BIT         (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 1)
-#define NET_HEADER_FIELD_L2TPv3_CTRL_SEQUENCE_BIT       (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 2)
-#define NET_HEADER_FIELD_L2TPv3_CTRL_VERSION            (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 3)
-#define NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH             (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 4)
-#define NET_HEADER_FIELD_L2TPv3_CTRL_CONTROL            (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 5)
-#define NET_HEADER_FIELD_L2TPv3_CTRL_SENT               (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 6)
-#define NET_HEADER_FIELD_L2TPv3_CTRL_RECV               (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 7)
-#define NET_HEADER_FIELD_L2TPv3_CTRL_FIRST_BYTE         (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 8)
-#define NET_HEADER_FIELD_L2TPv3_CTRL_ALL_FIELDS         ((NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 9) - 1)
-
-#define NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT           (1)
-#define NET_HEADER_FIELD_L2TPv3_SESS_VERSION            (NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 1)
-#define NET_HEADER_FIELD_L2TPv3_SESS_ID                 (NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 2)
-#define NET_HEADER_FIELD_L2TPv3_SESS_COOKIE             (NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 3)
-#define NET_HEADER_FIELD_L2TPv3_SESS_ALL_FIELDS         ((NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 4) - 1)
-
-
-typedef uint8_t headerFieldVlan_t;
-
-#define NET_HEADER_FIELD_VLAN_VPRI                      (1)
-#define NET_HEADER_FIELD_VLAN_CFI                       (NET_HEADER_FIELD_VLAN_VPRI << 1)
-#define NET_HEADER_FIELD_VLAN_VID                       (NET_HEADER_FIELD_VLAN_VPRI << 2)
-#define NET_HEADER_FIELD_VLAN_LENGTH                    (NET_HEADER_FIELD_VLAN_VPRI << 3)
-#define NET_HEADER_FIELD_VLAN_TYPE                      (NET_HEADER_FIELD_VLAN_VPRI << 4)
-#define NET_HEADER_FIELD_VLAN_ALL_FIELDS                ((NET_HEADER_FIELD_VLAN_VPRI << 5) - 1)
-
-#define NET_HEADER_FIELD_VLAN_TCI                       (NET_HEADER_FIELD_VLAN_VPRI | \
-                                                         NET_HEADER_FIELD_VLAN_CFI | \
-                                                         NET_HEADER_FIELD_VLAN_VID)
-
-
-typedef uint8_t headerFieldLlc_t;
-
-#define NET_HEADER_FIELD_LLC_DSAP                       (1)
-#define NET_HEADER_FIELD_LLC_SSAP                       (NET_HEADER_FIELD_LLC_DSAP << 1)
-#define NET_HEADER_FIELD_LLC_CTRL                       (NET_HEADER_FIELD_LLC_DSAP << 2)
-#define NET_HEADER_FIELD_LLC_ALL_FIELDS                 ((NET_HEADER_FIELD_LLC_DSAP << 3) - 1)
-
-#define NET_HEADER_FIELD_NLPID_NLPID                    (1)
-#define NET_HEADER_FIELD_NLPID_ALL_FIELDS               ((NET_HEADER_FIELD_NLPID_NLPID << 1) - 1)
-
-
-typedef uint8_t headerFieldSnap_t;
-
-#define NET_HEADER_FIELD_SNAP_OUI                       (1)
-#define NET_HEADER_FIELD_SNAP_PID                       (NET_HEADER_FIELD_SNAP_OUI << 1)
-#define NET_HEADER_FIELD_SNAP_ALL_FIELDS                ((NET_HEADER_FIELD_SNAP_OUI << 2) - 1)
-
-
-typedef uint8_t headerFieldLlcSnap_t;
-
-#define NET_HEADER_FIELD_LLC_SNAP_TYPE                  (1)
-#define NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS            ((NET_HEADER_FIELD_LLC_SNAP_TYPE << 1) - 1)
-
-#define NET_HEADER_FIELD_ARP_HTYPE                      (1)
-#define NET_HEADER_FIELD_ARP_PTYPE                      (NET_HEADER_FIELD_ARP_HTYPE << 1)
-#define NET_HEADER_FIELD_ARP_HLEN                       (NET_HEADER_FIELD_ARP_HTYPE << 2)
-#define NET_HEADER_FIELD_ARP_PLEN                       (NET_HEADER_FIELD_ARP_HTYPE << 3)
-#define NET_HEADER_FIELD_ARP_OPER                       (NET_HEADER_FIELD_ARP_HTYPE << 4)
-#define NET_HEADER_FIELD_ARP_SHA                        (NET_HEADER_FIELD_ARP_HTYPE << 5)
-#define NET_HEADER_FIELD_ARP_SPA                        (NET_HEADER_FIELD_ARP_HTYPE << 6)
-#define NET_HEADER_FIELD_ARP_THA                        (NET_HEADER_FIELD_ARP_HTYPE << 7)
-#define NET_HEADER_FIELD_ARP_TPA                        (NET_HEADER_FIELD_ARP_HTYPE << 8)
-#define NET_HEADER_FIELD_ARP_ALL_FIELDS                 ((NET_HEADER_FIELD_ARP_HTYPE << 9) - 1)
-
-#define NET_HEADER_FIELD_RFC2684_LLC                    (1)
-#define NET_HEADER_FIELD_RFC2684_NLPID                  (NET_HEADER_FIELD_RFC2684_LLC << 1)
-#define NET_HEADER_FIELD_RFC2684_OUI                    (NET_HEADER_FIELD_RFC2684_LLC << 2)
-#define NET_HEADER_FIELD_RFC2684_PID                    (NET_HEADER_FIELD_RFC2684_LLC << 3)
-#define NET_HEADER_FIELD_RFC2684_VPN_OUI                (NET_HEADER_FIELD_RFC2684_LLC << 4)
-#define NET_HEADER_FIELD_RFC2684_VPN_IDX                (NET_HEADER_FIELD_RFC2684_LLC << 5)
-#define NET_HEADER_FIELD_RFC2684_ALL_FIELDS             ((NET_HEADER_FIELD_RFC2684_LLC << 6) - 1)
-
-#define NET_HEADER_FIELD_USER_DEFINED_SRCPORT           (1)
-#define NET_HEADER_FIELD_USER_DEFINED_PCDID             (NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 1)
-#define NET_HEADER_FIELD_USER_DEFINED_ALL_FIELDS        ((NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 2) - 1)
-
-#define NET_HEADER_FIELD_PAYLOAD_BUFFER                 (1)
-#define NET_HEADER_FIELD_PAYLOAD_SIZE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 1)
-#define NET_HEADER_FIELD_MAX_FRM_SIZE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 2)
-#define NET_HEADER_FIELD_MIN_FRM_SIZE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 3)
-#define NET_HEADER_FIELD_PAYLOAD_TYPE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 4)
-#define NET_HEADER_FIELD_FRAME_SIZE                     (NET_HEADER_FIELD_PAYLOAD_BUFFER << 5)
-#define NET_HEADER_FIELD_PAYLOAD_ALL_FIELDS             ((NET_HEADER_FIELD_PAYLOAD_BUFFER << 6) - 1)
-
-
-typedef uint8_t headerFieldGre_t;
-
-#define NET_HEADER_FIELD_GRE_TYPE                       (1)
-#define NET_HEADER_FIELD_GRE_ALL_FIELDS                 ((NET_HEADER_FIELD_GRE_TYPE << 1) - 1)
-
-
-typedef uint8_t headerFieldMinencap_t;
-
-#define NET_HEADER_FIELD_MINENCAP_SRC_IP                (1)
-#define NET_HEADER_FIELD_MINENCAP_DST_IP                (NET_HEADER_FIELD_MINENCAP_SRC_IP << 1)
-#define NET_HEADER_FIELD_MINENCAP_TYPE                  (NET_HEADER_FIELD_MINENCAP_SRC_IP << 2)
-#define NET_HEADER_FIELD_MINENCAP_ALL_FIELDS            ((NET_HEADER_FIELD_MINENCAP_SRC_IP << 3) - 1)
-
-
-typedef uint8_t headerFieldIpsecAh_t;
-
-#define NET_HEADER_FIELD_IPSEC_AH_SPI                   (1)
-#define NET_HEADER_FIELD_IPSEC_AH_NH                    (NET_HEADER_FIELD_IPSEC_AH_SPI << 1)
-#define NET_HEADER_FIELD_IPSEC_AH_ALL_FIELDS            ((NET_HEADER_FIELD_IPSEC_AH_SPI << 2) - 1)
-
-
-typedef uint8_t headerFieldIpsecEsp_t;
-
-#define NET_HEADER_FIELD_IPSEC_ESP_SPI                  (1)
-#define NET_HEADER_FIELD_IPSEC_ESP_SEQUENCE_NUM         (NET_HEADER_FIELD_IPSEC_ESP_SPI << 1)
-#define NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS           ((NET_HEADER_FIELD_IPSEC_ESP_SPI << 2) - 1)
-
-#define NET_HEADER_FIELD_IPSEC_ESP_SPI_SIZE             4
-
-
-typedef uint8_t headerFieldMpls_t;
-
-#define NET_HEADER_FIELD_MPLS_LABEL_STACK               (1)
-#define NET_HEADER_FIELD_MPLS_LABEL_STACK_ALL_FIELDS    ((NET_HEADER_FIELD_MPLS_LABEL_STACK << 1) - 1)
-
-
-typedef uint8_t headerFieldMacsec_t;
-
-#define NET_HEADER_FIELD_MACSEC_SECTAG                  (1)
-#define NET_HEADER_FIELD_MACSEC_ALL_FIELDS              ((NET_HEADER_FIELD_MACSEC_SECTAG << 1) - 1)
-
-
-typedef enum {
-    HEADER_TYPE_NONE = 0,
-    HEADER_TYPE_PAYLOAD,
-    HEADER_TYPE_ETH,
-    HEADER_TYPE_VLAN,
-    HEADER_TYPE_IPv4,
-    HEADER_TYPE_IPv6,
-    HEADER_TYPE_IP,
-    HEADER_TYPE_TCP,
-    HEADER_TYPE_UDP,
-    HEADER_TYPE_UDP_LITE,
-    HEADER_TYPE_IPHC,
-    HEADER_TYPE_SCTP,
-    HEADER_TYPE_SCTP_CHUNK_DATA,
-    HEADER_TYPE_PPPoE,
-    HEADER_TYPE_PPP,
-    HEADER_TYPE_PPPMUX,
-    HEADER_TYPE_PPPMUX_SUBFRAME,
-    HEADER_TYPE_L2TPv2,
-    HEADER_TYPE_L2TPv3_CTRL,
-    HEADER_TYPE_L2TPv3_SESS,
-    HEADER_TYPE_LLC,
-    HEADER_TYPE_LLC_SNAP,
-    HEADER_TYPE_NLPID,
-    HEADER_TYPE_SNAP,
-    HEADER_TYPE_MPLS,
-    HEADER_TYPE_IPSEC_AH,
-    HEADER_TYPE_IPSEC_ESP,
-    HEADER_TYPE_UDP_ENCAP_ESP, /* RFC 3948 */
-    HEADER_TYPE_MACSEC,
-    HEADER_TYPE_GRE,
-    HEADER_TYPE_MINENCAP,
-    HEADER_TYPE_DCCP,
-    HEADER_TYPE_ICMP,
-    HEADER_TYPE_IGMP,
-    HEADER_TYPE_ARP,
-    HEADER_TYPE_CAPWAP,
-    HEADER_TYPE_CAPWAP_DTLS,
-    HEADER_TYPE_RFC2684,
-    HEADER_TYPE_USER_DEFINED_L2,
-    HEADER_TYPE_USER_DEFINED_L3,
-    HEADER_TYPE_USER_DEFINED_L4,
-    HEADER_TYPE_USER_DEFINED_SHIM1,
-    HEADER_TYPE_USER_DEFINED_SHIM2,
-    MAX_HEADER_TYPE_COUNT
-} e_NetHeaderType;
-
-
-#endif /* __NET_EXT_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/types_linux.h.orig	2022-05-26 11:28:30.986977256 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/types_linux.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,162 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-#ifndef __TYPES_LINUX_H
-#define __TYPES_LINUX_H
-#ifdef __GNUC__
-/* __inline__ is already valid in GNUC */
-#define _Packed
-#define _PackedType __attribute__ ((packed))
-#else   /* ! __GNUC__ */
-#define _PackedType
-#endif
-
-#ifdef DIAB
-#define _Packed __packed__
-#endif
-
-#ifdef _DIAB_TOOL
-#define _Packed __packed__
-#define __asm__ asm
-#define __volatile__ volatile
-#endif
-
-/* type definitions */
-#if defined(__KERNEL__)
-# include <linux/types.h>
-#else
-# include <stdint.h>
-# include <stddef.h>
-# include <stdbool.h>
-#endif
-
-#ifdef NETCOMMSW_ALIASING
-#define uint8_t        _NETCOMMSW_UINT8_T_
-#define uint16_t       _NETCOMMSW_UINT16_T_
-#define uint32_t       _NETCOMMSW_UINT32_T_
-#define uint64_t       _NETCOMMSW_UINT64_T_
-#define int8_t         _NETCOMMSW_INT8_T_
-#define int16_t        _NETCOMMSW_INT16_T_
-#define int32_t        _NETCOMMSW_INT32_T_
-#define int64_t        _NETCOMMSW_INT64_T_
-#define float_t        _NETCOMMSW_FLOAT_T_
-#define double_t       _NETCOMMSW_DOUBLE_T_
-#define bool           _NETCOMMSW_BOOL_
-#endif /* NETCOMMSW_ALIASING */
-
-/* physAddress_t should be uintptr_t */
-typedef uint64_t physAddress_t;
-
-#if (defined(__cplusplus))
-#undef FALSE
-#undef TRUE
-#define FALSE   false
-#define TRUE    true
-/* bool is already defined */
-
-#else
-#undef FALSE
-#undef TRUE
-#define FALSE   0
-#define TRUE    1
-/* TOBE removed: typedef char bool;*/
-#endif /* defined(__cplusplus) */
-
-/************************/
-/* Memory access macros */
-/************************/
-#define GET_UINT32(arg)             *(volatile uint32_t*)(&(arg))
-#define GET_UINT64(arg)             *(volatile uint64_t*)(&(arg))
-
-#define _WRITE_UINT32(arg, data)    *(volatile uint32_t*)(&(arg)) = (data)
-#define _WRITE_UINT64(arg, data)    *(volatile uint64_t*)(&(arg)) = (data)
-
-#ifndef QE_32_BIT_ACCESS_RESTRICTION
-
-#define GET_UINT8(arg)              *(volatile uint8_t *)(&(arg))
-#define GET_UINT16(arg)             *(volatile uint16_t*)(&(arg))
-
-#define _WRITE_UINT8(arg, data)     *(volatile uint8_t *)(&(arg)) = (data)
-#define _WRITE_UINT16(arg, data)    *(volatile uint16_t*)(&(arg)) = (data)
-
-#else  /* QE_32_BIT_ACCESS_RESTRICTION */
-
-#define QE_32_BIT_ADDR(_arg)        (uint32_t)((uint32_t)&(_arg) & 0xFFFFFFFC)
-#define QE_32_BIT_SHIFT8(__arg)     (uint32_t)((3 - ((uint32_t)&(__arg) & 0x3)) * 8)
-#define QE_32_BIT_SHIFT16(__arg)    (uint32_t)((2 - ((uint32_t)&(__arg) & 0x3)) * 8)
-
-#define GET_UINT8(arg)              (uint8_t)((*(volatile uint32_t *)QE_32_BIT_ADDR(arg)) >> QE_32_BIT_SHIFT8(arg))
-#define GET_UINT16(arg)             (uint16_t)((*(volatile uint32_t *)QE_32_BIT_ADDR(arg)) >> QE_32_BIT_SHIFT16(arg))
-
-#define _WRITE_UINT8(arg, data)                                                                         \
-    do                                                                                                  \
-    {                                                                                                   \
-        uint32_t addr = QE_32_BIT_ADDR(arg);                                                            \
-        uint32_t shift = QE_32_BIT_SHIFT8(arg);                                                         \
-        uint32_t tmp = *(volatile uint32_t *)addr;                                                      \
-        tmp = (uint32_t)((tmp & ~(0x000000FF << shift)) | ((uint32_t)(data & 0x000000FF) << shift));    \
-        *(volatile uint32_t *)addr = tmp;                                                               \
-    } while (0)
-
-#define _WRITE_UINT16(arg, data)                                                                        \
-    do                                                                                                  \
-    {                                                                                                   \
-        uint32_t addr = QE_32_BIT_ADDR(arg);                                                            \
-        uint32_t shift = QE_32_BIT_SHIFT16(arg);                                                        \
-        uint32_t tmp = *(volatile uint32_t *)addr;                                                      \
-        tmp = (uint32_t)((tmp & ~(0x0000FFFF << shift)) | ((uint32_t)(data & 0x0000FFFF) << shift));    \
-        *(volatile uint32_t *)addr = tmp;                                                               \
-    } while (0)
-
-#endif /* QE_32_BIT_ACCESS_RESTRICTION */
-
-
-#ifdef VERBOSE_WRITE
-
-#define WRITE_UINT8(arg, data)  \
-    do { XX_Print("ADDR: 0x%08x, VAL: 0x%02x\r\n",    (uint32_t)&(arg), (data)); _WRITE_UINT8((arg), (data)); } while (0)
-#define WRITE_UINT16(arg, data) \
-    do { XX_Print("ADDR: 0x%08x, VAL: 0x%04x\r\n",    (uint32_t)&(arg), (data)); _WRITE_UINT16((arg), (data)); } while (0)
-#define WRITE_UINT32(arg, data) \
-    do { XX_Print("ADDR: 0x%08x, VAL: 0x%08x\r\n",    (uint32_t)&(arg), (data)); _WRITE_UINT32((arg), (data)); } while (0)
-#define WRITE_UINT64(arg, data) \
-    do { XX_Print("ADDR: 0x%08x, VAL: 0x%016llx\r\n", (uint32_t)&(arg), (data)); _WRITE_UINT64((arg), (data)); } while (0)
-
-#else  /* not VERBOSE_WRITE */
-
-#define WRITE_UINT8                 _WRITE_UINT8
-#define WRITE_UINT16                _WRITE_UINT16
-#define WRITE_UINT32                _WRITE_UINT32
-#define WRITE_UINT64                _WRITE_UINT64
-
-#endif /* not VERBOSE_WRITE */
-#endif /* __TYPES_LINUX_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/xx_ext.h.orig	2022-05-26 11:28:30.986977256 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/xx_ext.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,816 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          xx_ext.h
-
- @Description   Prototypes, externals and typedefs for system-supplied
-                (external) routines
-*//***************************************************************************/
-
-#ifndef __XX_EXT_H
-#define __XX_EXT_H
-
-#include <stdlib.h>
-#include <stdio.h>
-
-#include "std_ext.h"
-#include "part_ext.h"
-
-#if defined(NCSW_LINUX) && defined(NCSW_MULTI_PARTITION)
-#error "NCSW_MULTI_PARTITION not supported in NCSW_LINUX!"
-#endif  /* NCSW_LINUX && NCSW_MULTI_PARTITION */
-
-
-/**************************************************************************//**
- @Group         xx_id  XX Interface (System call hooks)
-
- @Description   Prototypes, externals and typedefs for system-supplied
-                (external) routines
-
- @{
-*//***************************************************************************/
-
-#ifdef DEBUG_XX_MALLOC
-void * XX_MallocDebug(uint32_t size, char *fname, int line);
-
-void * XX_MallocSmartDebug(uint32_t size,
-                           int      memPartitionId,
-                           uint32_t alignment,
-                           char     *fname,
-                           int      line);
-
-#define XX_Malloc(sz) \
-    XX_MallocDebug((sz), __FILE__, __LINE__)
-
-#define XX_MallocSmart(sz, memt, al) \
-    XX_MallocSmartDebug((sz), (memt), (al), __FILE__, __LINE__)
-
-#else /* not DEBUG_XX_MALLOC */
-/**************************************************************************//**
- @Function      XX_Malloc
-
- @Description   allocates contiguous block of memory.
-
- @Param[in]     size - Number of bytes to allocate.
-
- @Return        The address of the newly allocated block on success, NULL on failure.
-*//***************************************************************************/
-#define XX_Malloc(size) XX_MallocSmart(size, 0, 0)
-
-/**************************************************************************//**
- @Function      XX_MallocSmart
-
- @Description   Allocates contiguous block of memory in a specified
-                alignment and from the specified segment.
-
- @Param[in]     size            - Number of bytes to allocate.
- @Param[in]     memPartitionId  - Memory partition ID; The value zero must
-                                  be mapped to the default heap partition.
- @Param[in]     alignment       - Required memory alignment (in bytes).
-
- @Return        The address of the newly allocated block on success, NULL on failure.
-*//***************************************************************************/
-void * XX_MallocSmart(uint32_t size, int memPartitionId, uint32_t alignment);
-#endif /* not DEBUG_XX_MALLOC */
-
-/**************************************************************************//**
- @Function      XX_FreeSmart
-
- @Description   Frees the memory block pointed to by "p".
-                Only for memory allocated by XX_MallocSmart
-
- @Param[in]     p_Memory - pointer to the memory block.
-
- @Return        None.
-*//***************************************************************************/
-#define XX_FreeSmart(p)  free((uint8_t*)(p) - sizeof(void*))
-
-/**************************************************************************//**
- @Function      XX_Free
-
- @Description   frees the memory block pointed to by "p".
-
- @Param[in]     p_Memory - pointer to the memory block.
-
- @Return        None.
-*//***************************************************************************/
-#define XX_Free(p) XX_FreeSmart(p)
-
-/**************************************************************************//**
- @Function      XX_Print
-
- @Description   print a string.
-
- @Param[in]     str - string to print.
-
- @Return        None.
-*//***************************************************************************/
-#define   XX_Print		printf
-
-/**************************************************************************//**
- @Function      XX_EnableIntr
-
- @Description   Enable a specific interrupt.
-
- @Param[in]     irq - Interrupt ID (system-specific number).
-
- @Return        E_OK on success; error code otherwise..
-*//***************************************************************************/
-#define XX_EnableIntr(irq)  (E_OK)
-
-/**************************************************************************//**
- @Function      XX_DisableIntr
-
- @Description   Disable a specific interrupt.
-
- @Param[in]     irq - Interrupt ID (system-specific number).
-
- @Return        E_OK on success; error code otherwise..
-*//***************************************************************************/
-#define XX_DisableIntr(irq) (E_OK)
-
-/**************************************************************************//**
- @Function      XX_DisableAllIntr
-
- @Description   Disable all interrupts by masking them at the CPU.
-
- @Return        A value that represents the interrupts state before the
-                operation, and should be passed to the matching
-                XX_RestoreAllIntr() call.
-*//***************************************************************************/
-#define XX_DisableAllIntr()     (0L) 
-
-/**************************************************************************//**
- @Function      XX_RestoreAllIntr
-
- @Description   Restore previous state of interrupts level at the CPU.
-
- @Param[in]     flags - A value that represents the interrupts state to restore,
-                        as returned by the matching call for XX_DisableAllIntr().
-
- @Return        None.
-*//***************************************************************************/
-#define XX_RestoreAllIntr(flags)    UNUSED(flags)
-
-/**************************************************************************//**
- @Function      XX_Exit
-
- @Description   Stop execution and report status (where it is applicable)
-
- @Param[in]     status - exit status
-*//***************************************************************************/
-#define	XX_Exit(status)	exit(status)
-
-/*****************************************************************************/
-/*                        Tasklet Service Routines                           */
-/*****************************************************************************/
-typedef t_Handle t_TaskletHandle;
-
-/**************************************************************************//**
- @Function      XX_InitTasklet
-
- @Description   Create and initialize a tasklet object.
-
- @Param[in]     routine - A routine to be ran as a tasklet.
- @Param[in]     data    - An argument to pass to the tasklet.
-
- @Return        Tasklet handle is returned on success. NULL is returned otherwise.
-*//***************************************************************************/
-t_TaskletHandle XX_InitTasklet (void (*routine)(void *), void *data);
-
-/**************************************************************************//**
- @Function      XX_FreeTasklet
-
- @Description   Free a tasklet object.
-
- @Param[in]     h_Tasklet - A handle to a tasklet to be free.
-
- @Return        None.
-*//***************************************************************************/
-#define XX_FreeTasklet(h_Tasklet)   XX_Free(h_Tasklet)
-
-/**************************************************************************//**
- @Function      XX_ScheduleTask
-
- @Description   Schedule a tasklet object.
-
- @Param[in]     h_Tasklet - A handle to a tasklet to be scheduled.
- @Param[in]     immediate - Indicate whether to schedule this tasklet on
-                            the immediate queue or on the delayed one.
-
- @Return        0 - on success. Error code - otherwise.
-*//***************************************************************************/
-int XX_ScheduleTask(t_TaskletHandle h_Tasklet, int immediate);
-
-/**************************************************************************//**
- @Function      XX_FlushScheduledTasks
-
- @Description   Flush all tasks there are in the scheduled tasks queue.
-
- @Return        None.
-*//***************************************************************************/
-#define XX_FlushScheduledTasks()
-
-/**************************************************************************//**
- @Function      XX_TaskletIsQueued
-
- @Description   Check if task is queued.
-
- @Param[in]     h_Tasklet - A handle to a tasklet to be scheduled.
-
- @Return        1 - task is queued. 0 - otherwise.
-*//***************************************************************************/
-int XX_TaskletIsQueued(t_TaskletHandle h_Tasklet);
-
-/**************************************************************************//**
- @Function      XX_SetTaskletData
-
- @Description   Set data to a scheduled task. Used to change data of already
-                scheduled task.
-
- @Param[in]     h_Tasklet - A handle to a tasklet to be scheduled.
- @Param[in]     data      - Data to be set.
-*//***************************************************************************/
-void XX_SetTaskletData(t_TaskletHandle h_Tasklet, t_Handle data);
-
-/**************************************************************************//**
- @Function      XX_GetTaskletData
-
- @Description   Get the data of scheduled task.
-
- @Param[in]     h_Tasklet - A handle to a tasklet to be scheduled.
-
- @Return        handle to the data of the task.
-*//***************************************************************************/
-t_Handle XX_GetTaskletData(t_TaskletHandle h_Tasklet);
-
-/**************************************************************************//**
- @Function      XX_BottomHalf
-
- @Description   Bottom half implementation, invoked by the interrupt handler.
-
-                This routine handles all bottom-half tasklets with interrupts
-                enabled.
-
- @Return        None.
-*//***************************************************************************/
-void XX_BottomHalf(void);
-
-
-#ifdef NCSW_SMP
-#include <pthread.h>
-/*****************************************************************************/
-/*                        Spinlock Service Routines                          */
-/*****************************************************************************/
-
-/**************************************************************************//**
- @Function      XX_InitSpinlock
-
- @Description   Creates a spinlock.
-
- @Return        Spinlock handle is returned on success; NULL otherwise.
-*//***************************************************************************/
-t_Handle XX_InitSpinlock(void);
-
-/**************************************************************************//**
- @Function      XX_FreeSpinlock
-
- @Description   Frees the memory allocated for the spinlock creation.
-
- @Param[in]     h_Spinlock - A handle to a spinlock.
-
- @Return        None.
-*//***************************************************************************/
-void XX_FreeSpinlock(t_Handle h_Spinlock);
-
-/**************************************************************************//**
- @Function      XX_LockSpinlock
-
- @Description   Locks a spinlock.
-
- @Param[in]     h_Spinlock - A handle to a spinlock.
-
- @Return        None.
-*//***************************************************************************/
-#define XX_LockSpinlock(h_Spinlock)    pthread_mutex_lock(h_Spinlock)
-
-/**************************************************************************//**
- @Function      XX_UnlockSpinlock
-
- @Description   Unlocks a spinlock.
-
- @Param[in]     h_Spinlock - A handle to a spinlock.
-
- @Return        None.
-*//***************************************************************************/
-#define	XX_UnlockSpinlock(h_Spinlock)  pthread_mutex_unlock(h_Spinlock)
-
-#else   /* NCSW_SMP */
-#define XX_InitSpinlock()                   ((t_Handle) 1)
-#define XX_FreeSpinlock(h_Spinlock)         UNUSED(h_Spinlock)
-#define XX_LockSpinlock(h_Spinlock)         UNUSED(h_Spinlock)
-#define	XX_UnlockSpinlock(h_Spinlock)       UNUSED(h_Spinlock)
-#endif  /* NCSW_SMP */
-
-/**************************************************************************//**
- @Function      XX_LockIntrSpinlock
-
- @Description   Locks a spinlock (interrupt safe).
-
- @Param[in]     h_Spinlock - A handle to a spinlock.
-
- @Return        A value that represents the interrupts state before the
-                operation, and should be passed to the matching
-                XX_UnlockIntrSpinlock() call.
-*//***************************************************************************/
-#define XX_LockIntrSpinlock(h_Spinlock) \
-        ({ XX_LockSpinlock(h_Spinlock); 0L;})
-
-/**************************************************************************//**
- @Function      XX_UnlockIntrSpinlock
-
- @Description   Unlocks a spinlock (interrupt safe).
-
- @Param[in]     h_Spinlock  - A handle to a spinlock.
- @Param[in]     intrFlags   - A value that represents the interrupts state to
-                              restore, as returned by the matching call for
-                              XX_LockIntrSpinlock().
-
- @Return        None.
-*//***************************************************************************/
-#define XX_UnlockIntrSpinlock(h_Spinlock, intrFlags) \
-        XX_UnlockSpinlock(h_Spinlock)
-
-
-/*****************************************************************************/
-/*                        Timers Service Routines                            */
-/*****************************************************************************/
-
-/**************************************************************************//**
- @Function      XX_CurrentTime
-
- @Description   Returns current system time.
-
- @Return        Current system time (in milliseconds).
-*//***************************************************************************/
-uint32_t XX_CurrentTime(void);
-
-/**************************************************************************//**
- @Function      XX_CreateTimer
-
- @Description   Creates a timer.
-
- @Return        Timer handle is returned on success; NULL otherwise.
-*//***************************************************************************/
-t_Handle XX_CreateTimer(void);
-
-/**************************************************************************//**
- @Function      XX_FreeTimer
-
- @Description   Frees the memory allocated for the timer creation.
-
- @Param[in]     h_Timer - A handle to a timer.
-
- @Return        None.
-*//***************************************************************************/
-void XX_FreeTimer(t_Handle h_Timer);
-
-/**************************************************************************//**
- @Function      XX_StartTimer
-
- @Description   Starts a timer.
-
-                The user can select to start the timer as periodic timer or as
-                one-shot timer. The user should provide a callback routine that
-                will be called when the timer expires.
-
- @Param[in]     h_Timer         - A handle to a timer.
- @Param[in]     msecs           - Timer expiration period (in milliseconds).
- @Param[in]     periodic        - TRUE for a periodic timer;
-                                  FALSE for a one-shot timer..
- @Param[in]     f_TimerExpired  - A callback routine to be called when the
-                                  timer expires.
- @Param[in]     h_Arg           - The argument to pass in the timer-expired
-                                  callback routine.
-
- @Return        None.
-*//***************************************************************************/
-void XX_StartTimer(t_Handle h_Timer,
-                   uint32_t msecs,
-                   bool     periodic,
-                   void     (*f_TimerExpired)(t_Handle h_Arg),
-                   t_Handle h_Arg);
-
-/**************************************************************************//**
- @Function      XX_StopTimer
-
- @Description   Frees the memory allocated for the timer creation.
-
- @Param[in]     h_Timer - A handle to a timer.
-
- @Return        None.
-*//***************************************************************************/
-void XX_StopTimer(t_Handle h_Timer);
-
-/**************************************************************************//**
- @Function      XX_GetExpirationTime
-
- @Description   Returns the time (in milliseconds) remaining until the
-                expiration of a timer.
-
- @Param[in]     h_Timer - A handle to a timer.
-
- @Return        The time left until the timer expires.
-*//***************************************************************************/
-uint32_t XX_GetExpirationTime(t_Handle h_Timer);
-
-/**************************************************************************//**
- @Function      XX_ModTimer
-
- @Description   Updates the expiration time of a timer.
-
-                This routine adds the given time to the current system time,
-                and sets this value as the new expiration time of the timer.
-
- @Param[in]     h_Timer - A handle to a timer.
- @Param[in]     msecs   - The new interval until timer expiration
-                          (in milliseconds).
-
- @Return        None.
-*//***************************************************************************/
-void XX_ModTimer(t_Handle h_Timer, uint32_t msecs);
-
-/**************************************************************************//**
- @Function      XX_TimerIsActive
-
- @Description   Checks whether a timer is active (pending) or not.
-
- @Param[in]     h_Timer - A handle to a timer.
-
- @Return        0 - the timer is inactive; Non-zero value - the timer is active;
-*//***************************************************************************/
-int XX_TimerIsActive(t_Handle h_Timer);
-
-/**************************************************************************//**
- @Function      XX_Sleep
-
- @Description   Non-busy wait until the desired time (in milliseconds) has passed.
-
- @Param[in]     msecs - The requested sleep time (in milliseconds).
-
- @Return        Zero if the requested time has elapsed; Otherwise, the value
-                returned will be the unslept amount) in milliseconds.
-
- @Cautions      This routine enables interrupts during its wait time.
-*//***************************************************************************/
-uint32_t XX_Sleep(uint32_t msecs);
-
-/**************************************************************************//**
- @Function      XX_UDelay
-
- @Description   Busy-wait until the desired time (in microseconds) has passed.
-
- @Param[in]     usecs - The requested delay time (in microseconds).
-
- @Return        None.
-
- @Cautions      It is highly unrecommended to call this routine during interrupt
-                time, because the system time may not be updated properly during
-                the delay loop. The behavior of this routine during interrupt
-                time is unexpected.
-*//***************************************************************************/
-#define XX_UDELAY_MAX   50000000
-void XX_UDelay(uint32_t usecs);
-
-
-/*****************************************************************************/
-/*                         Other Service Routines                            */
-/*****************************************************************************/
-
-/**************************************************************************//**
- @Function      XX_PhysToVirt
-
- @Description   Translates a physical address to the matching virtual address.
-
- @Param[in]     addr - The physical address to translate.
-
- @Return        Virtual address.
-*//***************************************************************************/
-#define XX_PhysToVirt(p_addr)                   \
-        ({ REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, \
-                        ("No physical addrs. in userspace!")); NULL; })
-
-/**************************************************************************//**
- @Function      XX_VirtToPhys
-
- @Description   Translates a virtual address to the matching physical address.
-
- @Param[in]     addr - The virtual address to translate.
-
- @Return        Physical address.
-*//***************************************************************************/
-#define XX_VirtToPhys(v_addr)                   \
-        ({ REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, \
-                        ("No physical addrs. in userspace!")); (physAddress_t) 0; })
-
-
-#ifdef NCSW_MULTI_PARTITION
-/**************************************************************************//**
- @Group         xx_ipc  XX Inter-Partition-Communication API
-
- @Description   The following API is to be used when working with multiple
-                partitions configuration.
-
- @{
-*//***************************************************************************/
-
-#define XX_IPC_MAX_ADDR_NAME_LENGTH 16         /**< Maximum length of an endpoint name string;
-                                                    The IPC service can use this constant to limit
-                                                    the storage space for IPC endpoint names. */
-
-
-/**************************************************************************//**
- @Function      t_IpcMsgCompletion
-
- @Description   Callback function used upon IPC non-blocking transaction completion
-                to return message buffer to the caller and to forward reply if available.
-
-                This callback function may be attached by the source endpoint to any outgoing
-                IPC message to indicate a non-blocking send (see also XX_IpcSendMessage() routine).
-                Upon completion of an IPC transaction (consisting of a message and an optional reply),
-                the IPC service invokes this callback routine to return the message buffer to the sender
-                and to provide the received reply, if requested.
-
-                User provides this function. Driver invokes it.
-
- @Param[in]     h_Module        - Abstract handle to the sending module -  the same handle as was passed
-                                  in the XX_IpcSendMessage() function; This handle is typically used to point
-                                  to the internal data structure of the source endpoint.
- @Param[in]     p_Msg           - Pointer to original (sent) message buffer;
-                                  The source endpoint can free (or reuse) this buffer when message
-                                  completion callback is called.
- @Param[in]     p_Reply         - Pointer to (received) reply buffer;
-                                  This pointer is the same as was provided by the source endpoint in
-                                  XX_IpcSendMessage().
- @Param[in]     replyLength     - Length (in bytes) of actual data in the reply buffer.
- @Param[in]     status          - Completion status - E_OK or failure indication, e.g. IPC transaction completion
-                                  timeout.
-
- @Return        None
- *//***************************************************************************/
-typedef void    (t_IpcMsgCompletion)(t_Handle   h_Module,
-                                     uint8_t    *p_Msg,
-                                     uint8_t    *p_Reply,
-                                     uint32_t   replyLength,
-                                     t_Error    status);
-
-/**************************************************************************//**
- @Function      t_IpcMsgHandler
-
- @Description   Callback function used as IPC message handler.
-
-                The IPC service invokes message handlers for each IPC message received.
-                The actual function pointer should be registered by each destination endpoint
-                via the XX_IpcRegisterMsgHandler() routine.
-
-                User provides this function. Driver invokes it.
-
- @Param[in]     h_Module        - Abstract handle to the message handling module -  the same handle as
-                                  was passed in the XX_IpcRegisterMsgHandler() function; this handle is
-                                  typically used to point to the internal data structure of the destination
-                                  endpoint.
- @Param[in]     p_Msg           - Pointer to message buffer with data received from peer.
- @Param[in]     msgLength       - Length (in bytes) of message data.
- @Param[in]     p_Reply         - Pointer to reply buffer, to be filled by the message handler and then sent
-                                  by the IPC service;
-                                  The reply buffer is allocated by the IPC service with size equals to the
-                                  replyLength parameter provided in message handler registration (see
-                                  XX_IpcRegisterMsgHandler() function);
-                                  If replyLength was initially specified as zero during message handler registration,
-                                  the IPC service may set this pointer to NULL and assume that a reply is not needed;
-                                  The IPC service is also responsible for freeing the reply buffer after the
-                                  reply has been sent or dismissed.
- @Param[in,out] p_ReplyLength   - Pointer to reply length, which has a dual role in this function:
-                                  [In] equals the replyLength parameter provided in message handler
-                                  registration (see XX_IpcRegisterMsgHandler() function), and
-                                  [Out] should be updated by message handler to the actual reply length; if
-                                  this value is set to zero, the IPC service must assume that a reply should
-                                  not be sent;
-                                  Note: If p_Reply is not NULL, p_ReplyLength must not be NULL as well.
-
- @Return        E_OK on success; Error code otherwise.
- *//***************************************************************************/
-typedef t_Error (t_IpcMsgHandler)(t_Handle  h_Module,
-                                  uint8_t   *p_Msg,
-                                  uint32_t  msgLength,
-                                  uint8_t   *p_Reply,
-                                  uint32_t  *p_ReplyLength);
-
-/**************************************************************************//**
- @Function      XX_IpcRegisterMsgHandler
-
- @Description   IPC mailbox registration.
-
-                This function is used for registering an IPC message handler in the IPC service.
-                This function is called by each destination endpoint to indicate that it is ready
-                to handle incoming messages. The IPC service invokes the message handler upon receiving
-                a message addressed to the specified destination endpoint.
-
- @Param[in]     addr                - The address name string associated with the destination endpoint;
-                                      This address must be unique across the IPC service domain to ensure
-                                      correct message routing.
- @Param[in]     f_MsgHandler        - Pointer to the message handler callback for processing incoming
-                                      message; invoked by the IPC service upon receiving a message
-                                      addressed to the destination endpoint specified by the addr
-                                      parameter.
- @Param[in]     h_Module            - Abstract handle to the message handling module, passed unchanged
-                                      to f_MsgHandler callback function.
- @Param[in]     replyLength         - The maximal data length (in bytes) of any reply that the specified message handler
-                                      may generate; the IPC service provides the message handler with buffer
-                                      for reply according to the length specified here (refer also to the description
-                                      of #t_IpcMsgHandler callback function type);
-                                      This size shall be zero if the message handler never generates replies.
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error XX_IpcRegisterMsgHandler(char                   addr[XX_IPC_MAX_ADDR_NAME_LENGTH],
-                                 t_IpcMsgHandler        *f_MsgHandler,
-                                 t_Handle               h_Module,
-                                 uint32_t               replyLength);
-
-/**************************************************************************//**
- @Function      XX_IpcUnregisterMsgHandler
-
- @Description   Release IPC mailbox routine.
-
-                 This function is used for unregistering an IPC message handler from the IPC service.
-                 This function is called by each destination endpoint to indicate that it is no longer
-                 capable of handling incoming messages.
-
- @Param[in]     addr          - The address name string associated with the destination endpoint;
-                                This address is the same as was used when the message handler was
-                                registered via XX_IpcRegisterMsgHandler().
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error XX_IpcUnregisterMsgHandler(char addr[XX_IPC_MAX_ADDR_NAME_LENGTH]);
-
-/**************************************************************************//**
- @Function      XX_IpcInitSession
-
- @Description   This function is used for creating an IPC session between the source endpoint
-                and the destination endpoint.
-
-                The actual implementation and representation of a session is left for the IPC service.
-                The function returns an abstract handle to the created session. This handle shall be used
-                by the source endpoint in subsequent calls to XX_IpcSendMessage().
-                The IPC service assumes that before this function is called, no messages are sent from
-                the specified source endpoint to the specified destination endpoint.
-
-                The IPC service may use a connection-oriented approach or a connectionless approach (or both)
-                as described below.
-
-                @par Connection-Oriented Approach
-
-                The IPC service may implement a session in a connection-oriented approach -  when this function is called,
-                the IPC service should take the necessary steps to bring up a source-to-destination channel for messages
-                and a destination-to-source channel for replies. The returned handle should represent the internal
-                representation of these channels.
-
-                @par Connectionless Approach
-
-                The IPC service may implement a session in a connectionless approach -  when this function is called, the
-                IPC service should not perform any particular steps, but it must store the pair of source and destination
-                addresses in some session representation and return it as a handle. When XX_IpcSendMessage() shall be
-                called, the IPC service may use this handle to provide the necessary identifiers for routing the messages
-                through the connectionless medium.
-
- @Param[in]     destAddr      - The address name string associated with the destination endpoint.
- @Param[in]     srcAddr       - The address name string associated with the source endpoint.
-
- @Return        Abstract handle to the initialized session, or NULL on error.
-*//***************************************************************************/
-t_Handle XX_IpcInitSession(char destAddr[XX_IPC_MAX_ADDR_NAME_LENGTH],
-                           char srcAddr[XX_IPC_MAX_ADDR_NAME_LENGTH]);
-
-/**************************************************************************//**
- @Function      XX_IpcFreeSession
-
- @Description   This function is used for terminating an existing IPC session between a source endpoint
-                and a destination endpoint.
-
-                The IPC service assumes that after this function is called, no messages shall be sent from
-                the associated source endpoint to the associated destination endpoint.
-
- @Param[in]     h_Session      - Abstract handle to the IPC session -  the same handle as was originally
-                                 returned by the XX_IpcInitSession() function.
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error XX_IpcFreeSession(t_Handle h_Session);
-
-/**************************************************************************//**
- @Function      XX_IpcSendMessage
-
- @Description   IPC message send routine.
-
-                This function may be used by a source endpoint to send an IPC message to a destination
-                endpoint. The source endpoint cannot send a message to the destination endpoint without
-                first initiating a session with that destination endpoint via XX_IpcInitSession() routine.
-
-                The source endpoint must provide the buffer pointer and length of the outgoing message.
-                Optionally, it may also provide a buffer for an expected reply. In the latter case, the
-                transaction is not considered complete by the IPC service until the reply has been received.
-                If the source endpoint does not provide a reply buffer, the transaction is considered
-                complete after the message has been sent. The source endpoint must keep the message (and
-                optional reply) buffers valid until the transaction is complete.
-
-                @par Non-blocking mode
-
-                The source endpoint may request a non-blocking send by providing a non-NULL pointer to a message
-                completion callback function (f_Completion). Upon completion of the IPC transaction (consisting of a
-                message and an optional reply), the IPC service invokes this callback routine to return the message
-                buffer to the sender and to provide the received reply, if requested.
-
-                @par Blocking mode
-
-                The source endpoint may request a blocking send by setting f_Completion to NULL. The function is
-                expected to block until the IPC transaction is complete -  either the reply has been received or (if no reply
-                was requested) the message has been sent.
-
- @Param[in]     h_Session       - Abstract handle to the IPC session -  the same handle as was originally
-                                  returned by the XX_IpcInitSession() function.
- @Param[in]     p_Msg           - Pointer to message buffer to send.
- @Param[in]     msgLength       - Length (in bytes) of actual data in the message buffer.
- @Param[in]     p_Reply         - Pointer to reply buffer -  if this buffer is not NULL, the IPC service
-                                  fills this buffer with the received reply data;
-                                  In blocking mode, the reply data must be valid when the function returns;
-                                  In non-blocking mode, the reply data is valid when f_Completion is called;
-                                  If this pointer is NULL, no reply is expected.
- @Param[in,out] p_ReplyLength   - Pointer to reply length, which has a dual role in this function:
-                                  [In] specifies the maximal length (in bytes) of the reply buffer pointed by
-                                  p_Reply, and
-                                  [Out] in non-blocking mode this value is updated by the IPC service to the
-                                  actual reply length (in bytes).
- @Param[in]     f_Completion    - Pointer to a completion callback to be used in non-blocking send mode;
-                                  The completion callback is invoked by the IPC service upon
-                                  completion of the IPC transaction (consisting of a message and an optional
-                                  reply);
-                                  If this pointer is NULL, the function is expected to block until the IPC
-                                  transaction is complete.
- @Param[in]     h_Arg           - Abstract handle to the sending module; passed unchanged to the f_Completion
-                                  callback function as the first argument.
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error XX_IpcSendMessage(t_Handle           h_Session,
-                          uint8_t            *p_Msg,
-                          uint32_t           msgLength,
-                          uint8_t            *p_Reply,
-                          uint32_t           *p_ReplyLength,
-                          t_IpcMsgCompletion *f_Completion,
-                          t_Handle           h_Arg);
-
-#else /* NCSW_MULTI_PARTITION */
-#define XX_IpcRegisterMsgHandler(a,b,c,d)   (E_OK)
-#define XX_IpcUnregisterMsgHandler(a)       (E_OK)
-#define XX_IpcInitSession(a,b)              (E_OK)
-#define XX_IpcFreeSession(a)                (E_OK)
-#define XX_IpcSendMessage(a,b,c,d,e,f,g)    (E_OK)
-#endif /* NCSW_MULTI_PARTITION */
-
-/** @} */ /* end of xx_ipc group */
-/** @} */ /* end of xx_id group */
-
-
-#endif /* __XX_EXT_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/error_ext.h.orig	2022-05-26 11:28:30.982977418 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/error_ext.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,529 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          error_ext.h
-
- @Description   Error definitions.
-*//***************************************************************************/
-
-#ifndef __ERROR_EXT_H
-#define __ERROR_EXT_H
-
-#include <errno.h>
-
-#include "std_ext.h"
-#include "xx_ext.h"
-
-
-
-/**************************************************************************//**
- @Group         gen_id  General Drivers Utilities
-
- @Description   External routines.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Group         gen_error_id  Errors, Events and Debug
-
- @Description   External routines.
-
- @{
-*//***************************************************************************/
-
-/******************************************************************************
-The scheme below provides the bits description for error codes:
-
- 0    1    2    3    4    5    6    7    8    9    10   11   12   13   14   15
-|       Reserved (should be zero)      |              Module ID               |
-
- 16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31
-|                               Error Type                                    |
-******************************************************************************/
-
-#define ERROR_CODE(_err)            ((((uint32_t)_err) & 0x0000FFFF) | __ERR_MODULE__)
-
-#define GET_ERROR_TYPE(_errcode)    ((_errcode) & 0x0000FFFF)
-                                /**< Extract module code from error code (#t_Error) */
-
-#define GET_ERROR_MODULE(_errcode)  ((_errcode) & 0x00FF0000)
-                                /**< Extract error type (#e_ErrorType) from
-                                     error code (#t_Error) */
-
-
-/**************************************************************************//**
- @Description    Error Type Enumeration
-*//***************************************************************************/
-typedef enum e_ErrorType    /*   Comments / Associated Message Strings                      */
-{                           /* ------------------------------------------------------------ */
-    E_OK = 0                /*   Never use "RETURN_ERROR" with E_OK; Use "return E_OK;"     */
-    ,E_WRITE_FAILED = EIO   /**< Write access failed on memory/device.                      */
-                            /*   String: none, or device name.                              */
-    ,E_NO_DEVICE = ENXIO    /**< The associated device is not initialized.                  */
-                            /*   String: none.                                              */
-    ,E_NOT_AVAILABLE = EAGAIN
-                            /**< Resource is unavailable.                                   */
-                            /*   String: none, unless the operation is not the main goal
-                                 of the function (in this case add resource description).   */
-    ,E_NO_MEMORY = ENOMEM   /**< External memory allocation failed.                         */
-                            /*   String: description of item for which allocation failed.   */
-    ,E_INVALID_ADDRESS = EFAULT
-                            /**< Invalid address.                                           */
-                            /*   String: description of the specific violation.             */
-    ,E_BUSY = EBUSY         /**< Resource or module is busy.                                */
-                            /*   String: none, unless the operation is not the main goal
-                                 of the function (in this case add resource description).   */
-    ,E_ALREADY_EXISTS = EEXIST
-                            /**< Requested resource or item already exists.                 */
-                            /*   Use when resource duplication or sharing are not allowed.
-                                 String: none, unless the operation is not the main goal
-                                 of the function (in this case add item description).       */
-    ,E_INVALID_OPERATION = ENODEV
-                            /**< The operation/command is invalid (unrecognized).           */
-                            /*   String: none.                                              */
-    ,E_INVALID_VALUE = EDOM /**< Invalid value.                                             */
-                            /*   Use for non-enumeration parameters, and
-                                 only when other error types are not suitable.
-                                 String: parameter description + "(should be <attribute>)",
-                                 e.g: "Maximum Rx buffer length (should be divisible by 8)",
-                                      "Channel number (should be even)".                    */
-    ,E_NOT_IN_RANGE = ERANGE/**< Parameter value is out of range.                           */
-                            /*   Don't use this error for enumeration parameters.
-                                 String: parameter description + "(should be %d-%d)",
-                                 e.g: "Number of pad characters (should be 0-15)".          */
-    ,E_NOT_SUPPORTED = ENOSYS
-                            /**< The function is not supported or not implemented.          */
-                            /*   String: none.                                              */
-    ,E_INVALID_STATE        /**< The operation is not allowed in current module state.      */
-                            /*   String: none.                                              */
-    ,E_INVALID_HANDLE       /**< Invalid handle of module or object.                        */
-                            /*   String: none, unless the function takes in more than one
-                                 handle (in this case add the handle description)           */
-    ,E_INVALID_ID           /**< Invalid module ID (usually enumeration or index).          */
-                            /*   String: none, unless the function takes in more than one
-                                 ID (in this case add the ID description)                   */
-    ,E_NULL_POINTER         /**< Unexpected NULL pointer.                                   */
-                            /*   String: pointer description.                               */
-    ,E_INVALID_SELECTION    /**< Invalid selection or mode.                                 */
-                            /*   Use for enumeration values, only when other error types
-                                 are not suitable.
-                                 String: parameter description.                             */
-    ,E_INVALID_COMM_MODE    /**< Invalid communication mode.                                */
-                            /*   String: none, unless the function takes in more than one
-                                 communication mode indications (in this case add
-                                 parameter description).                                    */
-    ,E_INVALID_MEMORY_TYPE  /**< Invalid memory type.                                       */
-                            /*   String: none, unless the function takes in more than one
-                                 memory types (in this case add memory description,
-                                 e.g: "Data memory", "Buffer descriptors memory").          */
-    ,E_INVALID_CLOCK        /**< Invalid clock.                                             */
-                            /*   String: none, unless the function takes in more than one
-                                 clocks (in this case add clock description,
-                                 e.g: "Rx clock", "Tx clock").                              */
-    ,E_CONFLICT             /**< Some setting conflicts with another setting.               */
-                            /*   String: description of the conflicting settings.           */
-    ,E_NOT_ALIGNED          /**< Non-aligned address.                                       */
-                            /*   String: parameter description + "(should be %d-bytes aligned)",
-                                 e.g: "Rx data buffer (should be 32-bytes aligned)".        */
-    ,E_NOT_FOUND            /**< Requested resource or item was not found.                  */
-                            /*   Use only when the resource/item is uniquely identified.
-                                 String: none, unless the operation is not the main goal
-                                 of the function (in this case add item description).       */
-    ,E_FULL                 /**< Resource is full.                                          */
-                            /*   String: none, unless the operation is not the main goal
-                                 of the function (in this case add resource description).   */
-    ,E_EMPTY                /**< Resource is empty.                                         */
-                            /*   String: none, unless the operation is not the main goal
-                                 of the function (in this case add resource description).   */
-    ,E_ALREADY_FREE         /**< Specified resource or item is already free or deleted.     */
-                            /*   String: none, unless the operation is not the main goal
-                                 of the function (in this case add item description).       */
-    ,E_READ_FAILED          /**< Read access failed on memory/device.                       */
-                            /*   String: none, or device name.                              */
-    ,E_INVALID_FRAME        /**< Invalid frame object (NULL handle or missing buffers).     */
-                            /*   String: none.                                              */
-    ,E_SEND_FAILED          /**< Send operation failed on device.                           */
-                            /*   String: none, or device name.                              */
-    ,E_RECEIVE_FAILED       /**< Receive operation failed on device.                        */
-                            /*   String: none, or device name.                              */
-    ,E_TIMEOUT/* = ETIMEDOUT*/  /**< The operation timed out.                                   */
-                            /*   String: none.                                              */
-
-    ,E_DUMMY_LAST           /* NEVER USED */
-
-} e_ErrorType;
-
-
-/**************************************************************************//**
- @Description    Event Type Enumeration
-*//***************************************************************************/
-typedef enum e_Event        /*   Comments / Associated Flags and Message Strings            */
-{                           /* ------------------------------------------------------------ */
-    EV_NO_EVENT = 0         /**< No event; Never used.                                      */
-
-    ,EV_RX_DISCARD          /**< Received packet discarded (by the driver, and only for
-                                 complete packets);
-                                 Flags: error flags in case of error, zero otherwise.       */
-                            /*   String: reason for discard, e.g: "Error in frame",
-                                 "Disordered frame", "Incomplete frame", "No frame object". */
-    ,EV_RX_ERROR            /**< Receive error (by hardware/firmware);
-                                 Flags: usually status flags from the buffer descriptor.    */
-                            /*   String: none.                                              */
-    ,EV_TX_ERROR            /**< Transmit error (by hardware/firmware);
-                                 Flags: usually status flags from the buffer descriptor.    */
-                            /*   String: none.                                              */
-    ,EV_NO_BUFFERS          /**< System ran out of buffer objects;
-                                 Flags: zero.                                               */
-                            /*   String: none.                                              */
-    ,EV_NO_MB_FRAMES        /**< System ran out of multi-buffer frame objects;
-                                 Flags: zero.                                               */
-                            /*   String: none.                                              */
-    ,EV_NO_SB_FRAMES        /**< System ran out of single-buffer frame objects;
-                                 Flags: zero.                                               */
-                            /*   String: none.                                              */
-    ,EV_TX_QUEUE_FULL       /**< Transmit queue is full;
-                                 Flags: zero.                                               */
-                            /*   String: none.                                              */
-    ,EV_RX_QUEUE_FULL       /**< Receive queue is full;
-                                 Flags: zero.                                               */
-                            /*   String: none.                                              */
-    ,EV_INTR_QUEUE_FULL     /**< Interrupt queue overflow;
-                                 Flags: zero.                                               */
-                            /*   String: none.                                              */
-    ,EV_NO_DATA_BUFFER      /**< Data buffer allocation (from higher layer) failed;
-                                 Flags: zero.                                               */
-                            /*   String: none.                                              */
-    ,EV_OBJ_POOL_EMPTY      /**< Objects pool is empty;
-                                 Flags: zero.                                               */
-                            /*   String: object description (name).                         */
-    ,EV_BUS_ERROR           /**< Illegal access on bus;
-                                 Flags: the address (if available) or bus identifier        */
-                            /*   String: bus/address/module description.                    */
-    ,EV_PTP_TXTS_QUEUE_FULL /**< PTP Tx timestamps queue is full;
-                                 Flags: zero.                                               */
-                            /*   String: none.                                              */
-    ,EV_PTP_RXTS_QUEUE_FULL /**< PTP Rx timestamps queue is full;
-                                 Flags: zero.                                               */
-                            /*   String: none.                                              */
-    ,EV_DUMMY_LAST
-
-} e_Event;
-
-
-/**************************************************************************//**
- @Collection    Debug Levels for Errors and Events
-
-                The level description refers to errors only.
-                For events, classification is done by the user.
-
-                The TRACE, INFO and WARNING levels are allowed only when using
-                the DBG macro, and are not allowed when using the error macros
-                (RETURN_ERROR or REPORT_ERROR).
- @{
-*//***************************************************************************/
-#define REPORT_LEVEL_CRITICAL   1       /**< Crasher: Incorrect flow, NULL pointers/handles. */
-#define REPORT_LEVEL_MAJOR      2       /**< Cannot proceed: Invalid operation, parameters or
-                                             configuration. */
-#define REPORT_LEVEL_MINOR      3       /**< Recoverable problem: a repeating call with the same
-                                             parameters may be successful. */
-#define REPORT_LEVEL_WARNING    4       /**< Something is not exactly right, yet it is not an error. */
-#define REPORT_LEVEL_INFO       5       /**< Messages which may be of interest to user/programmer. */
-#define REPORT_LEVEL_TRACE      6       /**< Program flow messages. */
-
-#define EVENT_DISABLED          0xFF    /**< Disabled event (not reported at all) */
-
-/* @} */
-
-
-
-#define NO_MSG      ("")
-
-#ifndef DEBUG_GLOBAL_LEVEL
-#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_WARNING
-#endif /* DEBUG_GLOBAL_LEVEL */
-
-#ifndef ERROR_GLOBAL_LEVEL
-#define ERROR_GLOBAL_LEVEL  DEBUG_GLOBAL_LEVEL
-#endif /* ERROR_GLOBAL_LEVEL */
-
-#ifndef EVENT_GLOBAL_LEVEL
-#define EVENT_GLOBAL_LEVEL  REPORT_LEVEL_MINOR
-#endif /* EVENT_GLOBAL_LEVEL */
-
-#ifdef EVENT_LOCAL_LEVEL
-#define EVENT_DYNAMIC_LEVEL EVENT_LOCAL_LEVEL
-#else
-#define EVENT_DYNAMIC_LEVEL EVENT_GLOBAL_LEVEL
-#endif /* EVENT_LOCAL_LEVEL */
-
-
-#ifndef DEBUG_DYNAMIC_LEVEL
-#define DEBUG_USING_STATIC_LEVEL
-
-#ifdef DEBUG_STATIC_LEVEL
-#define DEBUG_DYNAMIC_LEVEL DEBUG_STATIC_LEVEL
-#else
-#define DEBUG_DYNAMIC_LEVEL DEBUG_GLOBAL_LEVEL
-#endif /* DEBUG_STATIC_LEVEL */
-
-#else /* DEBUG_DYNAMIC_LEVEL */
-#ifdef DEBUG_STATIC_LEVEL
-#error "Please use either DEBUG_STATIC_LEVEL or DEBUG_DYNAMIC_LEVEL (not both)"
-#else
-int DEBUG_DYNAMIC_LEVEL = DEBUG_GLOBAL_LEVEL;
-#endif /* DEBUG_STATIC_LEVEL */
-#endif /* !DEBUG_DYNAMIC_LEVEL */
-
-
-#ifndef ERROR_DYNAMIC_LEVEL
-
-#ifdef ERROR_STATIC_LEVEL
-#define ERROR_DYNAMIC_LEVEL ERROR_STATIC_LEVEL
-#else
-#define ERROR_DYNAMIC_LEVEL ERROR_GLOBAL_LEVEL
-#endif /* ERROR_STATIC_LEVEL */
-
-#else /* ERROR_DYNAMIC_LEVEL */
-#ifdef ERROR_STATIC_LEVEL
-#error "Please use either ERROR_STATIC_LEVEL or ERROR_DYNAMIC_LEVEL (not both)"
-#else
-int ERROR_DYNAMIC_LEVEL = ERROR_GLOBAL_LEVEL;
-#endif /* ERROR_STATIC_LEVEL */
-#endif /* !ERROR_DYNAMIC_LEVEL */
-
-#define PRINT_FORMAT        "[CPU%02d, %s:%d %s]"
-#define PRINT_FMT_PARAMS    CORE_GetId(), __FILE__, __LINE__, __FUNCTION__
-
-#if (!(defined(DEBUG_ERRORS)) || (DEBUG_ERRORS == 0))
-/* No debug/error/event messages at all */
-#define DBG(_level, _vmsg)
-
-#define REPORT_ERROR(_level, _err, _vmsg)
-
-#define RETURN_ERROR(_level, _err, _vmsg) \
-        return ERROR_CODE(_err)
-
-#ifndef REPORT_EVENTS
-#define REPORT_EVENTS 1
-#endif
-
-#if (REPORT_EVENTS > 0)
-
-#define REPORT_EVENT(_ev, _appId, _flg, _vmsg) \
-    do { \
-        if (_ev##_LEVEL <= EVENT_DYNAMIC_LEVEL) { \
-            XX_EventById((uint32_t)(_ev), (t_Handle)(_appId), (uint16_t)(_flg), NO_MSG); \
-        } \
-    } while (0)
-
-#else
-
-#define REPORT_EVENT(_ev, _appId, _flg, _vmsg)
-
-#endif /* (REPORT_EVENTS > 0) */
-
-
-#else /* DEBUG_ERRORS > 0 */
-
-extern const char *dbgLevelStrings[];
-extern const char *moduleStrings[];
-#if (REPORT_EVENTS > 0)
-extern const char *eventStrings[];
-#endif /* (REPORT_EVENTS > 0) */
-
-char * ErrTypeStrings (e_ErrorType err);
-
-
-#if ((defined(DEBUG_USING_STATIC_LEVEL)) && (DEBUG_DYNAMIC_LEVEL < REPORT_LEVEL_WARNING))
-/* No need for DBG macro - debug level is higher anyway */
-#define DBG(_level, _vmsg)
-#else
-#define DBG(_level, _vmsg) \
-    do { \
-        if (REPORT_LEVEL_##_level <= DEBUG_DYNAMIC_LEVEL) { \
-            XX_Print("> %s (%s) " PRINT_FORMAT ": ", \
-                     dbgLevelStrings[REPORT_LEVEL_##_level - 1], \
-                     moduleStrings[__ERR_MODULE__ >> 16], \
-                     PRINT_FMT_PARAMS); \
-            XX_Print _vmsg; \
-            XX_Print("\r\n"); \
-        } \
-    } while (0)
-#endif /* (defined(DEBUG_USING_STATIC_LEVEL) && (DEBUG_DYNAMIC_LEVEL < WARNING)) */
-
-
-#define REPORT_ERROR(_level, _err, _vmsg) \
-    do { \
-        if (REPORT_LEVEL_##_level <= ERROR_DYNAMIC_LEVEL) { \
-            XX_Print("! %s %s Error " PRINT_FORMAT ": %s; ", \
-                     dbgLevelStrings[REPORT_LEVEL_##_level - 1], \
-                     moduleStrings[__ERR_MODULE__ >> 16], \
-                     PRINT_FMT_PARAMS, \
-                     ErrTypeStrings((e_ErrorType)GET_ERROR_TYPE(_err))); \
-            XX_Print _vmsg; \
-            XX_Print("\r\n"); \
-        } \
-    } while (0)
-
-
-#define RETURN_ERROR(_level, _err, _vmsg) \
-    do { \
-        REPORT_ERROR(_level, (_err), _vmsg); \
-        return ERROR_CODE(_err); \
-    } while (0)
-
-
-#if (REPORT_EVENTS > 0)
-
-#define REPORT_EVENT(_ev, _appId, _flg, _vmsg) \
-    do { \
-        if (_ev##_LEVEL <= EVENT_DYNAMIC_LEVEL) { \
-            XX_Print("~ %s %s Event " PRINT_FORMAT ": %s (flags: 0x%04x); ", \
-                     dbgLevelStrings[_ev##_LEVEL - 1], \
-                     moduleStrings[__ERR_MODULE__ >> 16], \
-                     PRINT_FMT_PARAMS, \
-                     eventStrings[((_ev) - EV_NO_EVENT - 1)], \
-                     (uint16_t)(_flg)); \
-            XX_Print _vmsg; \
-            XX_Print("\r\n"); \
-            XX_EventById((uint32_t)(_ev), (t_Handle)(_appId), (uint16_t)(_flg), NO_MSG); \
-        } \
-    } while (0)
-
-#else /* not REPORT_EVENTS */
-
-#define REPORT_EVENT(_ev, _appId, _flg, _vmsg)
-
-#endif /* (REPORT_EVENTS > 0) */
-
-#endif /* (DEBUG_ERRORS > 0) */
-
-
-/**************************************************************************//**
- @Function      ASSERT_COND
-
- @Description   Assertion macro.
-
- @Param[in]     _cond - The condition being checked, in positive form;
-                        Failure of the condition triggers the assert.
-*//***************************************************************************/
-#ifdef DISABLE_ASSERTIONS
-#define ASSERT_COND(_cond)
-#else
-#define ASSERT_COND(_cond) \
-    do { \
-        if (!(_cond)) { \
-            XX_Print("*** ASSERT_COND failed " PRINT_FORMAT "\r\n", \
-                    PRINT_FMT_PARAMS); \
-            XX_Exit(1); \
-        } \
-    } while (0)
-#endif /* DISABLE_ASSERTIONS */
-
-
-#ifdef DISABLE_INIT_PARAMETERS_CHECK
-
-#define CHECK_INIT_PARAMETERS(handle, f_check)
-#define CHECK_INIT_PARAMETERS_RETURN_VALUE(handle, f_check, retval)
-
-#else
-
-#define CHECK_INIT_PARAMETERS(handle, f_check) \
-    do { \
-        t_Error err = f_check(handle); \
-        if (err != E_OK) { \
-            RETURN_ERROR(MAJOR, err, NO_MSG); \
-        } \
-    } while (0)
-
-#define CHECK_INIT_PARAMETERS_RETURN_VALUE(handle, f_check, retval) \
-    do { \
-        t_Error err = f_check(handle); \
-        if (err != E_OK) { \
-            REPORT_ERROR(MAJOR, err, NO_MSG); \
-            return (retval); \
-        } \
-    } while (0)
-
-#endif /* DISABLE_INIT_PARAMETERS_CHECK */
-
-#ifdef DISABLE_SANITY_CHECKS
-
-#define SANITY_CHECK_RETURN_ERROR(_cond, _err)
-#define SANITY_CHECK_RETURN_VALUE(_cond, _err, retval)
-#define SANITY_CHECK_RETURN(_cond, _err)
-#define SANITY_CHECK_EXIT(_cond, _err)
-
-#else /* DISABLE_SANITY_CHECKS */
-
-#define SANITY_CHECK_RETURN_ERROR(_cond, _err) \
-    do { \
-        if (!(_cond)) { \
-            RETURN_ERROR(CRITICAL, (_err), NO_MSG); \
-        } \
-    } while (0)
-
-#define SANITY_CHECK_RETURN_VALUE(_cond, _err, retval) \
-    do { \
-        if (!(_cond)) { \
-            REPORT_ERROR(CRITICAL, (_err), NO_MSG); \
-            return (retval); \
-        } \
-    } while (0)
-
-#define SANITY_CHECK_RETURN(_cond, _err) \
-    do { \
-        if (!(_cond)) { \
-            REPORT_ERROR(CRITICAL, (_err), NO_MSG); \
-            return; \
-        } \
-    } while (0)
-
-#define SANITY_CHECK_EXIT(_cond, _err) \
-    do { \
-        if (!(_cond)) { \
-            REPORT_ERROR(CRITICAL, (_err), NO_MSG); \
-            XX_Exit(1); \
-        } \
-    } while (0)
-
-#endif /* DISABLE_SANITY_CHECKS */
-
-/** @} */ /* end of Debug/error Utils group */
-
-/** @} */ /* end of General Utils group */
-
-#endif /* __ERROR_EXT_H */
-
-
--- fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/dpaa_ext.h.orig	2022-05-26 11:28:30.970977909 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/dpaa_ext.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,204 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          dpaa_ext.h
-
- @Description   DPAA Application Programming Interface.
-*//***************************************************************************/
-#ifndef __DPAA_EXT_H
-#define __DPAA_EXT_H
-
-#include "std_ext.h"
-#include "error_ext.h"
-
-
-/**************************************************************************//**
- @Group         DPAA_grp Data Path Acceleration Architecture API
-
- @Description   DPAA API functions, definitions and enums.
-
- @{
-*//***************************************************************************/
-
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(push,1)
-#endif /* defined(__MWERKS__) && ... */
-
-/**************************************************************************//**
- @Description   Frame descriptor
-*//***************************************************************************/
-typedef _Packed struct t_DpaaFD {
-    volatile uint32_t    id;                /**< FD id */
-    volatile uint32_t    addrl;             /**< Data Address */
-    volatile uint32_t    length;            /**< Frame length */
-    volatile uint32_t    status;            /**< FD status */
-} _PackedType t_DpaaFD;
-
-/**************************************************************************//**
- @Description   enum for defining frame format
-*//***************************************************************************/
-typedef enum e_DpaaFDFormatType {
-    e_DPAA_FD_FORMAT_TYPE_SHORT_SBSF  = 0x0,   /**< Simple frame Single buffer; Offset and
-                                                    small length (9b OFFSET, 20b LENGTH) */
-    e_DPAA_FD_FORMAT_TYPE_LONG_SBSF   = 0x2,   /**< Simple frame, single buffer; big length
-                                                    (29b LENGTH ,No OFFSET) */
-    e_DPAA_FD_FORMAT_TYPE_SHORT_MBSF  = 0x4,   /**< Simple frame, Scatter Gather table; Offset
-                                                    and small length (9b OFFSET, 20b LENGTH) */
-    e_DPAA_FD_FORMAT_TYPE_LONG_MBSF   = 0x6,   /**< Simple frame, Scatter Gather table;
-                                                    big length (29b LENGTH ,No OFFSET) */
-    e_DPAA_FD_FORMAT_TYPE_COMPOUND    = 0x1,   /**< Compound Frame (29b CONGESTION-WEIGHT
-                                                    No LENGTH or OFFSET) */
-    e_DPAA_FD_FORMAT_TYPE_DUMMY
-} e_DpaaFDFormatType;
-
-/**************************************************************************//**
- @Collection   Frame descriptor macros
-*//***************************************************************************/
-#define DPAA_FD_DD_MASK       0xc0000000           /**< FD DD field mask */
-#define DPAA_FD_PID_MASK      0x3f000000           /**< FD PID field mask */
-#define DPAA_FD_ELIODN_MASK   0x0000f000           /**< FD ELIODN field mask */
-#define DPAA_FD_BPID_MASK     0x00ff0000           /**< FD BPID field mask */
-#define DPAA_FD_ADDRH_MASK    0x000000ff           /**< FD ADDRH field mask */
-#define DPAA_FD_ADDRL_MASK    0xffffffff           /**< FD ADDRL field mask */
-#define DPAA_FD_FORMAT_MASK   0xe0000000           /**< FD FORMAT field mask */
-#define DPAA_FD_OFFSET_MASK   0x1ff00000           /**< FD OFFSET field mask */
-#define DPAA_FD_LENGTH_MASK   0x000fffff           /**< FD LENGTH field mask */
-
-#define DPAA_FD_GET_DD(fd)            ((((t_DpaaFD *)fd)->id & DPAA_FD_DD_MASK) >> (31-1))              /**< Macro to get FD DD field */
-#define DPAA_FD_GET_PID(fd)           (((((t_DpaaFD *)fd)->id & DPAA_FD_PID_MASK) >> (31-7)) | \
-                                        ((((t_DpaaFD *)fd)->id & DPAA_FD_ELIODN_MASK) >> (31-19-6)))    /**< Macro to get FD PID field */
-#define DPAA_FD_GET_BPID(fd)          ((((t_DpaaFD *)fd)->id & DPAA_FD_BPID_MASK) >> (31-15))           /**< Macro to get FD BPID field */
-#define DPAA_FD_GET_ADDRH(fd)         (((t_DpaaFD *)fd)->id & DPAA_FD_ADDRH_MASK)                       /**< Macro to get FD ADDRH field */
-#define DPAA_FD_GET_ADDRL(fd)         ((t_DpaaFD *)fd)->addrl                                           /**< Macro to get FD ADDRL field */
-#define DPAA_FD_GET_PHYS_ADDR(fd)     ((physAddress_t)(((uint64_t)DPAA_FD_GET_ADDRH(fd) << 32) | (uint64_t)DPAA_FD_GET_ADDRL(fd))) /**< Macro to get FD ADDR field */
-#define DPAA_FD_GET_FORMAT(fd)        ((((t_DpaaFD *)fd)->length & DPAA_FD_FORMAT_MASK) >> (31-2))      /**< Macro to get FD FORMAT field */
-#define DPAA_FD_GET_OFFSET(fd)        ((((t_DpaaFD *)fd)->length & DPAA_FD_OFFSET_MASK) >> (31-11))     /**< Macro to get FD OFFSET field */
-#define DPAA_FD_GET_LENGTH(fd)        (((t_DpaaFD *)fd)->length & DPAA_FD_LENGTH_MASK)                  /**< Macro to get FD LENGTH field */
-#define DPAA_FD_GET_STATUS(fd)        ((t_DpaaFD *)fd)->status                                          /**< Macro to get FD STATUS field */
-#define DPAA_FD_GET_ADDR(fd)          XX_PhysToVirt(DPAA_FD_GET_PHYS_ADDR(fd))                          /**< Macro to get FD ADDR (virtual) */
-
-#define DPAA_FD_SET_DD(fd,val)        (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~DPAA_FD_DD_MASK) | (((val) << (31-1)) & DPAA_FD_DD_MASK )))      /**< Macro to set FD DD field */
-                                                                                                        /**< Macro to set FD PID field or LIODN offset*/
-#define DPAA_FD_SET_PID(fd,val)       (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~(DPAA_FD_PID_MASK|DPAA_FD_ELIODN_MASK)) | ((((val) << (31-7)) & DPAA_FD_PID_MASK) | ((((val)>>6) << (31-19)) & DPAA_FD_ELIODN_MASK))))
-#define DPAA_FD_SET_BPID(fd,val)      (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~DPAA_FD_BPID_MASK) | (((val)  << (31-15)) & DPAA_FD_BPID_MASK))) /**< Macro to set FD BPID field */
-#define DPAA_FD_SET_ADDRH(fd,val)     (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~DPAA_FD_ADDRH_MASK) | ((val) & DPAA_FD_ADDRH_MASK)))            /**< Macro to set FD ADDRH field */
-#define DPAA_FD_SET_ADDRL(fd,val)     ((t_DpaaFD *)fd)->addrl = (val)                                   /**< Macro to set FD ADDRL field */
-#define DPAA_FD_SET_ADDR(fd,val)                            \
-do {                                                        \
-    uint64_t physAddr = (uint64_t)(XX_VirtToPhys(val));     \
-    DPAA_FD_SET_ADDRH(fd, ((uint32_t)(physAddr >> 32)));    \
-    DPAA_FD_SET_ADDRL(fd, (uint32_t)physAddr);              \
-} while (0)                                                                                             /**< Macro to set FD ADDR field */
-#define DPAA_FD_SET_FORMAT(fd,val)    (((t_DpaaFD *)fd)->length = ((((t_DpaaFD *)fd)->length & ~DPAA_FD_FORMAT_MASK) | (((val)  << (31-2))& DPAA_FD_FORMAT_MASK)))  /**< Macro to set FD FORMAT field */
-#define DPAA_FD_SET_OFFSET(fd,val)    (((t_DpaaFD *)fd)->length = ((((t_DpaaFD *)fd)->length & ~DPAA_FD_OFFSET_MASK) | (((val) << (31-11))& DPAA_FD_OFFSET_MASK) )) /**< Macro to set FD OFFSET field */
-#define DPAA_FD_SET_LENGTH(fd,val)    (((t_DpaaFD *)fd)->length = (((t_DpaaFD *)fd)->length & ~DPAA_FD_LENGTH_MASK) | ((val) & DPAA_FD_LENGTH_MASK))                /**< Macro to set FD LENGTH field */
-#define DPAA_FD_SET_STATUS(fd,val)    ((t_DpaaFD *)fd)->status = (val)                                  /**< Macro to set FD STATUS field */
-/* @} */
-
-/**************************************************************************//**
- @Description   Frame Scatter/Gather Table Entry
-*//***************************************************************************/
-typedef _Packed struct t_DpaaSGTE {
-    volatile uint32_t    addrh;        /**< Buffer Address high */
-    volatile uint32_t    addrl;        /**< Buffer Address low */
-    volatile uint32_t    length;       /**< Buffer length */
-    volatile uint32_t    offset;       /**< SGTE offset */
-} _PackedType t_DpaaSGTE;
-
-#define DPAA_NUM_OF_SG_TABLE_ENTRY 16
-
-/**************************************************************************//**
- @Description   Frame Scatter/Gather Table
-*//***************************************************************************/
-typedef _Packed struct t_DpaaSGT {
-    t_DpaaSGTE    tableEntry[DPAA_NUM_OF_SG_TABLE_ENTRY];
-                                    /**< Structure that holds information about
-                                         a single S/G entry. */
-} _PackedType t_DpaaSGT;
-
-/**************************************************************************//**
- @Description   Compound Frame Table
-*//***************************************************************************/
-typedef _Packed struct t_DpaaCompTbl {
-    t_DpaaSGTE    outputBuffInfo;   /**< Structure that holds information about
-                                         the compound-frame output buffer;
-                                         NOTE: this may point to a S/G table */
-    t_DpaaSGTE    inputBuffInfo;    /**< Structure that holds information about
-                                         the compound-frame input buffer;
-                                         NOTE: this may point to a S/G table */
-} _PackedType t_DpaaCompTbl;
-
-/**************************************************************************//**
- @Collection   Frame Scatter/Gather Table Entry macros
-*//***************************************************************************/
-#define DPAA_SGTE_ADDRH_MASK    0x000000ff           /**< SGTE ADDRH field mask */
-#define DPAA_SGTE_ADDRL_MASK    0xffffffff           /**< SGTE ADDRL field mask */
-#define DPAA_SGTE_E_MASK        0x80000000           /**< SGTE Extension field mask */
-#define DPAA_SGTE_F_MASK        0x40000000           /**< SGTE Final field mask */
-#define DPAA_SGTE_LENGTH_MASK   0x3fffffff           /**< SGTE LENGTH field mask */
-#define DPAA_SGTE_BPID_MASK     0x00ff0000           /**< SGTE BPID field mask */
-#define DPAA_SGTE_OFFSET_MASK   0x00001fff           /**< SGTE OFFSET field mask */
-
-#define DPAA_SGTE_GET_ADDRH(sgte)         (((t_DpaaSGTE *)sgte)->addrh & DPAA_SGTE_ADDRH_MASK)              /**< Macro to get SGTE ADDRH field */
-#define DPAA_SGTE_GET_ADDRL(sgte)         ((t_DpaaSGTE *)sgte)->addrl                                       /**< Macro to get SGTE ADDRL field */
-#define DPAA_SGTE_GET_PHYS_ADDR(sgte)     ((physAddress_t)(((uint64_t)DPAA_SGTE_GET_ADDRH(sgte) << 32) | (uint64_t)DPAA_SGTE_GET_ADDRL(sgte))) /**< Macro to get FD ADDR field */
-#define DPAA_SGTE_GET_EXTENSION(sgte)     ((((t_DpaaSGTE *)sgte)->length & DPAA_SGTE_E_MASK) >> (31-0))     /**< Macro to get SGTE EXTENSION field */
-#define DPAA_SGTE_GET_FINAL(sgte)         ((((t_DpaaSGTE *)sgte)->length & DPAA_SGTE_F_MASK) >> (31-1))     /**< Macro to get SGTE FINAL field */
-#define DPAA_SGTE_GET_LENGTH(sgte)        (((t_DpaaSGTE *)sgte)->length & DPAA_SGTE_LENGTH_MASK)            /**< Macro to get SGTE LENGTH field */
-#define DPAA_SGTE_GET_BPID(sgte)          ((((t_DpaaSGTE *)sgte)->offset & DPAA_SGTE_BPID_MASK) >> (31-15)) /**< Macro to get SGTE BPID field */
-#define DPAA_SGTE_GET_OFFSET(sgte)        (((t_DpaaSGTE *)sgte)->offset & DPAA_SGTE_OFFSET_MASK)            /**< Macro to get SGTE OFFSET field */
-#define DPAA_SGTE_GET_ADDR(sgte)          XX_PhysToVirt(DPAA_SGTE_GET_PHYS_ADDR(sgte))
-
-#define DPAA_SGTE_SET_ADDRH(sgte,val)     (((t_DpaaSGTE *)sgte)->addrh = ((((t_DpaaSGTE *)sgte)->addrh & ~DPAA_SGTE_ADDRH_MASK) | ((val) & DPAA_SGTE_ADDRH_MASK))) /**< Macro to set SGTE ADDRH field */
-#define DPAA_SGTE_SET_ADDRL(sgte,val)     ((t_DpaaSGTE *)sgte)->addrl = (val)                                 /**< Macro to set SGTE ADDRL field */
-#define DPAA_SGTE_SET_ADDR(sgte,val)                            \
-do {                                                            \
-    uint64_t physAddr = (uint64_t)(XX_VirtToPhys(val));         \
-    DPAA_SGTE_SET_ADDRH(sgte, ((uint32_t)(physAddr >> 32)));    \
-    DPAA_SGTE_SET_ADDRL(sgte, (uint32_t)physAddr);              \
-} while (0)                                                                                                 /**< Macro to set SGTE ADDR field */
-#define DPAA_SGTE_SET_EXTENSION(sgte,val) (((t_DpaaSGTE *)sgte)->length = ((((t_DpaaSGTE *)sgte)->length & ~DPAA_SGTE_E_MASK) | (((val)  << (31-0))& DPAA_SGTE_E_MASK)))            /**< Macro to set SGTE EXTENSION field */
-#define DPAA_SGTE_SET_FINAL(sgte,val)     (((t_DpaaSGTE *)sgte)->length = ((((t_DpaaSGTE *)sgte)->length & ~DPAA_SGTE_F_MASK) | (((val)  << (31-1))& DPAA_SGTE_F_MASK)))            /**< Macro to set SGTE FINAL field */
-#define DPAA_SGTE_SET_LENGTH(sgte,val)    (((t_DpaaSGTE *)sgte)->length = (((t_DpaaSGTE *)sgte)->length & ~DPAA_SGTE_LENGTH_MASK) | ((val) & DPAA_SGTE_LENGTH_MASK))                /**< Macro to set SGTE LENGTH field */
-#define DPAA_SGTE_SET_BPID(sgte,val)      (((t_DpaaSGTE *)sgte)->offset = ((((t_DpaaSGTE *)sgte)->offset & ~DPAA_SGTE_BPID_MASK) | (((val)  << (31-15))& DPAA_SGTE_BPID_MASK)))     /**< Macro to set SGTE BPID field */
-#define DPAA_SGTE_SET_OFFSET(sgte,val)    (((t_DpaaSGTE *)sgte)->offset = ((((t_DpaaSGTE *)sgte)->offset & ~DPAA_SGTE_OFFSET_MASK) | (((val) << (31-31))& DPAA_SGTE_OFFSET_MASK) )) /**< Macro to set SGTE OFFSET field */
-/* @} */
-
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(pop)
-#endif /* defined(__MWERKS__) && ... */
-
-/** @} */ /* end of DPAA_grp group */
-
-
-#endif /* __DPAA_EXT_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/fm_pcd_ext.h.orig	2022-05-26 11:28:30.978977583 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/fm_pcd_ext.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,3934 +0,0 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-/**************************************************************************//**
- @File          fm_pcd_ext.h
-
- @Description   FM PCD API definitions
-*//***************************************************************************/
-#ifndef __FM_PCD_EXT
-#define __FM_PCD_EXT
-
-#include "std_ext.h"
-#include "net_ext.h"
-#include "fm_ext.h"
-#include "fsl_fman_kg.h"
-
-
-/**************************************************************************//**
- @Group         FM_grp Frame Manager API
-
- @Description   Frame Manager Application Programming Interface
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Group         FM_PCD_grp FM PCD
-
- @Description   Frame Manager PCD (Parse-Classify-Distribute) API.
-
-                The FM PCD module is responsible for the initialization of all
-                global classifying FM modules. This includes the parser general and
-                common registers, the key generator global and common registers,
-                and the policer global and common registers.
-                In addition, the FM PCD SW module will initialize all required
-                key generator schemes, coarse classification flows, and policer
-                profiles. When FM module is configured to work with one of these
-                entities, it will register to it using the FM PORT API. The PCD
-                module will manage the PCD resources - i.e. resource management of
-                KeyGen schemes, etc.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Collection    General PCD defines
-*//***************************************************************************/
-#define FM_PCD_MAX_NUM_OF_PRIVATE_HDRS              2                   /**< Number of units/headers saved for user */
-
-#define FM_PCD_PRS_NUM_OF_HDRS                      16                  /**< Number of headers supported by HW parser */
-#define FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS         (32 - FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
-                                                                        /**< Number of distinction units is limited by
-                                                                             register size (32 bits) minus reserved bits
-                                                                             for private headers. */
-#define FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS      4                   /**< Maximum number of interchangeable headers
-                                                                             in a distinction unit */
-#define FM_PCD_KG_NUM_OF_GENERIC_REGS               FM_KG_NUM_OF_GENERIC_REGS /**< Total number of generic KeyGen registers */
-#define FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration;
-                                                                             For HW implementation reasons, in most
-                                                                             cases less than this will be allowed; The
-                                                                             driver will return an initialization error
-                                                                             if resource is unavailable. */
-#define FM_PCD_KG_NUM_OF_EXTRACT_MASKS              4                   /**< Total number of masks allowed on KeyGen extractions. */
-#define FM_PCD_KG_NUM_OF_DEFAULT_GROUPS             16                  /**< Number of default value logical groups */
-
-#define FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Maximum number of SW parser labels */
-#define FM_PCD_SW_PRS_SIZE                          0x00000800          /**< Total size of SW parser area */
-#define FM_PCD_PRS_SW_OFFSET                        0x00000040          /**< Size of illegal addresses at the beginning
-                                                                             of the SW parser area */
-
-#define FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE        128                 /**< Maximum size of insertion template for
-                                                                             insert manipulation */
-
-#if (DPAA_VERSION >= 11)
-#define FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES        64                  /**< Maximum possible entries for frame replicator group */
-#endif /* (DPAA_VERSION >= 11) */
-/* @} */
-
-
-/**************************************************************************//**
- @Group         FM_PCD_init_grp FM PCD Initialization Unit
-
- @Description   Frame Manager PCD Initialization Unit API
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   PCD counters
-*//***************************************************************************/
-typedef enum e_FmPcdCounters {
-    e_FM_PCD_KG_COUNTERS_TOTAL,                                 /**< KeyGen counter */
-    e_FM_PCD_PLCR_COUNTERS_RED,                                 /**< Policer counter - counts the total number of RED packets that exit the Policer. */
-    e_FM_PCD_PLCR_COUNTERS_YELLOW,                              /**< Policer counter - counts the total number of YELLOW packets that exit the Policer. */
-    e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,                    /**< Policer counter - counts the number of packets that changed color to RED by the Policer;
-                                                                     This is a subset of e_FM_PCD_PLCR_COUNTERS_RED packet count, indicating active color changes. */
-    e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,                 /**< Policer counter - counts the number of packets that changed color to YELLOW by the Policer;
-                                                                     This is a subset of e_FM_PCD_PLCR_COUNTERS_YELLOW packet count, indicating active color changes. */
-    e_FM_PCD_PLCR_COUNTERS_TOTAL,                               /**< Policer counter - counts the total number of packets passed in the Policer. */
-    e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,                     /**< Policer counter - counts the number of packets with length mismatch. */
-    e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,                       /**< Parser counter - counts the number of times the parser block is dispatched. */
-    e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L2 parse result is returned (including errors). */
-    e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L3 parse result is returned (including errors). */
-    e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L4 parse result is returned (including errors). */
-    e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,           /**< Parser counter - counts the number of times SHIM parse result is returned (including errors). */
-    e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L2 parse result is returned with errors. */
-    e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L3 parse result is returned with errors. */
-    e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L4 parse result is returned with errors. */
-    e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter - counts the number of times SHIM parse result is returned with errors. */
-    e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,                      /**< Parser counter - counts the number of cycles spent executing soft parser instruction (including stall cycles). */
-    e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,                /**< Parser counter - counts the number of cycles stalled waiting for parser internal memory reads while executing soft parser instruction. */
-    e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,     /**< Parser counter - counts the number of cycles spent executing hard parser (including stall cycles). */
-    e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,                    /**< MURAM counter - counts the number of cycles while performing FMan Memory read. */
-    e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,              /**< MURAM counter - counts the number of cycles stalled while performing FMan Memory read. */
-    e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,                   /**< MURAM counter - counts the number of cycles while performing FMan Memory write. */
-    e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,             /**< MURAM counter - counts the number of cycles stalled while performing FMan Memory write. */
-    e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES              /**< FPM counter - counts the number of cycles stalled while performing a FPM Command. */
-} e_FmPcdCounters;
-
-/**************************************************************************//**
- @Description   PCD interrupts
-*//***************************************************************************/
-typedef enum e_FmPcdExceptions {
-    e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,                   /**< KeyGen double-bit ECC error is detected on internal memory read access. */
-    e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,             /**< KeyGen scheme configuration error indicating a key size larger than 56 bytes. */
-    e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,                 /**< Policer double-bit ECC error has been detected on PRAM read access. */
-    e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Policer access to a non-initialized profile has been detected. */
-    e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,    /**< Policer RAM self-initialization complete */
-    e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,     /**< Policer atomic action complete */
-    e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                  /**< Parser double-bit ECC error */
-    e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC                   /**< Parser single-bit ECC error */
-} e_FmPcdExceptions;
-
-
-/**************************************************************************//**
- @Description   Exceptions user callback routine, will be called upon an
-                exception passing the exception identification.
-
- @Param[in]     h_App      - User's application descriptor.
- @Param[in]     exception  - The exception.
-  *//***************************************************************************/
-typedef void (t_FmPcdExceptionCallback) (t_Handle h_App, e_FmPcdExceptions exception);
-
-/**************************************************************************//**
- @Description   Exceptions user callback routine, will be called upon an exception
-                passing the exception identification.
-
- @Param[in]     h_App           - User's application descriptor.
- @Param[in]     exception       - The exception.
- @Param[in]     index           - id of the relevant source (may be scheme or profile id).
- *//***************************************************************************/
-typedef void (t_FmPcdIdExceptionCallback) ( t_Handle           h_App,
-                                            e_FmPcdExceptions  exception,
-                                            uint16_t           index);
-
-/**************************************************************************//**
- @Description   A callback for enqueuing frame onto a QM queue.
-
- @Param[in]     h_QmArg         - Application's handle passed to QM module on enqueue.
- @Param[in]     p_Fd            - Frame descriptor for the frame.
-
- @Return        E_OK on success; Error code otherwise.
- *//***************************************************************************/
-typedef t_Error (t_FmPcdQmEnqueueCallback) (t_Handle h_QmArg, void *p_Fd);
-
-/**************************************************************************//**
- @Description   Host-Command parameters structure.
-
-                When using Host command for PCD functionalities, a dedicated port
-                must be used. If this routine is called for a PCD in a single partition
-                environment, or it is the Master partition in a Multi-partition
-                environment, The port will be initialized by the PCD driver
-                initialization routine.
- *//***************************************************************************/
-typedef struct t_FmPcdHcParams {
-    uintptr_t                   portBaseAddr;       /**< Virtual Address of Host-Command Port memory mapped registers.*/
-    uint8_t                     portId;             /**< Port Id (0-6 relative to Host-Command/Offline-Parsing ports);
-                                                         NOTE: When configuring Host Command port for
-                                                         FMANv3 devices (DPAA_VERSION 11 and higher),
-                                                         portId=0 MUST be used. */
-    uint16_t                    liodnBase;          /**< LIODN base for this port, to be used together with LIODN offset
-                                                         (irrelevant for P4080 revision 1.0) */
-    uint32_t                    errFqid;            /**< Host-Command Port error queue Id. */
-    uint32_t                    confFqid;           /**< Host-Command Port confirmation queue Id. */
-    uint32_t                    qmChannel;          /**< QM channel dedicated to this Host-Command port;
-                                                         will be used by the FM for dequeue. */
-    t_FmPcdQmEnqueueCallback    *f_QmEnqueue;       /**< Callback routine for enqueuing a frame to the QM */
-    t_Handle                    h_QmArg;            /**< Application's handle passed to QM module on enqueue */
-} t_FmPcdHcParams;
-
-/**************************************************************************//**
- @Description   The main structure for PCD initialization
- *//***************************************************************************/
-typedef struct t_FmPcdParams {
-    bool                        prsSupport;             /**< TRUE if Parser will be used for any of the FM ports. */
-    bool                        ccSupport;              /**< TRUE if Coarse Classification will be used for any
-                                                             of the FM ports. */
-    bool                        kgSupport;              /**< TRUE if KeyGen will be used for any of the FM ports. */
-    bool                        plcrSupport;            /**< TRUE if Policer will be used for any of the FM ports. */
-    t_Handle                    h_Fm;                   /**< A handle to the FM module. */
-    uint8_t                     numOfSchemes;           /**< Number of schemes dedicated to this partition.
-                                                             this parameter is relevant if 'kgSupport'=TRUE. */
-    bool                        useHostCommand;         /**< Optional for single partition, Mandatory for Multi partition */
-    t_FmPcdHcParams             hc;                     /**< Host Command parameters, relevant only if 'useHostCommand'=TRUE;
-                                                             Relevant when FM not runs in "guest-mode". */
-
-    t_FmPcdExceptionCallback    *f_Exception;           /**< Callback routine for general PCD exceptions;
-                                                             Relevant when FM not runs in "guest-mode". */
-    t_FmPcdIdExceptionCallback  *f_ExceptionId;         /**< Callback routine for specific KeyGen scheme or
-                                                             Policer profile exceptions;
-                                                             Relevant when FM not runs in "guest-mode". */
-    t_Handle                    h_App;                  /**< A handle to an application layer object; This handle will
-                                                             be passed by the driver upon calling the above callbacks;
-                                                             Relevant when FM not runs in "guest-mode". */
-    uint8_t                     partPlcrProfilesBase;   /**< The first policer-profile-id dedicated to this partition.
-                                                             this parameter is relevant if 'plcrSupport'=TRUE.
-                                                             NOTE: this parameter relevant only when working with multiple partitions. */
-    uint16_t                    partNumOfPlcrProfiles;  /**< Number of policer-profiles dedicated to this partition.
-                                                             this parameter is relevant if 'plcrSupport'=TRUE.
-                                                             NOTE: this parameter relevant only when working with multiple partitions. */
-} t_FmPcdParams;
-
-
-/**************************************************************************//**
- @Function      FM_PCD_Config
-
- @Description   Basic configuration of the PCD module.
-                Creates descriptor for the FM PCD module.
-
- @Param[in]     p_FmPcdParams    A structure of parameters for the initialization of PCD.
-
- @Return        A handle to the initialized module.
-*//***************************************************************************/
-t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams);
-
-/**************************************************************************//**
- @Function      FM_PCD_Init
-
- @Description   Initialization of the PCD module.
-
- @Param[in]     h_FmPcd - FM PCD module descriptor.
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error FM_PCD_Init(t_Handle h_FmPcd);
-
-/**************************************************************************//**
- @Function      FM_PCD_Free
-
- @Description   Frees all resources that were assigned to FM module.
-
-                Calling this routine invalidates the descriptor.
-
- @Param[in]     h_FmPcd - FM PCD module descriptor.
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error FM_PCD_Free(t_Handle h_FmPcd);
-
-/**************************************************************************//**
- @Group         FM_PCD_advanced_cfg_grp    FM PCD Advanced Configuration Unit
-
- @Description   Frame Manager PCD Advanced Configuration API.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Function      FM_PCD_ConfigException
-
- @Description   Calling this routine changes the internal driver data base
-                from its default selection of exceptions enabling.
-                [DEFAULT_numOfSharedPlcrProfiles].
-
- @Param[in]     h_FmPcd         FM PCD module descriptor.
- @Param[in]     exception       The exception to be selected.
- @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
-*//***************************************************************************/
-t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
-
-/**************************************************************************//**
- @Function      FM_PCD_ConfigHcFramesDataMemory
-
- @Description   Configures memory-partition-id for FMan-Controller Host-Command
-                frames. Calling this routine changes the internal driver data
-                base from its default configuration [0].
-
- @Param[in]     h_FmPcd         FM PCD module descriptor.
- @Param[in]     memId           Memory partition ID.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      This routine may be called only if 'useHostCommand' was TRUE
-                when FM_PCD_Config() routine was called.
-*//***************************************************************************/
-t_Error FM_PCD_ConfigHcFramesDataMemory(t_Handle h_FmPcd, uint8_t memId);
-
-/**************************************************************************//**
- @Function      FM_PCD_ConfigPlcrNumOfSharedProfiles
-
- @Description   Calling this routine changes the internal driver data base
-                from its default selection of exceptions enablement.
-                [DEFAULT_numOfSharedPlcrProfiles].
-
- @Param[in]     h_FmPcd                     FM PCD module descriptor.
- @Param[in]     numOfSharedPlcrProfiles     Number of profiles to
-                                            be shared between ports on this partition
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSharedPlcrProfiles);
-
-/**************************************************************************//**
- @Function      FM_PCD_ConfigPlcrAutoRefreshMode
-
- @Description   Calling this routine changes the internal driver data base
-                from its default selection of exceptions enablement.
-                By default auto-refresh is [DEFAULT_plcrAutoRefresh].
-
- @Param[in]     h_FmPcd         FM PCD module descriptor.
- @Param[in]     enable          TRUE to enable, FALSE to disable
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
-*//***************************************************************************/
-t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable);
-
-/**************************************************************************//**
- @Function      FM_PCD_ConfigPrsMaxCycleLimit
-
- @Description   Calling this routine changes the internal data structure for
-                the maximum parsing time from its default value
-                [DEFAULT_MAX_PRS_CYC_LIM].
-
- @Param[in]     h_FmPcd         FM PCD module descriptor.
- @Param[in]     value           0 to disable the mechanism, or new
-                                maximum parsing time.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
-*//***************************************************************************/
-t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value);
-
-/** @} */ /* end of FM_PCD_advanced_cfg_grp group */
-/** @} */ /* end of FM_PCD_init_grp group */
-
-
-/**************************************************************************//**
- @Group         FM_PCD_Runtime_grp FM PCD Runtime Unit
-
- @Description   Frame Manager PCD Runtime Unit API
-
-                The runtime control allows creation of PCD infrastructure modules
-                such as Network Environment Characteristics, Classification Plan
-                Groups and Coarse Classification Trees.
-                It also allows on-the-fly initialization, modification and removal
-                of PCD modules such as KeyGen schemes, coarse classification nodes
-                and Policer profiles.
-
-                In order to explain the programming model of the PCD driver interface
-                a few terms should be explained, and will be used below.
-                  - Distinction Header - One of the 16 protocols supported by the FM parser,
-                    or one of the SHIM headers (1 or 2). May be a header with a special
-                    option (see below).
-                  - Interchangeable Headers Group - This is a group of Headers recognized
-                    by either one of them. For example, if in a specific context the user
-                    chooses to treat IPv4 and IPV6 in the same way, they may create an
-                    interchangeable Headers Unit consisting of these 2 headers.
-                  - A Distinction Unit - a Distinction Header or an Interchangeable Headers
-                    Group.
-                  - Header with special option - applies to Ethernet, MPLS, VLAN, IPv4 and
-                    IPv6, includes multicast, broadcast and other protocol specific options.
-                    In terms of hardware it relates to the options available in the classification
-                    plan.
-                  - Network Environment Characteristics - a set of Distinction Units that define
-                    the total recognizable header selection for a certain environment. This is
-                    NOT the list of all headers that will ever appear in a flow, but rather
-                    everything that needs distinction in a flow, where distinction is made by KeyGen
-                    schemes and coarse classification action descriptors.
-
-                The PCD runtime modules initialization is done in stages. The first stage after
-                initializing the PCD module itself is to establish a Network Flows Environment
-                Definition. The application may choose to establish one or more such environments.
-                Later, when needed, the application will have to state, for some of its modules,
-                to which single environment it belongs.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   A structure for SW parser labels
- *//***************************************************************************/
-typedef struct t_FmPcdPrsLabelParams {
-    uint32_t                instructionOffset;              /**< SW parser label instruction offset (2 bytes
-                                                                 resolution), relative to Parser RAM. */
-    e_NetHeaderType         hdr;                            /**< The existence of this header will invoke
-                                                                 the SW parser code. */
-    uint8_t                 indexPerHdr;                    /**< Normally 0, if more than one SW parser
-                                                                 attachments for the same header, use this
-                                                                 index to distinguish between them. */
-} t_FmPcdPrsLabelParams;
-
-/**************************************************************************//**
- @Description   A structure for SW parser
- *//***************************************************************************/
-typedef struct t_FmPcdPrsSwParams {
-    bool                    override;                   /**< FALSE to invoke a check that nothing else
-                                                             was loaded to this address, including
-                                                             internal patches.
-                                                             TRUE to override any existing code.*/
-    uint32_t                size;                       /**< SW parser code size */
-    uint16_t                base;                       /**< SW parser base (in instruction counts!
-                                                             must be larger than 0x20)*/
-    uint8_t                 *p_Code;                    /**< SW parser code */
-    uint32_t                swPrsDataParams[FM_PCD_PRS_NUM_OF_HDRS];
-                                                        /**< SW parser data (parameters) */
-    uint8_t                 numOfLabels;                /**< Number of labels for SW parser. */
-    t_FmPcdPrsLabelParams   labelsTable[FM_PCD_PRS_NUM_OF_LABELS];
-                                                        /**< SW parser labels table, containing
-                                                             numOfLabels entries */
-} t_FmPcdPrsSwParams;
-
-t_Handle FM_PCD_Open( t_FmPcdParams *p_FmPcdParams );
-void FM_PCD_Close(t_Handle h_FmPcd);
-
-
-/**************************************************************************//**
- @Function      FM_PCD_Enable
-
- @Description   This routine should be called after PCD is initialized for enabling all
-                PCD engines according to their existing configuration.
-
- @Param[in]     h_FmPcd         FM PCD module descriptor.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init() and when PCD is disabled.
-*//***************************************************************************/
-t_Error FM_PCD_Enable(t_Handle h_FmPcd);
-
-/**************************************************************************//**
- @Function      FM_PCD_Disable
-
- @Description   This routine may be called when PCD is enabled in order to
-                disable all PCD engines. It may be called
-                only when none of the ports in the system are using the PCD.
-
- @Param[in]     h_FmPcd         FM PCD module descriptor.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init() and when PCD is enabled.
-*//***************************************************************************/
-t_Error FM_PCD_Disable(t_Handle h_FmPcd);
-
-/**************************************************************************//**
- @Function      FM_PCD_GetCounter
-
- @Description   Reads one of the FM PCD counters.
-
- @Param[in]     h_FmPcd     FM PCD module descriptor.
- @Param[in]     counter     The requested counter.
-
- @Return        Counter's current value.
-
- @Cautions      Allowed only following FM_PCD_Init().
-                Note that it is user's responsibility to call this routine only
-                for enabled counters, and there will be no indication if a
-                disabled counter is accessed.
-*//***************************************************************************/
-uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter);
-
-/**************************************************************************//**
-@Function       FM_PCD_PrsLoadSw
-
-@Description    This routine may be called in order to load software parsing code.
-
-
-@Param[in]      h_FmPcd        FM PCD module descriptor.
-@Param[in]      p_SwPrs        A pointer to a structure of software
-                               parser parameters, including the software
-                               parser image.
-
-@Return         E_OK on success; Error code otherwise.
-
-@Cautions       Allowed only following FM_PCD_Init() and when PCD is disabled.
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
-*//***************************************************************************/
-t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs);
-
-/**************************************************************************//**
-@Function      FM_PCD_SetAdvancedOffloadSupport
-
-@Description   This routine must be called in order to support the following features:
-               IP-fragmentation, IP-reassembly, IPsec, Header-manipulation, frame-replicator.
-
-@Param[in]     h_FmPcd         FM PCD module descriptor.
-
-@Return        E_OK on success; Error code otherwise.
-
-@Cautions      Allowed only following FM_PCD_Init() and when PCD is disabled.
-               This routine should NOT be called from guest-partition
-               (i.e. guestId != NCSW_MASTER_ID)
-*//***************************************************************************/
-t_Error FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPcd);
-
-/**************************************************************************//**
- @Function      FM_PCD_KgSetDfltValue
-
- @Description   Calling this routine sets a global default value to be used
-                by the KeyGen when parser does not recognize a required
-                field/header.
-                By default default values are 0.
-
- @Param[in]     h_FmPcd         FM PCD module descriptor.
- @Param[in]     valueId         0,1 - one of 2 global default values.
- @Param[in]     value           The requested default value.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init() and when PCD is disabled.
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
-*//***************************************************************************/
-t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value);
-
-/**************************************************************************//**
- @Function      FM_PCD_KgSetAdditionalDataAfterParsing
-
- @Description   Calling this routine allows the KeyGen to access data past
-                the parser finishing point.
-
- @Param[in]     h_FmPcd         FM PCD module descriptor.
- @Param[in]     payloadOffset   the number of bytes beyond the parser location.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init() and when PCD is disabled.
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
-*//***************************************************************************/
-t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset);
-
-/**************************************************************************//**
- @Function      FM_PCD_SetException
-
- @Description   Calling this routine enables/disables PCD interrupts.
-
- @Param[in]     h_FmPcd         FM PCD module descriptor.
- @Param[in]     exception       The exception to be selected.
- @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
-*//***************************************************************************/
-t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
-
-/**************************************************************************//**
- @Function      FM_PCD_ModifyCounter
-
- @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
-
- @Param[in]     h_FmPcd     FM PCD module descriptor.
- @Param[in]     counter     The requested counter.
- @Param[in]     value       The requested value to be written into the counter.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
-*//***************************************************************************/
-t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value);
-
-/**************************************************************************//**
- @Function      FM_PCD_SetPlcrStatistics
-
- @Description   This routine may be used to enable/disable policer statistics
-                counter. By default the statistics is enabled.
-
- @Param[in]     h_FmPcd         FM PCD module descriptor
- @Param[in]     enable          TRUE to enable, FALSE to disable.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
-*//***************************************************************************/
-t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable);
-
-/**************************************************************************//**
- @Function      FM_PCD_SetPrsStatistics
-
- @Description   Defines whether to gather parser statistics including all ports.
-
- @Param[in]     h_FmPcd     FM PCD module descriptor.
- @Param[in]     enable      TRUE to enable, FALSE to disable.
-
- @Return        None
-
- @Cautions      Allowed only following FM_PCD_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
-*//***************************************************************************/
-void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable);
-
-/**************************************************************************//**
- @Function      FM_PCD_HcTxConf
-
- @Description   This routine should be called to confirm frames that were
-                 received on the HC confirmation queue.
-
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
- @Param[in]     p_Fd            Frame descriptor of the received frame.
-
- @Cautions      Allowed only following FM_PCD_Init(). Allowed only if 'useHostCommand'
-                option was selected in the initialization.
-*//***************************************************************************/
-void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_DpaaFD *p_Fd);
-
-/**************************************************************************//*
- @Function      FM_PCD_ForceIntr
-
- @Description   Causes an interrupt event on the requested source.
-
- @Param[in]     h_FmPcd     FM PCD module descriptor.
- @Param[in]     exception       An exception to be forced.
-
- @Return        E_OK on success; Error code if the exception is not enabled,
-                or is not able to create interrupt.
-
- @Cautions      Allowed only following FM_PCD_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
-*//***************************************************************************/
-t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception);
-
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-/**************************************************************************//**
- @Function      FM_PCD_DumpRegs
-
- @Description   Dumps all PCD registers
-
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-                NOTE: this routine may be called only for FM in master mode
-                (i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
-                are mapped.
-*//***************************************************************************/
-t_Error FM_PCD_DumpRegs(t_Handle h_FmPcd);
-
-/**************************************************************************//**
- @Function      FM_PCD_KgDumpRegs
-
- @Description   Dumps all PCD KG registers
-
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-                NOTE: this routine may be called only for FM in master mode
-                (i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
-                are mapped.
-*//***************************************************************************/
-t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd);
-
-/**************************************************************************//**
- @Function      FM_PCD_PlcrDumpRegs
-
- @Description   Dumps all PCD Policer registers
-
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-                NOTE: this routine may be called only for FM in master mode
-                (i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
-                are mapped.
-*//***************************************************************************/
-t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd);
-
-/**************************************************************************//**
- @Function      FM_PCD_PlcrProfileDumpRegs
-
- @Description   Dumps all PCD Policer profile registers
-
- @Param[in]     h_Profile       A handle to a Policer profile.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-                NOTE: this routine may be called only for FM in master mode
-                (i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
-                are mapped.
-*//***************************************************************************/
-t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile);
-
-/**************************************************************************//**
- @Function      FM_PCD_PrsDumpRegs
-
- @Description   Dumps all PCD Parser registers
-
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-                NOTE: this routine may be called only for FM in master mode
-                (i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
-                are mapped.
-*//***************************************************************************/
-t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd);
-
-/**************************************************************************//**
- @Function      FM_PCD_HcDumpRegs
-
- @Description   Dumps HC Port registers
-
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-                NOTE: this routine may be called only for FM in master mode
-                (i.e. 'guestId'=NCSW_MASTER_ID).
-*//***************************************************************************/
-t_Error     FM_PCD_HcDumpRegs(t_Handle h_FmPcd);
-#endif /* (defined(DEBUG_ERRORS) && ... */
-
-
-
-/**************************************************************************//**
- KeyGen         FM_PCD_Runtime_build_grp FM PCD Runtime Building Unit
-
- @Description   Frame Manager PCD Runtime Building API
-
-                This group contains routines for setting, deleting and modifying
-                PCD resources, for defining the total PCD tree.
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Collection    Definitions of coarse classification
-                parameters as required by KeyGen (when coarse classification
-                is the next engine after this scheme).
-*//***************************************************************************/
-#define FM_PCD_MAX_NUM_OF_CC_TREES              8
-#define FM_PCD_MAX_NUM_OF_CC_GROUPS             16
-#define FM_PCD_MAX_NUM_OF_CC_UNITS              4
-#define FM_PCD_MAX_NUM_OF_KEYS                  256
-#define FM_PCD_MAX_NUM_OF_FLOWS                 (4*KILOBYTE)
-#define FM_PCD_MAX_SIZE_OF_KEY                  56
-#define FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP     16
-#define FM_PCD_LAST_KEY_INDEX                   0xffff
-
-#define FM_PCD_MAX_NUM_OF_CC_NODES              255 /* Obsolete, not used - will be removed in the future */
-/* @} */
-
-/**************************************************************************//**
- @Collection    A set of definitions to allow protocol
-                special option description.
-*//***************************************************************************/
-typedef uint32_t        protocolOpt_t;          /**< A general type to define a protocol option. */
-
-typedef protocolOpt_t   ethProtocolOpt_t;       /**< Ethernet protocol options. */
-#define ETH_BROADCAST               0x80000000  /**< Ethernet Broadcast. */
-#define ETH_MULTICAST               0x40000000  /**< Ethernet Multicast. */
-
-typedef protocolOpt_t   vlanProtocolOpt_t;      /**< VLAN protocol options. */
-#define VLAN_STACKED                0x20000000  /**< Stacked VLAN. */
-
-typedef protocolOpt_t   mplsProtocolOpt_t;      /**< MPLS protocol options. */
-#define MPLS_STACKED                0x10000000  /**< Stacked MPLS. */
-
-typedef protocolOpt_t   ipv4ProtocolOpt_t;      /**< IPv4 protocol options. */
-#define IPV4_BROADCAST_1            0x08000000  /**< IPv4 Broadcast. */
-#define IPV4_MULTICAST_1            0x04000000  /**< IPv4 Multicast. */
-#define IPV4_UNICAST_2              0x02000000  /**< Tunneled IPv4 - Unicast. */
-#define IPV4_MULTICAST_BROADCAST_2  0x01000000  /**< Tunneled IPv4 - Broadcast/Multicast. */
-
-#define IPV4_FRAG_1                 0x00000008  /**< IPV4 reassembly option.
-                                                     IPV4 Reassembly manipulation requires network
-                                                     environment with IPV4 header and IPV4_FRAG_1 option  */
-
-typedef protocolOpt_t   ipv6ProtocolOpt_t;      /**< IPv6 protocol options. */
-#define IPV6_MULTICAST_1            0x00800000  /**< IPv6 Multicast. */
-#define IPV6_UNICAST_2              0x00400000  /**< Tunneled IPv6 - Unicast. */
-#define IPV6_MULTICAST_2            0x00200000  /**< Tunneled IPv6 - Multicast. */
-
-#define IPV6_FRAG_1                 0x00000004  /**< IPV6 reassembly option.
-                                                     IPV6 Reassembly manipulation requires network
-                                                     environment with IPV6 header and IPV6_FRAG_1 option;
-                                                     in case where fragment found, the fragment-extension offset
-                                                     may be found at 'shim2' (in parser-result). */
-#if (DPAA_VERSION >= 11)
-typedef protocolOpt_t   capwapProtocolOpt_t;      /**< CAPWAP protocol options. */
-#define CAPWAP_FRAG_1               0x00000008  /**< CAPWAP reassembly option.
-                                                     CAPWAP Reassembly manipulation requires network
-                                                     environment with CAPWAP header and CAPWAP_FRAG_1 option;
-                                                     in case where fragment found, the fragment-extension offset
-                                                     may be found at 'shim2' (in parser-result). */
-#endif /* (DPAA_VERSION >= 11) */
-
-
-/* @} */
-
-#define FM_PCD_MANIP_MAX_HDR_SIZE               256
-#define FM_PCD_MANIP_DSCP_TO_VLAN_TRANS         64
-
-/**************************************************************************//**
- @Collection    A set of definitions to support Header Manipulation selection.
-*//***************************************************************************/
-typedef uint32_t                hdrManipFlags_t;            /**< A general type to define a HMan update command flags. */
-
-typedef hdrManipFlags_t         ipv4HdrManipUpdateFlags_t;  /**< IPv4 protocol HMan update command flags. */
-
-#define HDR_MANIP_IPV4_TOS      0x80000000                  /**< update TOS with the given value ('tos' field
-                                                                 of t_FmPcdManipHdrFieldUpdateIpv4) */
-#define HDR_MANIP_IPV4_ID       0x40000000                  /**< update IP ID with the given value ('id' field
-                                                                 of t_FmPcdManipHdrFieldUpdateIpv4) */
-#define HDR_MANIP_IPV4_TTL      0x20000000                  /**< Decrement TTL by 1 */
-#define HDR_MANIP_IPV4_SRC      0x10000000                  /**< update IP source address with the given value
-                                                                 ('src' field of t_FmPcdManipHdrFieldUpdateIpv4) */
-#define HDR_MANIP_IPV4_DST      0x08000000                  /**< update IP destination address with the given value
-                                                                 ('dst' field of t_FmPcdManipHdrFieldUpdateIpv4) */
-
-typedef hdrManipFlags_t         ipv6HdrManipUpdateFlags_t;  /**< IPv6 protocol HMan update command flags. */
-
-#define HDR_MANIP_IPV6_TC       0x80000000                  /**< update Traffic Class address with the given value
-                                                                 ('trafficClass' field of t_FmPcdManipHdrFieldUpdateIpv6) */
-#define HDR_MANIP_IPV6_HL       0x40000000                  /**< Decrement Hop Limit by 1 */
-#define HDR_MANIP_IPV6_SRC      0x20000000                  /**< update IP source address with the given value
-                                                                 ('src' field of t_FmPcdManipHdrFieldUpdateIpv6) */
-#define HDR_MANIP_IPV6_DST      0x10000000                  /**< update IP destination address with the given value
-                                                                 ('dst' field of t_FmPcdManipHdrFieldUpdateIpv6) */
-
-typedef hdrManipFlags_t         tcpUdpHdrManipUpdateFlags_t;/**< TCP/UDP protocol HMan update command flags. */
-
-#define HDR_MANIP_TCP_UDP_SRC       0x80000000              /**< update TCP/UDP source address with the given value
-                                                                 ('src' field of t_FmPcdManipHdrFieldUpdateTcpUdp) */
-#define HDR_MANIP_TCP_UDP_DST       0x40000000              /**< update TCP/UDP destination address with the given value
-                                                                 ('dst' field of t_FmPcdManipHdrFieldUpdateTcpUdp) */
-#define HDR_MANIP_TCP_UDP_CHECKSUM  0x20000000             /**< update TCP/UDP checksum */
-
-/* @} */
-
-/**************************************************************************//**
- @Description   A type used for returning the order of the key extraction.
-                each value in this array represents the index of the extraction
-                command as defined by the user in the initialization extraction array.
-                The valid size of this array is the user define number of extractions
-                required (also marked by the second '0' in this array).
-*//***************************************************************************/
-typedef    uint8_t    t_FmPcdKgKeyOrder [FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
-
-/**************************************************************************//**
- @Description   All PCD engines
-*//***************************************************************************/
-typedef enum e_FmPcdEngine {
-    e_FM_PCD_INVALID = 0,   /**< Invalid PCD engine */
-    e_FM_PCD_DONE,          /**< No PCD Engine indicated */
-    e_FM_PCD_KG,            /**< KeyGen */
-    e_FM_PCD_CC,            /**< Coarse classifier */
-    e_FM_PCD_PLCR,          /**< Policer */
-    e_FM_PCD_PRS,           /**< Parser */
-#if (DPAA_VERSION >= 11)
-    e_FM_PCD_FR,            /**< Frame-Replicator */
-#endif /* (DPAA_VERSION >= 11) */
-    e_FM_PCD_HASH           /**< Hash table */
-} e_FmPcdEngine;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting extraction by header types
-*//***************************************************************************/
-typedef enum e_FmPcdExtractByHdrType {
-    e_FM_PCD_EXTRACT_FROM_HDR,      /**< Extract bytes from header */
-    e_FM_PCD_EXTRACT_FROM_FIELD,    /**< Extract bytes from header field */
-    e_FM_PCD_EXTRACT_FULL_FIELD     /**< Extract a full field */
-} e_FmPcdExtractByHdrType;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting extraction source
-                (when it is not the header)
-*//***************************************************************************/
-typedef enum e_FmPcdExtractFrom {
-    e_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< KG & CC: Extract from beginning of frame */
-    e_FM_PCD_EXTRACT_FROM_DFLT_VALUE,           /**< KG only: Extract from a default value */
-    e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE,    /**< KG & CC: Extract from the point where parsing had finished */
-    e_FM_PCD_EXTRACT_FROM_KEY,                  /**< CC only: Field where saved KEY */
-    e_FM_PCD_EXTRACT_FROM_HASH,                 /**< CC only: Field where saved HASH */
-    e_FM_PCD_EXTRACT_FROM_PARSE_RESULT,         /**< KG only: Extract from the parser result */
-    e_FM_PCD_EXTRACT_FROM_ENQ_FQID,             /**< KG & CC: Extract from enqueue FQID */
-    e_FM_PCD_EXTRACT_FROM_FLOW_ID               /**< CC only: Field where saved Dequeue FQID */
-} e_FmPcdExtractFrom;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting extraction type
-*//***************************************************************************/
-typedef enum e_FmPcdExtractType {
-    e_FM_PCD_EXTRACT_BY_HDR,                /**< Extract according to header */
-    e_FM_PCD_EXTRACT_NON_HDR,               /**< Extract from data that is not the header */
-    e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO   /**< Extract private info as specified by user */
-} e_FmPcdExtractType;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting default extraction value
-*//***************************************************************************/
-typedef enum e_FmPcdKgExtractDfltSelect {
-    e_FM_PCD_KG_DFLT_GBL_0,          /**< Default selection is KG register 0 */
-    e_FM_PCD_KG_DFLT_GBL_1,          /**< Default selection is KG register 1 */
-    e_FM_PCD_KG_DFLT_PRIVATE_0,      /**< Default selection is a per scheme register 0 */
-    e_FM_PCD_KG_DFLT_PRIVATE_1,      /**< Default selection is a per scheme register 1 */
-    e_FM_PCD_KG_DFLT_ILLEGAL         /**< Illegal selection */
-} e_FmPcdKgExtractDfltSelect;
-
-/**************************************************************************//**
- @Description   Enumeration type defining all default groups - each group shares
-                a default value, one of four user-initialized values.
-*//***************************************************************************/
-typedef enum e_FmPcdKgKnownFieldsDfltTypes {
-    e_FM_PCD_KG_MAC_ADDR,               /**< MAC Address */
-    e_FM_PCD_KG_TCI,                    /**< TCI field */
-    e_FM_PCD_KG_ENET_TYPE,              /**< ENET Type */
-    e_FM_PCD_KG_PPP_SESSION_ID,         /**< PPP Session id */
-    e_FM_PCD_KG_PPP_PROTOCOL_ID,        /**< PPP Protocol id */
-    e_FM_PCD_KG_MPLS_LABEL,             /**< MPLS label */
-    e_FM_PCD_KG_IP_ADDR,                /**< IP address */
-    e_FM_PCD_KG_PROTOCOL_TYPE,          /**< Protocol type */
-    e_FM_PCD_KG_IP_TOS_TC,              /**< TOS or TC */
-    e_FM_PCD_KG_IPV6_FLOW_LABEL,        /**< IPV6 flow label */
-    e_FM_PCD_KG_IPSEC_SPI,              /**< IPSEC SPI */
-    e_FM_PCD_KG_L4_PORT,                /**< L4 Port */
-    e_FM_PCD_KG_TCP_FLAG,               /**< TCP Flag */
-    e_FM_PCD_KG_GENERIC_FROM_DATA,      /**< grouping implemented by SW,
-                                             any data extraction that is not the full
-                                             field described above  */
-    e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by SW,
-                                             any data extraction without validation */
-    e_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by SW,
-                                             extraction from parser result or
-                                             direct use of default value  */
-} e_FmPcdKgKnownFieldsDfltTypes;
-
-/**************************************************************************//**
- @Description   Enumeration type for defining header index for scenarios with
-                multiple (tunneled) headers
-*//***************************************************************************/
-typedef enum e_FmPcdHdrIndex {
-    e_FM_PCD_HDR_INDEX_NONE = 0,        /**< used when multiple headers not used, also
-                                             to specify regular IP (not tunneled). */
-    e_FM_PCD_HDR_INDEX_1,               /**< may be used for VLAN, MPLS, tunneled IP */
-    e_FM_PCD_HDR_INDEX_2,               /**< may be used for MPLS, tunneled IP */
-    e_FM_PCD_HDR_INDEX_3,               /**< may be used for MPLS */
-    e_FM_PCD_HDR_INDEX_LAST = 0xFF      /**< may be used for VLAN, MPLS */
-} e_FmPcdHdrIndex;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting the policer profile functional type
-*//***************************************************************************/
-typedef enum e_FmPcdProfileTypeSelection {
-    e_FM_PCD_PLCR_PORT_PRIVATE,         /**< Port dedicated profile */
-    e_FM_PCD_PLCR_SHARED                /**< Shared profile (shared within partition) */
-} e_FmPcdProfileTypeSelection;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting the policer profile algorithm
-*//***************************************************************************/
-typedef enum e_FmPcdPlcrAlgorithmSelection {
-    e_FM_PCD_PLCR_PASS_THROUGH,         /**< Policer pass through */
-    e_FM_PCD_PLCR_RFC_2698,             /**< Policer algorithm RFC 2698 */
-    e_FM_PCD_PLCR_RFC_4115              /**< Policer algorithm RFC 4115 */
-} e_FmPcdPlcrAlgorithmSelection;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting a policer profile color mode
-*//***************************************************************************/
-typedef enum e_FmPcdPlcrColorMode {
-    e_FM_PCD_PLCR_COLOR_BLIND,          /**< Color blind */
-    e_FM_PCD_PLCR_COLOR_AWARE           /**< Color aware */
-} e_FmPcdPlcrColorMode;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting a policer profile color
-*//***************************************************************************/
-typedef enum e_FmPcdPlcrColor {
-    e_FM_PCD_PLCR_GREEN,                /**< Green color code */
-    e_FM_PCD_PLCR_YELLOW,               /**< Yellow color code */
-    e_FM_PCD_PLCR_RED,                  /**< Red color code */
-    e_FM_PCD_PLCR_OVERRIDE              /**< Color override code */
-} e_FmPcdPlcrColor;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting the policer profile packet frame length selector
-*//***************************************************************************/
-typedef enum e_FmPcdPlcrFrameLengthSelect {
-  e_FM_PCD_PLCR_L2_FRM_LEN,             /**< L2 frame length */
-  e_FM_PCD_PLCR_L3_FRM_LEN,             /**< L3 frame length */
-  e_FM_PCD_PLCR_L4_FRM_LEN,             /**< L4 frame length */
-  e_FM_PCD_PLCR_FULL_FRM_LEN            /**< Full frame length */
-} e_FmPcdPlcrFrameLengthSelect;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting roll-back frame
-*//***************************************************************************/
-typedef enum e_FmPcdPlcrRollBackFrameSelect {
-  e_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN,    /**< Roll-back L2 frame length */
-  e_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN   /**< Roll-back Full frame length */
-} e_FmPcdPlcrRollBackFrameSelect;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting the policer profile packet or byte mode
-*//***************************************************************************/
-typedef enum e_FmPcdPlcrRateMode {
-    e_FM_PCD_PLCR_BYTE_MODE,            /**< Byte mode */
-    e_FM_PCD_PLCR_PACKET_MODE           /**< Packet mode */
-} e_FmPcdPlcrRateMode;
-
-/**************************************************************************//**
- @Description   Enumeration type for defining action of frame
-*//***************************************************************************/
-typedef enum e_FmPcdDoneAction {
-    e_FM_PCD_ENQ_FRAME = 0,        /**< Enqueue frame */
-    e_FM_PCD_DROP_FRAME            /**< Mark this frame as error frame and continue
-                                        to error flow; 'FM_PORT_FRM_ERR_CLS_DISCARD'
-                                        flag will be set for this frame. */
-} e_FmPcdDoneAction;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting the policer counter
-*//***************************************************************************/
-typedef enum e_FmPcdPlcrProfileCounters {
-    e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER,               /**< Green packets counter */
-    e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER,              /**< Yellow packets counter */
-    e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER,                 /**< Red packets counter */
-    e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER,   /**< Recolored yellow packets counter */
-    e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER       /**< Recolored red packets counter */
-} e_FmPcdPlcrProfileCounters;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting the PCD action after extraction
-*//***************************************************************************/
-typedef enum e_FmPcdAction {
-    e_FM_PCD_ACTION_NONE,                           /**< NONE  */
-    e_FM_PCD_ACTION_EXACT_MATCH,                    /**< Exact match on the selected extraction */
-    e_FM_PCD_ACTION_INDEXED_LOOKUP                  /**< Indexed lookup on the selected extraction */
-} e_FmPcdAction;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of insert manipulation
-*//***************************************************************************/
-typedef enum e_FmPcdManipHdrInsrtType {
-    e_FM_PCD_MANIP_INSRT_GENERIC,                   /**< Insert according to offset & size */
-    e_FM_PCD_MANIP_INSRT_BY_HDR,                    /**< Insert according to protocol */
-#ifdef FM_CAPWAP_SUPPORT
-    e_FM_PCD_MANIP_INSRT_BY_TEMPLATE                /**< Insert template to start of frame */
-#endif /* FM_CAPWAP_SUPPORT */
-} e_FmPcdManipHdrInsrtType;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of remove manipulation
-*//***************************************************************************/
-typedef enum e_FmPcdManipHdrRmvType {
-    e_FM_PCD_MANIP_RMV_GENERIC,                     /**< Remove according to offset & size */
-    e_FM_PCD_MANIP_RMV_BY_HDR                       /**< Remove according to offset & size */
-} e_FmPcdManipHdrRmvType;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting specific L2 fields removal
-*//***************************************************************************/
-typedef enum e_FmPcdManipHdrRmvSpecificL2 {
-    e_FM_PCD_MANIP_HDR_RMV_ETHERNET,                /**< Ethernet/802.3 MAC */
-    e_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS,           /**< stacked QTags */
-    e_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS,       /**< MPLS and Ethernet/802.3 MAC header until
-                                                         the header which follows the MPLS header */
-    e_FM_PCD_MANIP_HDR_RMV_MPLS                     /**< Remove MPLS header (Unlimited MPLS labels) */
-} e_FmPcdManipHdrRmvSpecificL2;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting specific fields updates
-*//***************************************************************************/
-typedef enum e_FmPcdManipHdrFieldUpdateType {
-    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN,               /**< VLAN updates */
-    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4,               /**< IPV4 updates */
-    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6,               /**< IPV6 updates */
-    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP,            /**< TCP_UDP updates */
-} e_FmPcdManipHdrFieldUpdateType;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting VLAN updates
-*//***************************************************************************/
-typedef enum e_FmPcdManipHdrFieldUpdateVlan {
-    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI,      /**< Replace VPri of outer most VLAN tag. */
-    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN    /**< DSCP to VLAN priority bits translation */
-} e_FmPcdManipHdrFieldUpdateVlan;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting specific L2 fields removal
-*//***************************************************************************/
-typedef enum e_FmPcdManipHdrInsrtSpecificL2 {
-    e_FM_PCD_MANIP_HDR_INSRT_MPLS                   /**< Insert MPLS header (Unlimited MPLS labels) */
-} e_FmPcdManipHdrInsrtSpecificL2;
-
-#if (DPAA_VERSION >= 11)
-/**************************************************************************//**
- @Description   Enumeration type for selecting QoS mapping mode
-
-                Note: In all cases except 'e_FM_PCD_MANIP_HDR_QOS_MAPPING_NONE'
-                User should instruct the port to read the parser-result
-*//***************************************************************************/
-typedef enum e_FmPcdManipHdrQosMappingMode {
-    e_FM_PCD_MANIP_HDR_QOS_MAPPING_NONE = 0,   /**< No mapping, QoS field will not be changed */
-    e_FM_PCD_MANIP_HDR_QOS_MAPPING_AS_IS, /**< QoS field will be overwritten by the last byte in the parser-result. */
-} e_FmPcdManipHdrQosMappingMode;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting QoS source
-
-                Note: In all cases except 'e_FM_PCD_MANIP_HDR_QOS_SRC_NONE'
-                User should left room for the parser-result on input/output buffer
-                and instruct the port to read/write the parser-result to the buffer (RPD should be set)
-*//***************************************************************************/
-typedef enum e_FmPcdManipHdrQosSrc {
-    e_FM_PCD_MANIP_HDR_QOS_SRC_NONE = 0,        /**< TODO */
-    e_FM_PCD_MANIP_HDR_QOS_SRC_USER_DEFINED,    /**< QoS will be taken from the last byte in the parser-result. */
-} e_FmPcdManipHdrQosSrc;
-#endif /* (DPAA_VERSION >= 11) */
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of header insertion
-*//***************************************************************************/
-typedef enum e_FmPcdManipHdrInsrtByHdrType {
-    e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2,        /**< Specific L2 fields insertion */
-#if (DPAA_VERSION >= 11)
-    e_FM_PCD_MANIP_INSRT_BY_HDR_IP,                 /**< IP insertion */
-    e_FM_PCD_MANIP_INSRT_BY_HDR_UDP,                /**< UDP insertion */
-    e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE,             /**< UDP lite insertion */
-    e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP                 /**< CAPWAP insertion */
-#endif /* (DPAA_VERSION >= 11) */
-} e_FmPcdManipHdrInsrtByHdrType;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting specific customCommand
-*//***************************************************************************/
-typedef enum e_FmPcdManipHdrCustomType {
-    e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE,           /**< Replace IPv4/IPv6 */
-} e_FmPcdManipHdrCustomType;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting specific customCommand
-*//***************************************************************************/
-typedef enum e_FmPcdManipHdrCustomIpReplace {
-    e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV4_BY_IPV6,           /**< Replace IPv4 by IPv6 */
-    e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4            /**< Replace IPv6 by IPv4 */
-} e_FmPcdManipHdrCustomIpReplace;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of header removal
-*//***************************************************************************/
-typedef enum e_FmPcdManipHdrRmvByHdrType {
-    e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2 = 0,      /**< Specific L2 fields removal */
-#if (DPAA_VERSION >= 11)
-    e_FM_PCD_MANIP_RMV_BY_HDR_CAPWAP,                  /**< CAPWAP removal */
-#endif /* (DPAA_VERSION >= 11) */
-#if (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
-    e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START,           /**< Locate from data that is not the header */
-#endif /* (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
-} e_FmPcdManipHdrRmvByHdrType;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of timeout mode
-*//***************************************************************************/
-typedef enum e_FmPcdManipReassemTimeOutMode {
-    e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES, /**< Limits the time of the reassembly process
-                                                 from the first fragment to the last */
-    e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG    /**< Limits the time of receiving the fragment */
-} e_FmPcdManipReassemTimeOutMode;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of WaysNumber mode
-*//***************************************************************************/
-typedef enum e_FmPcdManipReassemWaysNumber {
-    e_FM_PCD_MANIP_ONE_WAY_HASH = 1,    /**< One way hash    */
-    e_FM_PCD_MANIP_TWO_WAYS_HASH,       /**< Two ways hash   */
-    e_FM_PCD_MANIP_THREE_WAYS_HASH,     /**< Three ways hash */
-    e_FM_PCD_MANIP_FOUR_WAYS_HASH,      /**< Four ways hash  */
-    e_FM_PCD_MANIP_FIVE_WAYS_HASH,      /**< Five ways hash  */
-    e_FM_PCD_MANIP_SIX_WAYS_HASH,       /**< Six ways hash   */
-    e_FM_PCD_MANIP_SEVEN_WAYS_HASH,     /**< Seven ways hash */
-    e_FM_PCD_MANIP_EIGHT_WAYS_HASH      /**< Eight ways hash */
-} e_FmPcdManipReassemWaysNumber;
-
-#ifdef FM_CAPWAP_SUPPORT
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of statistics mode
-*//***************************************************************************/
-typedef enum e_FmPcdStatsType {
-    e_FM_PCD_STATS_PER_FLOWID = 0       /**< Flow ID is used as index for getting statistics */
-} e_FmPcdStatsType;
-#endif /* FM_CAPWAP_SUPPORT */
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting manipulation type
-*//***************************************************************************/
-typedef enum e_FmPcdManipType {
-    e_FM_PCD_MANIP_HDR = 0,             /**< Header manipulation */
-    e_FM_PCD_MANIP_REASSEM,             /**< Reassembly */
-    e_FM_PCD_MANIP_FRAG,                /**< Fragmentation */
-    e_FM_PCD_MANIP_SPECIAL_OFFLOAD      /**< Special Offloading */
-} e_FmPcdManipType;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of statistics mode
-*//***************************************************************************/
-typedef enum e_FmPcdCcStatsMode {
-    e_FM_PCD_CC_STATS_MODE_NONE = 0,        /**< No statistics support */
-    e_FM_PCD_CC_STATS_MODE_FRAME,           /**< Frame count statistics */
-    e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME,  /**< Byte and frame count statistics */
-#if (DPAA_VERSION >= 11)
-    e_FM_PCD_CC_STATS_MODE_RMON,            /**< Byte and frame length range count statistics;
-                                                 This mode is supported only on B4860 device */
-#endif /* (DPAA_VERSION >= 11) */
-} e_FmPcdCcStatsMode;
-
-/**************************************************************************//**
- @Description   Enumeration type for determining the action in case an IP packet
-                is larger than MTU but its DF (Don't Fragment) bit is set.
-*//***************************************************************************/
-typedef enum e_FmPcdManipDontFragAction {
-    e_FM_PCD_MANIP_DISCARD_PACKET = 0,                  /**< Discard packet */
-    e_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET = e_FM_PCD_MANIP_DISCARD_PACKET,
-                                                        /**< Obsolete, cannot enqueue to error queue;
-                                                             In practice, selects to discard packets;
-                                                             Will be removed in the future */
-    e_FM_PCD_MANIP_FRAGMENT_PACKET,                     /**< Fragment packet and continue normal processing */
-    e_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG                /**< Continue normal processing without fragmenting the packet */
-} e_FmPcdManipDontFragAction;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of special offload manipulation
-*//***************************************************************************/
-typedef enum e_FmPcdManipSpecialOffloadType {
-    e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC,    /**< IPSec offload manipulation */
-#if (DPAA_VERSION >= 11)
-    e_FM_PCD_MANIP_SPECIAL_OFFLOAD_CAPWAP    /**< CAPWAP offload manipulation */
-#endif /* (DPAA_VERSION >= 11) */
-} e_FmPcdManipSpecialOffloadType;
-
-
-/**************************************************************************//**
- @Description   A Union of protocol dependent special options
-*//***************************************************************************/
-typedef union u_FmPcdHdrProtocolOpt {
-    ethProtocolOpt_t    ethOpt;     /**< Ethernet options */
-    vlanProtocolOpt_t   vlanOpt;    /**< VLAN options */
-    mplsProtocolOpt_t   mplsOpt;    /**< MPLS options */
-    ipv4ProtocolOpt_t   ipv4Opt;    /**< IPv4 options */
-    ipv6ProtocolOpt_t   ipv6Opt;    /**< IPv6 options */
-#if (DPAA_VERSION >= 11)
-    capwapProtocolOpt_t capwapOpt;  /**< CAPWAP options */
-#endif /* (DPAA_VERSION >= 11) */
-} u_FmPcdHdrProtocolOpt;
-
-/**************************************************************************//**
- @Description   A union holding protocol fields
-
-
-                Fields supported as "full fields":
-                    HEADER_TYPE_ETH:
-                        NET_HEADER_FIELD_ETH_DA
-                        NET_HEADER_FIELD_ETH_SA
-                        NET_HEADER_FIELD_ETH_TYPE
-
-                    HEADER_TYPE_LLC_SNAP:
-                        NET_HEADER_FIELD_LLC_SNAP_TYPE
-
-                    HEADER_TYPE_VLAN:
-                        NET_HEADER_FIELD_VLAN_TCI
-                                (index may apply:
-                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
-                                 e_FM_PCD_HDR_INDEX_LAST)
-
-                    HEADER_TYPE_MPLS:
-                        NET_HEADER_FIELD_MPLS_LABEL_STACK
-                                (index may apply:
-                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
-                                 e_FM_PCD_HDR_INDEX_2,
-                                 e_FM_PCD_HDR_INDEX_LAST)
-
-                    HEADER_TYPE_IPv4:
-                        NET_HEADER_FIELD_IPv4_SRC_IP
-                        NET_HEADER_FIELD_IPv4_DST_IP
-                        NET_HEADER_FIELD_IPv4_PROTO
-                        NET_HEADER_FIELD_IPv4_TOS
-                                (index may apply:
-                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
-                                 e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
-
-                    HEADER_TYPE_IPv6:
-                        NET_HEADER_FIELD_IPv6_SRC_IP
-                        NET_HEADER_FIELD_IPv6_DST_IP
-                        NET_HEADER_FIELD_IPv6_NEXT_HDR
-                        NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC (must come together!)
-                                (index may apply:
-                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
-                                 e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
-
-                                (Note that starting from DPAA 1-1, NET_HEADER_FIELD_IPv6_NEXT_HDR applies to
-                                 the last next header indication, meaning the next L4, which may be
-                                 present at the Ipv6 last extension. On earlier revisions this field
-                                 applies to the Next-Header field of the main IPv6 header)
-
-                    HEADER_TYPE_IP:
-                        NET_HEADER_FIELD_IP_PROTO
-                                (index may apply:
-                                 e_FM_PCD_HDR_INDEX_LAST)
-                        NET_HEADER_FIELD_IP_DSCP
-                                (index may apply:
-                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1)
-                    HEADER_TYPE_GRE:
-                        NET_HEADER_FIELD_GRE_TYPE
-
-                    HEADER_TYPE_MINENCAP
-                        NET_HEADER_FIELD_MINENCAP_SRC_IP
-                        NET_HEADER_FIELD_MINENCAP_DST_IP
-                        NET_HEADER_FIELD_MINENCAP_TYPE
-
-                    HEADER_TYPE_TCP:
-                        NET_HEADER_FIELD_TCP_PORT_SRC
-                        NET_HEADER_FIELD_TCP_PORT_DST
-                        NET_HEADER_FIELD_TCP_FLAGS
-
-                    HEADER_TYPE_UDP:
-                        NET_HEADER_FIELD_UDP_PORT_SRC
-                        NET_HEADER_FIELD_UDP_PORT_DST
-
-                    HEADER_TYPE_UDP_LITE:
-                        NET_HEADER_FIELD_UDP_LITE_PORT_SRC
-                        NET_HEADER_FIELD_UDP_LITE_PORT_DST
-
-                    HEADER_TYPE_IPSEC_AH:
-                        NET_HEADER_FIELD_IPSEC_AH_SPI
-                        NET_HEADER_FIELD_IPSEC_AH_NH
-
-                    HEADER_TYPE_IPSEC_ESP:
-                        NET_HEADER_FIELD_IPSEC_ESP_SPI
-
-                    HEADER_TYPE_SCTP:
-                        NET_HEADER_FIELD_SCTP_PORT_SRC
-                        NET_HEADER_FIELD_SCTP_PORT_DST
-
-                    HEADER_TYPE_DCCP:
-                        NET_HEADER_FIELD_DCCP_PORT_SRC
-                        NET_HEADER_FIELD_DCCP_PORT_DST
-
-                    HEADER_TYPE_PPPoE:
-                        NET_HEADER_FIELD_PPPoE_PID
-                        NET_HEADER_FIELD_PPPoE_SID
-
-        *****************************************************************
-                Fields supported as "from fields":
-                    HEADER_TYPE_ETH (with or without validation):
-                        NET_HEADER_FIELD_ETH_TYPE
-
-                    HEADER_TYPE_VLAN (with or without validation):
-                        NET_HEADER_FIELD_VLAN_TCI
-                                (index may apply:
-                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
-                                 e_FM_PCD_HDR_INDEX_LAST)
-
-                    HEADER_TYPE_IPv4 (without validation):
-                        NET_HEADER_FIELD_IPv4_PROTO
-                                (index may apply:
-                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
-                                 e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
-
-                    HEADER_TYPE_IPv6 (without validation):
-                        NET_HEADER_FIELD_IPv6_NEXT_HDR
-                                (index may apply:
-                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
-                                 e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
-
-*//***************************************************************************/
-typedef union t_FmPcdFields {
-    headerFieldEth_t            eth;            /**< Ethernet               */
-    headerFieldVlan_t           vlan;           /**< VLAN                   */
-    headerFieldLlcSnap_t        llcSnap;        /**< LLC SNAP               */
-    headerFieldPppoe_t          pppoe;          /**< PPPoE                  */
-    headerFieldMpls_t           mpls;           /**< MPLS                   */
-    headerFieldIp_t             ip;             /**< IP                     */
-    headerFieldIpv4_t           ipv4;           /**< IPv4                   */
-    headerFieldIpv6_t           ipv6;           /**< IPv6                   */
-    headerFieldUdp_t            udp;            /**< UDP                    */
-    headerFieldUdpLite_t        udpLite;        /**< UDP Lite               */
-    headerFieldTcp_t            tcp;            /**< TCP                    */
-    headerFieldSctp_t           sctp;           /**< SCTP                   */
-    headerFieldDccp_t           dccp;           /**< DCCP                   */
-    headerFieldGre_t            gre;            /**< GRE                    */
-    headerFieldMinencap_t       minencap;       /**< Minimal Encapsulation  */
-    headerFieldIpsecAh_t        ipsecAh;        /**< IPSec AH               */
-    headerFieldIpsecEsp_t       ipsecEsp;       /**< IPSec ESP              */
-    headerFieldUdpEncapEsp_t    udpEncapEsp;    /**< UDP Encapsulation ESP  */
-} t_FmPcdFields;
-
-/**************************************************************************//**
- @Description   Parameters for defining header extraction for key generation
-*//***************************************************************************/
-typedef struct t_FmPcdFromHdr {
-    uint8_t             size;           /**< Size in byte */
-    uint8_t             offset;         /**< Byte offset */
-} t_FmPcdFromHdr;
-
-/**************************************************************************//**
- @Description   Parameters for defining field extraction for key generation
-*//***************************************************************************/
-typedef struct t_FmPcdFromField {
-    t_FmPcdFields       field;          /**< Field selection */
-    uint8_t             size;           /**< Size in byte */
-    uint8_t             offset;         /**< Byte offset */
-} t_FmPcdFromField;
-
-/**************************************************************************//**
- @Description   Parameters for defining a single network environment unit
-
-                A distinction unit should be defined if it will later be used
-                by one or more PCD engines to distinguish between flows.
-*//***************************************************************************/
-typedef struct t_FmPcdDistinctionUnit {
-    struct {
-        e_NetHeaderType         hdr;        /**< One of the headers supported by the FM */
-        u_FmPcdHdrProtocolOpt   opt;        /**< Select only one option ! */
-    } hdrs[FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS];
-} t_FmPcdDistinctionUnit;
-
-/**************************************************************************//**
- @Description   Parameters for defining all different distinction units supported
-                by a specific PCD Network Environment Characteristics module.
-
-                Each unit represent a protocol or a group of protocols that may
-                be used later by the different PCD engines to distinguish
-                between flows.
-*//***************************************************************************/
-typedef struct t_FmPcdNetEnvParams {
-    uint8_t                 numOfDistinctionUnits;                      /**< Number of different units to be identified */
-    t_FmPcdDistinctionUnit  units[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS]; /**< An array of numOfDistinctionUnits of the
-                                                                             different units to be identified */
-} t_FmPcdNetEnvParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining a single extraction action when
-                creating a key
-*//***************************************************************************/
-typedef struct t_FmPcdExtractEntry {
-    e_FmPcdExtractType                  type;           /**< Extraction type select */
-    union {
-        struct {
-            e_NetHeaderType             hdr;            /**< Header selection */
-            bool                        ignoreProtocolValidation;
-                                                        /**< Ignore protocol validation */
-            e_FmPcdHdrIndex             hdrIndex;       /**< Relevant only for MPLS, VLAN and tunneled
-                                                             IP. Otherwise should be cleared. */
-            e_FmPcdExtractByHdrType     type;           /**< Header extraction type select */
-            union {
-                t_FmPcdFromHdr          fromHdr;        /**< Extract bytes from header parameters */
-                t_FmPcdFromField        fromField;      /**< Extract bytes from field parameters */
-                t_FmPcdFields           fullField;      /**< Extract full filed parameters */
-            } extractByHdrType;
-        } extractByHdr;                                 /**< used when type = e_FM_PCD_KG_EXTRACT_BY_HDR */
-        struct {
-            e_FmPcdExtractFrom          src;            /**< Non-header extraction source */
-            e_FmPcdAction               action;         /**< Relevant for CC Only */
-            uint16_t                    icIndxMask;     /**< Relevant only for CC when
-                                                             action = e_FM_PCD_ACTION_INDEXED_LOOKUP;
-                                                             Note that the number of bits that are set within
-                                                             this mask must be log2 of the CC-node 'numOfKeys'.
-                                                             Note that the mask cannot be set on the lower bits. */
-            uint8_t                     offset;         /**< Byte offset */
-            uint8_t                     size;           /**< Size in byte */
-        } extractNonHdr;                                /**< used when type = e_FM_PCD_KG_EXTRACT_NON_HDR */
-    };
-} t_FmPcdExtractEntry;
-
-/**************************************************************************//**
- @Description   Parameters for defining masks for each extracted field in the key.
-*//***************************************************************************/
-typedef struct t_FmPcdKgExtractMask {
-    uint8_t                             extractArrayIndex;  /**< Index in the extraction array, as initialized by user */
-    uint8_t                             offset;             /**< Byte offset */
-    uint8_t                             mask;               /**< A byte mask (selected bits will be used) */
-} t_FmPcdKgExtractMask;
-
-/**************************************************************************//**
- @Description   Parameters for defining default selection per groups of fields
-*//***************************************************************************/
-typedef struct t_FmPcdKgExtractDflt {
-    e_FmPcdKgKnownFieldsDfltTypes       type;                /**< Default type select */
-    e_FmPcdKgExtractDfltSelect          dfltSelect;          /**< Default register select */
-} t_FmPcdKgExtractDflt;
-
-/**************************************************************************//**
- @Description   Parameters for defining key extraction and hashing
-*//***************************************************************************/
-typedef struct t_FmPcdKgKeyExtractAndHashParams {
-    uint32_t                    privateDflt0;                /**< Scheme default register 0 */
-    uint32_t                    privateDflt1;                /**< Scheme default register 1 */
-    uint8_t                     numOfUsedExtracts;           /**< defines the valid size of the following array */
-    t_FmPcdExtractEntry         extractArray [FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY]; /**< An array of extractions definition. */
-    uint8_t                     numOfUsedDflts;              /**< defines the valid size of the following array */
-    t_FmPcdKgExtractDflt        dflts[FM_PCD_KG_NUM_OF_DEFAULT_GROUPS];
-                                                             /**< For each extraction used in this scheme, specify the required
-                                                                  default register to be used when header is not found.
-                                                                  types not specified in this array will get undefined value. */
-    uint8_t                     numOfUsedMasks;              /**< defines the valid size of the following array */
-    t_FmPcdKgExtractMask        masks[FM_PCD_KG_NUM_OF_EXTRACT_MASKS];
-    uint8_t                     hashShift;                   /**< hash result right shift. Select the 24 bits out of the 64 hash
-                                                                  result. 0 means using the 24 LSB's, otherwise use the
-                                                                  24 LSB's after shifting right.*/
-    uint32_t                    hashDistributionNumOfFqids;  /**< must be > 1 and a power of 2. Represents the range
-                                                                  of queues for the key and hash functionality */
-    uint8_t                     hashDistributionFqidsShift;  /**< selects the FQID bits that will be effected by the hash */
-    bool                        symmetricHash;               /**< TRUE to generate the same hash for frames with swapped source and
-                                                                  destination fields on all layers; If TRUE, driver will check that for
-                                                                  all layers, if SRC extraction is selected, DST extraction must also be
-                                                                  selected, and vice versa. */
-} t_FmPcdKgKeyExtractAndHashParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining a single FQID mask (extracted OR).
-*//***************************************************************************/
-typedef struct t_FmPcdKgExtractedOrParams {
-    e_FmPcdExtractType              type;               /**< Extraction type select */
-    union {
-        struct {                                        /**< used when type = e_FM_PCD_KG_EXTRACT_BY_HDR */
-            e_NetHeaderType         hdr;
-            e_FmPcdHdrIndex         hdrIndex;           /**< Relevant only for MPLS, VLAN and tunneled
-                                                             IP. Otherwise should be cleared.*/
-            bool                    ignoreProtocolValidation;
-                                                        /**< continue extraction even if protocol is not recognized */
-        } extractByHdr;                                 /**< Header to extract by */
-        e_FmPcdExtractFrom          src;                /**< used when type = e_FM_PCD_KG_EXTRACT_NON_HDR */
-    };
-    uint8_t                         extractionOffset;   /**< Offset for extraction (in bytes).  */
-    e_FmPcdKgExtractDfltSelect      dfltValue;          /**< Select register from which extraction is taken if
-                                                             field not found */
-    uint8_t                         mask;               /**< Extraction mask (specified bits are used) */
-    uint8_t                         bitOffsetInFqid;    /**< 0-31, Selects which bits of the 24 FQID bits to effect using
-                                                             the extracted byte; Assume byte is placed as the 8 MSB's in
-                                                             a 32 bit word where the lower bits
-                                                             are the FQID; i.e if bitOffsetInFqid=1 than its LSB
-                                                             will effect the FQID MSB, if bitOffsetInFqid=24 than the
-                                                             extracted byte will effect the 8 LSB's of the FQID,
-                                                             if bitOffsetInFqid=31 than the byte's MSB will effect
-                                                             the FQID's LSB; 0 means - no effect on FQID;
-                                                             Note that one, and only one of
-                                                             bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
-                                                             extracted byte must effect either FQID or Policer profile).*/
-    uint8_t                         bitOffsetInPlcrProfile;
-                                                        /**< 0-15, Selects which bits of the 8 policer profile id bits to
-                                                             effect using the extracted byte; Assume byte is placed
-                                                             as the 8 MSB's in a 16 bit word where the lower bits
-                                                             are the policer profile id; i.e if bitOffsetInPlcrProfile=1
-                                                             than its LSB will effect the profile MSB, if bitOffsetInFqid=8
-                                                             than the extracted byte will effect the whole policer profile id,
-                                                             if bitOffsetInFqid=15 than the byte's MSB will effect
-                                                             the Policer Profile id's LSB;
-                                                             0 means - no effect on policer profile; Note that one, and only one of
-                                                             bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
-                                                             extracted byte must effect either FQID or Policer profile).*/
-} t_FmPcdKgExtractedOrParams;
-
-/**************************************************************************//**
- @Description   Parameters for configuring a scheme counter
-*//***************************************************************************/
-typedef struct t_FmPcdKgSchemeCounter {
-    bool        update;     /**< FALSE to keep the current counter state
-                                 and continue from that point, TRUE to update/reset
-                                 the counter when the scheme is written. */
-    uint32_t    value;      /**< If update=TRUE, this value will be written into the
-                                 counter. clear this field to reset the counter. */
-} t_FmPcdKgSchemeCounter;
-
-/**************************************************************************//**
- @Description   Parameters for configuring a policer profile for a KeyGen scheme
-                (when policer is the next engine after this scheme).
-*//***************************************************************************/
-typedef struct t_FmPcdKgPlcrProfile {
-    bool                sharedProfile;              /**< TRUE if this profile is shared between ports
-                                                         (managed by master partition); Must not be TRUE
-                                                         if profile is after Coarse Classification*/
-    bool                direct;                     /**< if TRUE, directRelativeProfileId only selects the profile
-                                                         id, if FALSE fqidOffsetRelativeProfileIdBase is used
-                                                         together with fqidOffsetShift and numOfProfiles
-                                                         parameters, to define a range of profiles from
-                                                         which the KeyGen result will determine the
-                                                         destination policer profile.  */
-    union {
-        uint16_t        directRelativeProfileId;    /**< Used if 'direct' is TRUE, to select policer profile.
-                                                         should indicate the policer profile offset within the
-                                                         port's policer profiles or shared window. */
-        struct {
-            uint8_t     fqidOffsetShift;            /**< Shift on the KeyGen create FQID offset (i.e. not the
-                                                         final FQID - without the FQID base). */
-            uint8_t     fqidOffsetRelativeProfileIdBase;
-                                                    /**< The base of the FMan Port's relative Storage-Profile ID;
-                                                         this value will be "OR'ed" with the KeyGen create FQID
-                                                         offset (i.e. not the final FQID - without the FQID base);
-                                                         the final result should indicate the Storage-Profile offset
-                                                         within the FMan Port's relative Storage-Profiles window/
-                                                         (or the SHARED window depends on 'sharedProfile'). */
-            uint8_t     numOfProfiles;              /**< Range of profiles starting at base */
-        } indirectProfile;                          /**< Indirect profile parameters */
-    } profileSelect;                                /**< Direct/indirect profile selection and parameters */
-} t_FmPcdKgPlcrProfile;
-
-#if (DPAA_VERSION >= 11)
-/**************************************************************************//**
- @Description   Parameters for configuring a storage profile for a KeyGen scheme.
-*//***************************************************************************/
-typedef struct t_FmPcdKgStorageProfile {
-    bool                direct;                     /**< If TRUE, directRelativeProfileId only selects the
-                                                         profile id;
-                                                         If FALSE, fqidOffsetRelativeProfileIdBase is used
-                                                         together with fqidOffsetShift and numOfProfiles
-                                                         parameters to define a range of profiles from which
-                                                         the KeyGen result will determine the destination
-                                                         storage profile. */
-    union {
-        uint16_t        directRelativeProfileId;    /**< Used when 'direct' is TRUE, to select a storage profile;
-                                                         should indicate the storage profile offset within the
-                                                         port's storage profiles window. */
-        struct {
-            uint8_t     fqidOffsetShift;            /**< Shift on the KeyGen create FQID offset (i.e. not the
-                                                         final FQID - without the FQID base). */
-            uint8_t     fqidOffsetRelativeProfileIdBase;
-                                                    /**< The base of the FMan Port's relative Storage-Profile ID;
-                                                         this value will be "OR'ed" with the KeyGen create FQID
-                                                         offset (i.e. not the final FQID - without the FQID base);
-                                                         the final result should indicate the Storage-Profile offset
-                                                         within the FMan Port's relative Storage-Profiles window. */
-            uint8_t     numOfProfiles;              /**< Range of profiles starting at base. */
-        } indirectProfile;                          /**< Indirect profile parameters. */
-    } profileSelect;                                /**< Direct/indirect profile selection and parameters. */
-} t_FmPcdKgStorageProfile;
-#endif /* (DPAA_VERSION >= 11) */
-
-/**************************************************************************//**
- @Description   Parameters for defining CC as the next engine after KeyGen
-*//***************************************************************************/
-typedef struct t_FmPcdKgCc {
-    t_Handle                h_CcTree;                       /**< A handle to a CC Tree */
-    uint8_t                 grpId;                          /**< CC group id within the CC tree */
-    bool                    plcrNext;                       /**< TRUE if after CC, in case of data frame,
-                                                                 policing is required. */
-    bool                    bypassPlcrProfileGeneration;    /**< TRUE to bypass KeyGen policer profile generation;
-                                                                 selected profile is the one set at port initialization. */
-    t_FmPcdKgPlcrProfile    plcrProfile;                    /**< Valid only if plcrNext = TRUE and
-                                                                 bypassPlcrProfileGeneration = FALSE */
-} t_FmPcdKgCc;
-
-/**************************************************************************//**
- @Description   Parameters for defining initializing a KeyGen scheme
-*//***************************************************************************/
-typedef struct t_FmPcdKgSchemeParams {
-    bool                                modify;                 /**< TRUE to change an existing scheme */
-    union
-    {
-        uint8_t                         relativeSchemeId;       /**< if modify=FALSE:Partition relative scheme id */
-        t_Handle                        h_Scheme;               /**< if modify=TRUE: a handle of the existing scheme */
-    } id;
-    bool                                alwaysDirect;           /**< This scheme is reached only directly, i.e. no need
-                                                                     for match vector; KeyGen will ignore it when matching */
-    struct {                                                    /**< HL Relevant only if alwaysDirect = FALSE */
-        t_Handle                        h_NetEnv;               /**< A handle to the Network environment as returned
-                                                                     by FM_PCD_NetEnvCharacteristicsSet() */
-        uint8_t                         numOfDistinctionUnits;  /**< Number of NetEnv units listed in unitIds array */
-        uint8_t                         unitIds[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
-                                                                /**< Indexes as passed to SetNetEnvCharacteristics array*/
-    } netEnvParams;
-    bool                                useHash;                /**< use the KeyGen Hash functionality  */
-    t_FmPcdKgKeyExtractAndHashParams    keyExtractAndHashParams;
-                                                                /**< used only if useHash = TRUE */
-    bool                                bypassFqidGeneration;   /**< Normally - FALSE, TRUE to avoid FQID update in the IC;
-                                                                     In such a case FQID after KeyGen will be the default FQID
-                                                                     defined for the relevant port, or the FQID defined by CC
-                                                                     in cases where CC was the previous engine. */
-    uint32_t                            baseFqid;               /**< Base FQID; Relevant only if bypassFqidGeneration = FALSE;
-                                                                     If hash is used and an even distribution is expected
-                                                                     according to hashDistributionNumOfFqids, baseFqid must be aligned to
-                                                                     hashDistributionNumOfFqids. */
-    uint8_t                             numOfUsedExtractedOrs;  /**< Number of FQID masks listed in extractedOrs array */
-    t_FmPcdKgExtractedOrParams          extractedOrs[FM_PCD_KG_NUM_OF_GENERIC_REGS];
-                                                                /**< FM_PCD_KG_NUM_OF_GENERIC_REGS
-                                                                     registers are shared between qidMasks
-                                                                     functionality and some of the extraction
-                                                                     actions; Normally only some will be used
-                                                                     for qidMask. Driver will return error if
-                                                                     resource is full at initialization time. */
-
-#if (DPAA_VERSION >= 11)
-    bool                                overrideStorageProfile; /**< TRUE if KeyGen override previously decided storage profile */
-    t_FmPcdKgStorageProfile             storageProfile;         /**< Used when overrideStorageProfile TRUE */
-#endif /* (DPAA_VERSION >= 11) */
-
-    e_FmPcdEngine                       nextEngine;             /**< may be BMI, PLCR or CC */
-    union {                                                     /**< depends on nextEngine */
-        e_FmPcdDoneAction               doneAction;             /**< Used when next engine is BMI (done) */
-        t_FmPcdKgPlcrProfile            plcrProfile;            /**< Used when next engine is PLCR */
-        t_FmPcdKgCc                     cc;                     /**< Used when next engine is CC */
-    } kgNextEngineParams;
-    t_FmPcdKgSchemeCounter              schemeCounter;          /**< A structure of parameters for updating
-                                                                     the scheme counter */
-} t_FmPcdKgSchemeParams;
-
-/**************************************************************************//**
- @Collection    Definitions for CC statistics
-*//***************************************************************************/
-#if (DPAA_VERSION >= 11)
-#define FM_PCD_CC_STATS_MAX_NUM_OF_FLR      10  /* Maximal supported number of frame length ranges */
-#define FM_PCD_CC_STATS_FLR_SIZE            2   /* Size in bytes of a frame length range limit */
-#endif /* (DPAA_VERSION >= 11) */
-#define FM_PCD_CC_STATS_COUNTER_SIZE        4   /* Size in bytes of a frame length range counter */
-/* @} */
-
-/**************************************************************************//**
- @Description   Parameters for defining CC as the next engine after a CC node.
-*//***************************************************************************/
-typedef struct t_FmPcdCcNextCcParams {
-    t_Handle    h_CcNode;               /**< A handle of the next CC node */
-} t_FmPcdCcNextCcParams;
-
-#if (DPAA_VERSION >= 11)
-/**************************************************************************//**
- @Description   Parameters for defining Frame replicator as the next engine after a CC node.
-*//***************************************************************************/
-typedef struct t_FmPcdCcNextFrParams {
-    t_Handle    h_FrmReplic;               /**< A handle of the next frame replicator group */
-} t_FmPcdCcNextFrParams;
-#endif /* (DPAA_VERSION >= 11) */
-
-/**************************************************************************//**
- @Description   Parameters for defining Policer as the next engine after a CC node.
-*//***************************************************************************/
-typedef struct t_FmPcdCcNextPlcrParams {
-    bool        overrideParams;         /**< TRUE if CC override previously decided parameters*/
-    bool        sharedProfile;          /**< Relevant only if overrideParams=TRUE:
-                                             TRUE if this profile is shared between ports */
-    uint16_t    newRelativeProfileId;   /**< Relevant only if overrideParams=TRUE:
-                                             (otherwise profile id is taken from KeyGen);
-                                             This parameter should indicate the policer
-                                             profile offset within the port's
-                                             policer profiles or from SHARED window.*/
-    uint32_t    newFqid;                /**< Relevant only if overrideParams=TRUE:
-                                             FQID for enqueuing the frame;
-                                             In earlier chips  if policer next engine is KEYGEN,
-                                             this parameter can be 0, because the KEYGEN
-                                             always decides the enqueue FQID.*/
-#if (DPAA_VERSION >= 11)
-    uint8_t     newRelativeStorageProfileId;
-                                        /**< Indicates the relative storage profile offset within
-                                             the port's storage profiles window;
-                                             Relevant only if the port was configured with VSP. */
-#endif /* (DPAA_VERSION >= 11) */
-} t_FmPcdCcNextPlcrParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining enqueue as the next action after a CC node.
-*//***************************************************************************/
-typedef struct t_FmPcdCcNextEnqueueParams {
-    e_FmPcdDoneAction    action;        /**< Action - when next engine is BMI (done) */
-    bool                 overrideFqid;  /**< TRUE if CC override previously decided fqid and vspid,
-                                             relevant if action = e_FM_PCD_ENQ_FRAME */
-    uint32_t             newFqid;       /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
-                                             (otherwise FQID is taken from KeyGen),
-                                             relevant if action = e_FM_PCD_ENQ_FRAME */
-#if (DPAA_VERSION >= 11)
-    uint8_t              newRelativeStorageProfileId;
-                                        /**< Valid if overrideFqid=TRUE, Indicates the relative virtual
-                                             storage profile offset within the port's storage profiles
-                                             window; Relevant only if the port was configured with VSP. */
-#endif /* (DPAA_VERSION >= 11) */
-} t_FmPcdCcNextEnqueueParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining KeyGen as the next engine after a CC node.
-*//***************************************************************************/
-typedef struct t_FmPcdCcNextKgParams {
-    bool        overrideFqid;           /**< TRUE if CC override previously decided fqid and vspid,
-                                             Note - this parameters irrelevant for earlier chips */
-    uint32_t    newFqid;                /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
-                                             (otherwise FQID is taken from KeyGen),
-                                             Note - this parameters irrelevant for earlier chips */
-#if (DPAA_VERSION >= 11)
-    uint8_t     newRelativeStorageProfileId;
-                                        /**< Valid if overrideFqid=TRUE, Indicates the relative virtual
-                                             storage profile offset within the port's storage profiles
-                                             window; Relevant only if the port was configured with VSP. */
-#endif /* (DPAA_VERSION >= 11) */
-
-    t_Handle    h_DirectScheme;         /**< Direct scheme handle to go to. */
-} t_FmPcdCcNextKgParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining the next engine after a CC node.
-*//***************************************************************************/
-typedef struct t_FmPcdCcNextEngineParams {
-    e_FmPcdEngine                       nextEngine;     /**< User has to initialize parameters
-                                                             according to nextEngine definition */
-    union {
-        t_FmPcdCcNextCcParams           ccParams;       /**< Parameters in case next engine is CC */
-        t_FmPcdCcNextPlcrParams         plcrParams;     /**< Parameters in case next engine is PLCR */
-        t_FmPcdCcNextEnqueueParams      enqueueParams;  /**< Parameters in case next engine is BMI */
-        t_FmPcdCcNextKgParams           kgParams;       /**< Parameters in case next engine is KG */
-#if (DPAA_VERSION >= 11)
-        t_FmPcdCcNextFrParams           frParams;       /**< Parameters in case next engine is FR */
-#endif /* (DPAA_VERSION >= 11) */
-    } params;                                           /**< union used for all the next-engine parameters options */
-
-    t_Handle                            h_Manip;        /**< Handle to Manipulation object.
-                                                             Relevant if next engine is of type result
-                                                             (e_FM_PCD_PLCR, e_FM_PCD_KG, e_FM_PCD_DONE) */
-
-    bool                                statisticsEn;   /**< If TRUE, statistics counters are incremented
-                                                             for each frame passing through this
-                                                             Coarse Classification entry. */
-} t_FmPcdCcNextEngineParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining a single CC key
-*//***************************************************************************/
-typedef struct t_FmPcdCcKeyParams {
-    uint8_t                     *p_Key;     /**< Relevant only if 'action' = e_FM_PCD_ACTION_EXACT_MATCH;
-                                                 pointer to the key of the size defined in keySize */
-    uint8_t                     *p_Mask;    /**< Relevant only if 'action' = e_FM_PCD_ACTION_EXACT_MATCH;
-                                                 pointer to the Mask per key  of the size defined
-                                                 in keySize. p_Key and p_Mask (if defined) has to be
-                                                 of the same size defined in the keySize;
-                                                 NOTE that if this value is equal for all entries whithin
-                                                 this table, the driver will automatically use global-mask
-                                                 (i.e. one common mask for all entries) instead of private
-                                                 one; that is done in order to spare some memory and for
-                                                 better performance. */
-    t_FmPcdCcNextEngineParams   ccNextEngineParams;
-                                            /**< parameters for the next for the defined Key in
-                                                 the p_Key */
-} t_FmPcdCcKeyParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining CC keys parameters
-                The driver supports two methods for CC node allocation: dynamic and static.
-                Static mode was created in order to prevent runtime alloc/free
-                of FMan memory (MURAM), which may cause fragmentation; in this mode,
-                the driver automatically allocates the memory according to
-                'maxNumOfKeys' parameter. The driver calculates the maximal memory
-                size that may be used for this CC-Node taking into consideration
-                'maskSupport' and 'statisticsMode' parameters.
-                When 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP in the extraction
-                parameters of this node, 'maxNumOfKeys' must be equal to 'numOfKeys'.
-                In dynamic mode, 'maxNumOfKeys' must be zero. At initialization,
-                all required structures are allocated according to 'numOfKeys'
-                parameter. During runtime modification, these structures are
-                re-allocated according to the updated number of keys.
-
-                Please note that 'action' and 'icIndxMask' mentioned in the
-                specific parameter explanations are passed in the extraction
-                parameters of the node (fields of extractCcParams.extractNonHdr).
-*//***************************************************************************/
-typedef struct t_KeysParams {
-    uint16_t                    maxNumOfKeys;   /**< Maximum number of keys that will (ever) be used in this CC-Node;
-                                                     A value of zero may be used for dynamic memory allocation. */
-    bool                        maskSupport;    /**< This parameter is relevant only if a node is initialized with
-                                                     'action' = e_FM_PCD_ACTION_EXACT_MATCH and maxNumOfKeys > 0;
-                                                     Should be TRUE to reserve table memory for key masks, even if
-                                                     initial keys do not contain masks, or if the node was initialized
-                                                     as 'empty' (without keys); this will allow user to add keys with
-                                                     masks at runtime.
-                                                     NOTE that if user want to use only global-masks (i.e. one common mask
-                                                     for all the entries within this table, this parameter should set to 'FALSE'. */
-    e_FmPcdCcStatsMode          statisticsMode; /**< Determines the supported statistics mode for all node's keys.
-                                                     To enable statistics gathering, statistics should be enabled per
-                                                     every key, using 'statisticsEn' in next engine parameters structure
-                                                     of that key;
-                                                     If 'maxNumOfKeys' is set, all required structures will be
-                                                     preallocated for all keys. */
-#if (DPAA_VERSION >= 11)
-    uint16_t                    frameLengthRanges[FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
-                                                /**< Relevant only for 'RMON' statistics mode
-                                                     (this feature is supported only on B4860 device);
-                                                     Holds a list of programmable thresholds - for each received frame,
-                                                     its length in bytes is examined against these range thresholds and
-                                                     the appropriate counter is incremented by 1 - for example, to belong
-                                                     to range i, the following should hold:
-                                                     range i-1 threshold < frame length <= range i threshold
-                                                     Each range threshold must be larger then its preceding range
-                                                     threshold, and last range threshold must be 0xFFFF. */
-#endif /* (DPAA_VERSION >= 11) */
-    uint16_t                    numOfKeys;      /**< Number of initial keys;
-                                                     Note that in case of 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP,
-                                                     this field should be power-of-2 of the number of bits that are
-                                                     set in 'icIndxMask'. */
-    uint8_t                     keySize;        /**< Size of key - for extraction of type FULL_FIELD, 'keySize' has
-                                                     to be the standard size of the selected key; For other extraction
-                                                     types, 'keySize' has to be as size of extraction; When 'action' =
-                                                     e_FM_PCD_ACTION_INDEXED_LOOKUP, 'keySize' must be 2. */
-    t_FmPcdCcKeyParams          keyParams[FM_PCD_MAX_NUM_OF_KEYS];
-                                                /**< An array with 'numOfKeys' entries, each entry specifies the
-                                                     corresponding key parameters;
-                                                     When 'action' = e_FM_PCD_ACTION_EXACT_MATCH, this value must not
-                                                     exceed 255 (FM_PCD_MAX_NUM_OF_KEYS-1) as the last entry is saved
-                                                     for the 'miss' entry. */
-    t_FmPcdCcNextEngineParams   ccNextEngineParamsForMiss;
-                                                /**< Parameters for defining the next engine when a key is not matched;
-                                                     Not relevant if action = e_FM_PCD_ACTION_INDEXED_LOOKUP. */
-} t_KeysParams;
-
-
-/**************************************************************************//**
- @Description   Parameters for defining a CC node
-*//***************************************************************************/
-typedef struct t_FmPcdCcNodeParams {
-    t_FmPcdExtractEntry         extractCcParams;    /**< Extraction parameters */
-    t_KeysParams                keysParams;         /**< Keys definition matching the selected extraction */
-} t_FmPcdCcNodeParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining a hash table
-*//***************************************************************************/
-typedef struct t_FmPcdHashTableParams {
-    uint16_t                    maxNumOfKeys;               /**< Maximum Number Of Keys that will (ever) be used in this Hash-table */
-    e_FmPcdCcStatsMode          statisticsMode;             /**< If not e_FM_PCD_CC_STATS_MODE_NONE, the required structures for the
-                                                                 requested statistics mode will be allocated according to maxNumOfKeys. */
-    uint8_t                     kgHashShift;                /**< KG-Hash-shift as it was configured in the KG-scheme
-                                                                 that leads to this hash-table. */
-    uint16_t                    hashResMask;                /**< Mask that will be used on the hash-result;
-                                                                 The number-of-sets for this hash will be calculated
-                                                                 as (2^(number of bits set in 'hashResMask'));
-                                                                 The 4 lower bits must be cleared. */
-    uint8_t                     hashShift;                  /**< Byte offset from the beginning of the KeyGen hash result to the
-                                                                 2-bytes to be used as hash index. */
-    uint8_t                     matchKeySize;               /**< Size of the exact match keys held by the hash buckets */
-
-    t_FmPcdCcNextEngineParams   ccNextEngineParamsForMiss;  /**< Parameters for defining the next engine when a key is not matched */
-} t_FmPcdHashTableParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining a CC tree group.
-
-                This structure defines a CC group in terms of NetEnv units
-                and the action to be taken in each case. The unitIds list must
-                be given in order from low to high indices.
-
-                t_FmPcdCcNextEngineParams is a list of 2^numOfDistinctionUnits
-                structures where each defines the next action to be taken for
-                each units combination. for example:
-                numOfDistinctionUnits = 2
-                unitIds = {1,3}
-                p_NextEnginePerEntriesInGrp[0] = t_FmPcdCcNextEngineParams for the case that
-                                                        unit 1 - not found; unit 3 - not found;
-                p_NextEnginePerEntriesInGrp[1] = t_FmPcdCcNextEngineParams for the case that
-                                                        unit 1 - not found; unit 3 - found;
-                p_NextEnginePerEntriesInGrp[2] = t_FmPcdCcNextEngineParams for the case that
-                                                        unit 1 - found; unit 3 - not found;
-                p_NextEnginePerEntriesInGrp[3] = t_FmPcdCcNextEngineParams for the case that
-                                                        unit 1 - found; unit 3 - found;
-*//***************************************************************************/
-typedef struct t_FmPcdCcGrpParams {
-    uint8_t                     numOfDistinctionUnits;          /**< Up to 4 */
-    uint8_t                     unitIds[FM_PCD_MAX_NUM_OF_CC_UNITS];
-                                                                /**< Indices of the units as defined in
-                                                                     FM_PCD_NetEnvCharacteristicsSet() */
-    t_FmPcdCcNextEngineParams   nextEnginePerEntriesInGrp[FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP];
-                                                                /**< Maximum entries per group is 16 */
-} t_FmPcdCcGrpParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining CC tree groups
-*//***************************************************************************/
-typedef struct t_FmPcdCcTreeParams {
-    t_Handle                h_NetEnv;                   /**< A handle to the Network environment as returned
-                                                             by FM_PCD_NetEnvCharacteristicsSet() */
-    uint8_t                 numOfGrps;                  /**< Number of CC groups within the CC tree */
-    t_FmPcdCcGrpParams      ccGrpParams[FM_PCD_MAX_NUM_OF_CC_GROUPS];
-                                                        /**< Parameters for each group. */
-} t_FmPcdCcTreeParams;
-
-
-/**************************************************************************//**
- @Description   CC key statistics structure
-*//***************************************************************************/
-typedef struct t_FmPcdCcKeyStatistics {
-    uint32_t    byteCount;      /**< This counter reflects byte count of frames that
-                                     were matched by this key. */
-    uint32_t    frameCount;     /**< This counter reflects count of frames that
-                                     were matched by this key. */
-#if (DPAA_VERSION >= 11)
-    uint32_t    frameLengthRangeCount[FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
-                                /**< These counters reflect how many frames matched
-                                     this key in 'RMON' statistics mode:
-                                     Each counter holds the number of frames of a
-                                     specific frames length range, according to the
-                                     ranges provided at initialization. */
-#endif /* (DPAA_VERSION >= 11) */
-} t_FmPcdCcKeyStatistics;
-
-/**************************************************************************//**
- @Description   Parameters for defining policer byte rate
-*//***************************************************************************/
-typedef struct t_FmPcdPlcrByteRateModeParams {
-    e_FmPcdPlcrFrameLengthSelect    frameLengthSelection;   /**< Frame length selection */
-    e_FmPcdPlcrRollBackFrameSelect  rollBackFrameSelection; /**< relevant option only e_FM_PCD_PLCR_L2_FRM_LEN,
-                                                                 e_FM_PCD_PLCR_FULL_FRM_LEN */
-} t_FmPcdPlcrByteRateModeParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining the policer profile (based on
-                RFC-2698 or RFC-4115 attributes).
-*//***************************************************************************/
-typedef struct t_FmPcdPlcrNonPassthroughAlgParams {
-    e_FmPcdPlcrRateMode              rateMode;                       /**< Byte mode or Packet mode */
-    t_FmPcdPlcrByteRateModeParams    byteModeParams;                 /**< Valid for Byte NULL for Packet */
-    uint32_t                         comittedInfoRate;               /**< KBits/Second or Packets/Second */
-    uint32_t                         comittedBurstSize;              /**< Bytes/Packets */
-    uint32_t                         peakOrAccessiveInfoRate;        /**< KBits/Second or Packets/Second */
-    uint32_t                         peakOrAccessiveBurstSize;       /**< Bytes/Packets */
-} t_FmPcdPlcrNonPassthroughAlgParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining the next engine after policer
-*//***************************************************************************/
-typedef union u_FmPcdPlcrNextEngineParams {
-    e_FmPcdDoneAction               action;             /**< Action - when next engine is BMI (done) */
-    t_Handle                        h_Profile;          /**< Policer profile handle -  used when next engine
-                                                             is Policer, must be a SHARED profile */
-    t_Handle                        h_DirectScheme;     /**< Direct scheme select - when next engine is KeyGen */
-} u_FmPcdPlcrNextEngineParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining the policer profile entry
-*//***************************************************************************/
-typedef struct t_FmPcdPlcrProfileParams {
-    bool                                modify;                     /**< TRUE to change an existing profile */
-    union {
-        struct {
-            e_FmPcdProfileTypeSelection profileType;                /**< Type of policer profile */
-            t_Handle                    h_FmPort;                   /**< Relevant for per-port profiles only */
-            uint16_t                    relativeProfileId;          /**< Profile id - relative to shared group or to port */
-        } newParams;                                                /**< use it when modify = FALSE */
-        t_Handle                        h_Profile;                  /**< A handle to a profile - use it when modify=TRUE */
-    } id;
-    e_FmPcdPlcrAlgorithmSelection       algSelection;               /**< Profile Algorithm PASS_THROUGH, RFC_2698, RFC_4115 */
-    e_FmPcdPlcrColorMode                colorMode;                  /**< COLOR_BLIND, COLOR_AWARE */
-
-    union {
-        e_FmPcdPlcrColor                dfltColor;                  /**< For Color-Blind Pass-Through mode; the policer will re-color
-                                                                         any incoming packet with the default value. */
-        e_FmPcdPlcrColor                override;                   /**< For Color-Aware modes; the profile response to a
-                                                                         pre-color value of 2'b11. */
-    } color;
-
-    t_FmPcdPlcrNonPassthroughAlgParams  nonPassthroughAlgParams;    /**< RFC2698 or RFC4115 parameters */
-
-    e_FmPcdEngine                       nextEngineOnGreen;          /**< Next engine for green-colored frames */
-    u_FmPcdPlcrNextEngineParams         paramsOnGreen;              /**< Next engine parameters for green-colored frames  */
-
-    e_FmPcdEngine                       nextEngineOnYellow;         /**< Next engine for yellow-colored frames */
-    u_FmPcdPlcrNextEngineParams         paramsOnYellow;             /**< Next engine parameters for yellow-colored frames  */
-
-    e_FmPcdEngine                       nextEngineOnRed;            /**< Next engine for red-colored frames */
-    u_FmPcdPlcrNextEngineParams         paramsOnRed;                /**< Next engine parameters for red-colored frames  */
-
-    bool                                trapProfileOnFlowA;         /**< Obsolete - do not use */
-    bool                                trapProfileOnFlowB;         /**< Obsolete - do not use */
-    bool                                trapProfileOnFlowC;         /**< Obsolete - do not use */
-} t_FmPcdPlcrProfileParams;
-
-/**************************************************************************//**
- @Description   Parameters for selecting a location for requested manipulation
-*//***************************************************************************/
-typedef struct t_FmManipHdrInfo {
-    e_NetHeaderType                     hdr;            /**< Header selection */
-    e_FmPcdHdrIndex                     hdrIndex;       /**< Relevant only for MPLS, VLAN and tunneled IP. Otherwise should be cleared. */
-    bool                                byField;        /**< TRUE if the location of manipulation is according to some field in the specific header*/
-    t_FmPcdFields                       fullField;      /**< Relevant only when byField = TRUE: Extract field */
-} t_FmManipHdrInfo;
-
-#ifdef FM_CAPWAP_SUPPORT
-/**************************************************************************//**
- @Description   Parameters for defining an insertion manipulation
-                of type e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrInsrtByTemplateParams {
-    uint8_t         size;                               /**< Size of insert template to the start of the frame. */
-    uint8_t         hdrTemplate[FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE];
-                                                        /**< Array of the insertion template. */
-
-    bool            modifyOuterIp;                      /**< TRUE if user want to modify some fields in outer IP. */
-    struct {
-        uint16_t    ipOuterOffset;                      /**< Offset of outer IP in the insert template, relevant if modifyOuterIp = TRUE.*/
-        uint16_t    dscpEcn;                            /**< value of dscpEcn in IP outer, relevant if modifyOuterIp = TRUE.
-                                                             in IPV4 dscpEcn only byte - it has to be adjusted to the right*/
-        bool        udpPresent;                         /**< TRUE if UDP is present in the insert template, relevant if modifyOuterIp = TRUE.*/
-        uint8_t     udpOffset;                          /**< Offset in the insert template of UDP, relevant if modifyOuterIp = TRUE and udpPresent=TRUE.*/
-        uint8_t     ipIdentGenId;                       /**< Used by FMan-CTRL to calculate IP-identification field,relevant if modifyOuterIp = TRUE.*/
-        bool        recalculateLength;                  /**< TRUE if recalculate length has to be performed due to the engines in the path which can change the frame later, relevant if modifyOuterIp = TRUE.*/
-        struct {
-            uint8_t blockSize;                          /**< The CAAM block-size; Used by FMan-CTRL to calculate the IP Total Length field.*/
-            uint8_t extraBytesAddedAlignedToBlockSize;  /**< Used by FMan-CTRL to calculate the IP Total Length field and UDP length*/
-            uint8_t extraBytesAddedNotAlignedToBlockSize;/**< Used by FMan-CTRL to calculate the IP Total Length field and UDP length.*/
-        } recalculateLengthParams;                      /**< Recalculate length parameters - relevant if modifyOuterIp = TRUE and recalculateLength = TRUE */
-    } modifyOuterIpParams;                              /**< Outer IP modification parameters - ignored if modifyOuterIp is FALSE */
-
-    bool            modifyOuterVlan;                    /**< TRUE if user wants to modify VPri field in the outer VLAN header*/
-    struct {
-        uint8_t     vpri;                               /**< Value of VPri, relevant if modifyOuterVlan = TRUE
-                                                             VPri only 3 bits, it has to be adjusted to the right*/
-    } modifyOuterVlanParams;
-} t_FmPcdManipHdrInsrtByTemplateParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining CAPWAP fragmentation
-*//***************************************************************************/
-typedef struct t_CapwapFragmentationParams {
-    uint16_t         sizeForFragmentation;              /**< if length of the frame is greater than this value, CAPWAP fragmentation will be executed.*/
-    bool             headerOptionsCompr;                /**< TRUE - first fragment include the CAPWAP header options field,
-                                                             and all other fragments exclude the CAPWAP options field,
-                                                             FALSE - all fragments include CAPWAP header options field. */
-} t_CapwapFragmentationParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining CAPWAP reassembly
-*//***************************************************************************/
-typedef struct t_CapwapReassemblyParams {
-    uint16_t                        maxNumFramesInProcess;  /**< Number of frames which can be reassembled concurrently; must be power of 2.
-                                                                 In case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
-                                                                 maxNumFramesInProcess has to be in the range of 4 - 512,
-                                                                 In case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
-                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048 */
-    bool                            haltOnDuplicationFrag;  /**< If TRUE, reassembly process will be halted due to duplicated fragment,
-                                                                 and all processed fragments will be enqueued with error indication;
-                                                                 If FALSE, only duplicated fragments will be enqueued with error indication. */
-
-    e_FmPcdManipReassemTimeOutMode  timeOutMode;            /**< Expiration delay initialized by the reassembly process */
-    uint32_t                        fqidForTimeOutFrames;   /**< FQID in which time out frames will enqueue during Time Out Process  */
-    uint32_t                        timeoutRoutineRequestTime;
-                                                            /**< Represents the time interval in microseconds between consecutive
-                                                                 timeout routine requests It has to be power of 2. */
-    uint32_t                        timeoutThresholdForReassmProcess;
-                                                            /**< Time interval (microseconds) for marking frames in process as too old;
-                                                                 Frames in process are those for which at least one fragment was received
-                                                                 but not all fragments. */
-
-    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;/**< Number of frames per hash entry (needed for the reassembly process) */
-} t_CapwapReassemblyParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining fragmentation/reassembly manipulation
-*//***************************************************************************/
-typedef struct t_FmPcdManipFragOrReasmParams {
-    bool                                frag;               /**< TRUE if using the structure for fragmentation,
-                                                                 otherwise this structure is used for reassembly */
-    uint8_t                             sgBpid;             /**< Scatter/Gather buffer pool id;
-                                                                 Same LIODN number is used for these buffers as for
-                                                                 the received frames buffers, so buffers of this pool
-                                                                 need to be allocated in the same memory area as the
-                                                                 received buffers. If the received buffers arrive
-                                                                 from different sources, the Scatter/Gather BP id
-                                                                 should be mutual to all these sources. */
-    e_NetHeaderType                     hdr;                /**< Header selection */
-    union {
-        t_CapwapFragmentationParams     capwapFragParams;   /**< Structure for CAPWAP fragmentation,
-                                                                 relevant if 'frag' = TRUE, 'hdr' = HEADER_TYPE_CAPWAP */
-        t_CapwapReassemblyParams        capwapReasmParams;  /**< Structure for CAPWAP reassembly,
-                                                                 relevant if 'frag' = FALSE, 'hdr' = HEADER_TYPE_CAPWAP */
-    } u;
-} t_FmPcdManipFragOrReasmParams;
-
-#endif /* FM_CAPWAP_SUPPORT */
-
-/**************************************************************************//**
- @Description   Parameters for defining header removal by header type
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrRmvByHdrParams {
-    e_FmPcdManipHdrRmvByHdrType         type;           /**< Selection of header removal location */
-    union {
-#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
-        struct {
-            bool                        include;        /**< If FALSE, remove until the specified header (not including the header);
-                                                             If TRUE, remove also the specified header. */
-            t_FmManipHdrInfo            hdrInfo;
-        } fromStartByHdr;                               /**< Relevant when type = e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
-#endif /* FM_CAPWAP_SUPPORT */
-#if (DPAA_VERSION >= 11)
-        t_FmManipHdrInfo                hdrInfo;        /**< Relevant when type = e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
-#endif /* (DPAA_VERSION >= 11) */
-        e_FmPcdManipHdrRmvSpecificL2    specificL2;     /**< Relevant when type = e_FM_PCD_MANIP_BY_HDR_SPECIFIC_L2;
-                                                             Defines which L2 headers to remove. */
-    } u;
-} t_FmPcdManipHdrRmvByHdrParams;
-
-/**************************************************************************//**
- @Description   Parameters for configuring IP fragmentation manipulation
-
- Restrictions:
-     - IP Fragmentation output fragments must not be forwarded to application directly.
-     - Maximum number of fragments per frame is 16.
-     - Fragmentation of IP fragments is not supported.
-     - IPv4 packets containing header Option fields are fragmented by copying all option
-       fields to each fragment, regardless of the copy bit value.
-     - Transmit confirmation is not supported.
-     - Fragmentation after SEC can't handle S/G frames.
-     - Fragmentation nodes must be set as the last PCD action (i.e. the
-       corresponding CC node key must have next engine set to e_FM_PCD_DONE).
-     - Only BMan buffers shall be used for frames to be fragmented.
-     - IPF does not support VSP. Therefore, on the same port where we have IPF
-       we cannot support VSP.
-     - NOTE: The following comment is relevant only for FMAN v3 devices: IPF
-       does not support VSP. Therefore, on the same port where we have IPF we
-       cannot support VSP.
-*//***************************************************************************/
-typedef struct t_FmPcdManipFragIpParams {
-    uint16_t                    sizeForFragmentation;   /**< If length of the frame is greater than this value,
-                                                             IP fragmentation will be executed.*/
-#if (DPAA_VERSION == 10)
-    uint8_t                     scratchBpid;            /**< Absolute buffer pool id according to BM configuration.*/
-#endif /* (DPAA_VERSION == 10) */
-    bool                        sgBpidEn;               /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
-                                                             If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
-                                                             received frame's buffer. */
-    uint8_t                     sgBpid;                 /**< Scatter/Gather buffer pool id;
-                                                             This parameters is relevant when 'sgBpidEn=TRUE';
-                                                             Same LIODN number is used for these buffers as for the received frames buffers, so buffers
-                                                             of this pool need to be allocated in the same memory area as the received buffers.
-                                                             If the received buffers arrive from different sources, the Scatter/Gather BP id should be
-                                                             mutual to all these sources. */
-    e_FmPcdManipDontFragAction  dontFragAction;         /**< Don't Fragment Action - If an IP packet is larger
-                                                             than MTU and its DF bit is set, then this field will
-                                                             determine the action to be taken.*/
-} t_FmPcdManipFragIpParams;
-
-/**************************************************************************//**
- @Description   Parameters for configuring IP reassembly manipulation.
-
-                This is a common structure for both IPv4 and IPv6 reassembly
-                manipulation. For reassembly of both IPv4 and IPv6, make sure to
-                set the 'hdr' field in t_FmPcdManipReassemParams to HEADER_TYPE_IPv6.
-
- Restrictions:
-    - Application must define at least one scheme to catch the reassembled frames.
-    - Maximum number of fragments per frame is 16.
-    - Reassembly of IPv4 fragments containing Option fields is supported.
-
-*//***************************************************************************/
-typedef struct t_FmPcdManipReassemIpParams {
-    uint8_t                         relativeSchemeId[2];    /**< Partition relative scheme id:
-                                                                 relativeSchemeId[0] -  Relative scheme ID for IPV4 Reassembly manipulation;
-                                                                 relativeSchemeId[1] -  Relative scheme ID for IPV6 Reassembly manipulation;
-                                                                 NOTE: The following comment is relevant only for FMAN v2 devices:
-                                                                 Relative scheme ID for IPv4/IPv6 Reassembly manipulation must be smaller than
-                                                                 the user schemes id to ensure that the reassembly schemes will be first match;
-                                                                 Rest schemes, if defined, should have higher relative scheme ID. */
-#if (DPAA_VERSION >= 11)
-    uint32_t                        nonConsistentSpFqid;    /**< In case that other fragments of the frame corresponds to different storage
-                                                                 profile than the opening fragment (Non-Consistent-SP state)
-                                                                 then one of two possible scenarios occurs:
-                                                                 if 'nonConsistentSpFqid != 0', the reassembled frame will be enqueued to
-                                                                 this fqid, otherwise a 'Non Consistent SP' bit will be set in the FD[status].*/
-#else
-    uint8_t                         sgBpid;                 /**< Buffer pool id for the S/G frame created by the reassembly process */
-#endif /* (DPAA_VERSION >= 11) */
-    uint8_t                         dataMemId;              /**< Memory partition ID for the IPR's external tables structure */
-    uint16_t                        dataLiodnOffset;        /**< LIODN offset for access the IPR's external tables structure. */
-    uint16_t                        minFragSize[2];         /**< Minimum fragment size:
-                                                                 minFragSize[0] - for ipv4, minFragSize[1] - for ipv6 */
-    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry[2];
-                                                            /**< Number of frames per hash entry needed for reassembly process:
-                                                                 numOfFramesPerHashEntry[0] - for ipv4 (max value is e_FM_PCD_MANIP_EIGHT_WAYS_HASH);
-                                                                 numOfFramesPerHashEntry[1] - for ipv6 (max value is e_FM_PCD_MANIP_SIX_WAYS_HASH). */
-    uint16_t                        maxNumFramesInProcess;  /**< Number of frames which can be processed by Reassembly in the same time;
-                                                                 Must be power of 2;
-                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
-                                                                 maxNumFramesInProcess has to be in the range of 4 - 512;
-                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
-                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048. */
-    e_FmPcdManipReassemTimeOutMode  timeOutMode;            /**< Expiration delay initialized by Reassembly process */
-    uint32_t                        fqidForTimeOutFrames;   /**< FQID in which time out frames will enqueue during Time Out Process;
-                                                                 Recommended value for this field is 0; in this way timed-out frames will be discarded */
-    uint32_t                        timeoutThresholdForReassmProcess;
-                                                            /**< Represents the time interval in microseconds which defines
-                                                                 if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
-} t_FmPcdManipReassemIpParams;
-
-/**************************************************************************//**
- @Description   structure for defining IPSEC manipulation
-*//***************************************************************************/
-typedef struct t_FmPcdManipSpecialOffloadIPSecParams {
-    bool        decryption;                     /**< TRUE if being used in decryption direction;
-                                                     FALSE if being used in encryption direction. */
-    bool        ecnCopy;                        /**< TRUE to copy the ECN bits from inner/outer to outer/inner
-                                                     (direction depends on the 'decryption' field). */
-    bool        dscpCopy;                       /**< TRUE to copy the DSCP bits from inner/outer to outer/inner
-                                                     (direction depends on the 'decryption' field). */
-    bool        variableIpHdrLen;               /**< TRUE for supporting variable IP header length in decryption. */
-    bool        variableIpVersion;              /**< TRUE for supporting both IP version on the same SA in encryption */
-    uint8_t     outerIPHdrLen;                  /**< if 'variableIpVersion == TRUE' than this field must be set to non-zero value;
-                                                     It is specifies the length of the outer IP header that was configured in the
-                                                     corresponding SA. */
-} t_FmPcdManipSpecialOffloadIPSecParams;
-
-#if (DPAA_VERSION >= 11)
-/**************************************************************************//**
- @Description   Parameters for configuring CAPWAP fragmentation manipulation
-
- Restrictions:
-     - Maximum number of fragments per frame is 16.
-     - Transmit confirmation is not supported.
-     - Fragmentation nodes must be set as the last PCD action (i.e. the
-       corresponding CC node key must have next engine set to e_FM_PCD_DONE).
-     - Only BMan buffers shall be used for frames to be fragmented.
-     - NOTE: The following comment is relevant only for FMAN v3 devices: IPF
-       does not support VSP. Therefore, on the same port where we have IPF we
-       cannot support VSP.
-*//***************************************************************************/
-typedef struct t_FmPcdManipFragCapwapParams {
-    uint16_t                    sizeForFragmentation;   /**< If length of the frame is greater than this value,
-                                                             CAPWAP fragmentation will be executed.*/
-    bool                        sgBpidEn;               /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
-                                                             If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
-                                                             received frame's buffer. */
-    uint8_t                     sgBpid;                 /**< Scatter/Gather buffer pool id;
-                                                             This parameters is relevant when 'sgBpidEn=TRUE';
-                                                             Same LIODN number is used for these buffers as for the received frames buffers, so buffers
-                                                             of this pool need to be allocated in the same memory area as the received buffers.
-                                                             If the received buffers arrive from different sources, the Scatter/Gather BP id should be
-                                                             mutual to all these sources. */
-    bool                        compressModeEn;         /**< CAPWAP Header Options Compress Enable mode;
-                                                             When this mode is enabled then only the first fragment include the CAPWAP header options
-                                                             field (if user provides it in the input frame) and all other fragments exclude the CAPWAP
-                                                             options field (CAPWAP header is updated accordingly).*/
-} t_FmPcdManipFragCapwapParams;
-
-/**************************************************************************//**
- @Description   Parameters for configuring CAPWAP reassembly manipulation.
-
- Restrictions:
-    - Application must define one scheme to catch the reassembled frames.
-    - Maximum number of fragments per frame is 16.
-
-*//***************************************************************************/
-typedef struct t_FmPcdManipReassemCapwapParams {
-    uint8_t                         relativeSchemeId;    /**< Partition relative scheme id;
-                                                                 NOTE: this id must be smaller than the user schemes id to ensure that the reassembly scheme will be first match;
-                                                                 Rest schemes, if defined, should have higher relative scheme ID. */
-    uint8_t                         dataMemId;              /**< Memory partition ID for the IPR's external tables structure */
-    uint16_t                        dataLiodnOffset;        /**< LIODN offset for access the IPR's external tables structure. */
-    uint16_t                        maxReassembledFrameLength;/**< The maximum CAPWAP reassembled frame length in bytes;
-                                                                   If maxReassembledFrameLength == 0, any successful reassembled frame length is
-                                                                   considered as a valid length;
-                                                                   if maxReassembledFrameLength > 0, a successful reassembled frame which its length
-                                                                   exceeds this value is considered as an error frame (FD status[CRE] bit is set). */
-    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;
-                                                            /**< Number of frames per hash entry needed for reassembly process */
-    uint16_t                        maxNumFramesInProcess;  /**< Number of frames which can be processed by reassembly in the same time;
-                                                                 Must be power of 2;
-                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
-                                                                 maxNumFramesInProcess has to be in the range of 4 - 512;
-                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
-                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048. */
-    e_FmPcdManipReassemTimeOutMode  timeOutMode;            /**< Expiration delay initialized by Reassembly process */
-    uint32_t                        fqidForTimeOutFrames;   /**< FQID in which time out frames will enqueue during Time Out Process;
-                                                                 Recommended value for this field is 0; in this way timed-out frames will be discarded */
-    uint32_t                        timeoutThresholdForReassmProcess;
-                                                            /**< Represents the time interval in microseconds which defines
-                                                                 if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
-} t_FmPcdManipReassemCapwapParams;
-
-/**************************************************************************//**
- @Description   structure for defining CAPWAP manipulation
-*//***************************************************************************/
-typedef struct t_FmPcdManipSpecialOffloadCapwapParams {
-    bool                    dtls;   /**< TRUE if continue to SEC DTLS encryption */
-    e_FmPcdManipHdrQosSrc   qosSrc; /**< TODO */
-} t_FmPcdManipSpecialOffloadCapwapParams;
-
-#endif /* (DPAA_VERSION >= 11) */
-
-
-/**************************************************************************//**
- @Description   Parameters for defining special offload manipulation
-*//***************************************************************************/
-typedef struct t_FmPcdManipSpecialOffloadParams {
-    e_FmPcdManipSpecialOffloadType              type;       /**< Type of special offload manipulation */
-    union
-    {
-        t_FmPcdManipSpecialOffloadIPSecParams   ipsec;      /**< Parameters for IPSec; Relevant when
-                                                                 type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC */
-#if (DPAA_VERSION >= 11)
-        t_FmPcdManipSpecialOffloadCapwapParams  capwap;     /**< Parameters for CAPWAP; Relevant when
-                                                                 type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD_CAPWAP */
-#endif /* (DPAA_VERSION >= 11) */
-    } u;
-} t_FmPcdManipSpecialOffloadParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining insertion manipulation
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrInsrt {
-    uint8_t size;           /**< size of inserted section */
-    uint8_t *p_Data;        /**< data to be inserted */
-} t_FmPcdManipHdrInsrt;
-
-
-/**************************************************************************//**
- @Description   Parameters for defining generic removal manipulation
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrRmvGenericParams {
-    uint8_t                         offset;         /**< Offset from beginning of header to the start
-                                                         location of the removal */
-    uint8_t                         size;           /**< Size of removed section */
-} t_FmPcdManipHdrRmvGenericParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining generic insertion manipulation
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrInsrtGenericParams {
-    uint8_t                         offset;         /**< Offset from beginning of header to the start
-                                                         location of the insertion */
-    uint8_t                         size;           /**< Size of inserted section */
-    bool                            replace;        /**< TRUE to override (replace) existing data at
-                                                         'offset', FALSE to insert */
-    uint8_t                         *p_Data;        /**< Pointer to data to be inserted */
-} t_FmPcdManipHdrInsrtGenericParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining header manipulation VLAN DSCP To Vpri translation
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrFieldUpdateVlanDscpToVpri {
-    uint8_t                         dscpToVpriTable[FM_PCD_MANIP_DSCP_TO_VLAN_TRANS];
-                                                        /**< A table of VPri values for each DSCP value;
-                                                             The index is the DSCP value (0-0x3F) and the
-                                                             value is the corresponding VPRI (0-15). */
-    uint8_t                         vpriDefVal;         /**< 0-7, Relevant only if if updateType =
-                                                             e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN,
-                                                             this field is the Q Tag default value if the
-                                                             IP header is not found. */
-} t_FmPcdManipHdrFieldUpdateVlanDscpToVpri;
-
-/**************************************************************************//**
- @Description   Parameters for defining header manipulation VLAN fields updates
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrFieldUpdateVlan {
-    e_FmPcdManipHdrFieldUpdateVlan                  updateType; /**< Selects VLAN update type */
-    union {
-        uint8_t                                     vpri;       /**< 0-7, Relevant only if If updateType =
-                                                                     e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_PRI, this
-                                                                     is the new VLAN pri. */
-        t_FmPcdManipHdrFieldUpdateVlanDscpToVpri    dscpToVpri; /**< Parameters structure, Relevant only if updateType
-                                                                     = e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN. */
-    } u;
-} t_FmPcdManipHdrFieldUpdateVlan;
-
-/**************************************************************************//**
- @Description   Parameters for defining header manipulation IPV4 fields updates
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrFieldUpdateIpv4 {
-    ipv4HdrManipUpdateFlags_t       validUpdates;       /**< ORed flag, selecting the required updates */
-    uint8_t                         tos;                /**< 8 bit New TOS; Relevant if validUpdates contains
-                                                             HDR_MANIP_IPV4_TOS */
-    uint16_t                        id;                 /**< 16 bit New IP ID; Relevant only if validUpdates
-                                                             contains HDR_MANIP_IPV4_ID */
-    uint32_t                        src;                /**< 32 bit New IP SRC; Relevant only if validUpdates
-                                                             contains HDR_MANIP_IPV4_SRC */
-    uint32_t                        dst;                /**< 32 bit New IP DST; Relevant only if validUpdates
-                                                             contains HDR_MANIP_IPV4_DST */
-} t_FmPcdManipHdrFieldUpdateIpv4;
-
-/**************************************************************************//**
- @Description   Parameters for defining header manipulation IPV6 fields updates
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrFieldUpdateIpv6 {
-    ipv6HdrManipUpdateFlags_t   validUpdates;           /**< ORed flag, selecting the required updates */
-    uint8_t                     trafficClass;           /**< 8 bit New Traffic Class; Relevant if validUpdates contains
-                                                             HDR_MANIP_IPV6_TC */
-    uint8_t                     src[NET_HEADER_FIELD_IPv6_ADDR_SIZE];
-                                                        /**< 16 byte new IP SRC; Relevant only if validUpdates
-                                                             contains HDR_MANIP_IPV6_SRC */
-    uint8_t                     dst[NET_HEADER_FIELD_IPv6_ADDR_SIZE];
-                                                        /**< 16 byte new IP DST; Relevant only if validUpdates
-                                                             contains HDR_MANIP_IPV6_DST */
-} t_FmPcdManipHdrFieldUpdateIpv6;
-
-/**************************************************************************//**
- @Description   Parameters for defining header manipulation TCP/UDP fields updates
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrFieldUpdateTcpUdp {
-    tcpUdpHdrManipUpdateFlags_t     validUpdates;       /**< ORed flag, selecting the required updates */
-    uint16_t                        src;                /**< 16 bit New TCP/UDP SRC; Relevant only if validUpdates
-                                                             contains HDR_MANIP_TCP_UDP_SRC */
-    uint16_t                        dst;                /**< 16 bit New TCP/UDP DST; Relevant only if validUpdates
-                                                             contains HDR_MANIP_TCP_UDP_DST */
-} t_FmPcdManipHdrFieldUpdateTcpUdp;
-
-/**************************************************************************//**
- @Description   Parameters for defining header manipulation fields updates
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrFieldUpdateParams {
-    e_FmPcdManipHdrFieldUpdateType                  type;           /**< Type of header field update manipulation */
-    union {
-        t_FmPcdManipHdrFieldUpdateVlan              vlan;           /**< Parameters for VLAN update. Relevant when
-                                                                         type = e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN */
-        t_FmPcdManipHdrFieldUpdateIpv4              ipv4;           /**< Parameters for IPv4 update. Relevant when
-                                                                         type = e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4 */
-        t_FmPcdManipHdrFieldUpdateIpv6              ipv6;           /**< Parameters for IPv6 update. Relevant when
-                                                                         type = e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6 */
-        t_FmPcdManipHdrFieldUpdateTcpUdp            tcpUdp;         /**< Parameters for TCP/UDP update. Relevant when
-                                                                         type = e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP */
-    } u;
-} t_FmPcdManipHdrFieldUpdateParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining custom header manipulation for IP replacement
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrCustomIpHdrReplace {
-    e_FmPcdManipHdrCustomIpReplace  replaceType;        /**< Selects replace update type */
-    bool                            decTtlHl;           /**< Decrement TTL (IPV4) or Hop limit (IPV6) by 1  */
-    bool                            updateIpv4Id;       /**< Relevant when replaceType =
-                                                             e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4 */
-    uint16_t                        id;                 /**< 16 bit New IP ID; Relevant only if
-                                                             updateIpv4Id = TRUE */
-    uint8_t                         hdrSize;            /**< The size of the new IP header */
-    uint8_t                         hdr[FM_PCD_MANIP_MAX_HDR_SIZE];
-                                                        /**< The new IP header */
-} t_FmPcdManipHdrCustomIpHdrReplace;
-
-/**************************************************************************//**
- @Description   Parameters for defining custom header manipulation
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrCustomParams {
-    e_FmPcdManipHdrCustomType               type;           /**< Type of header field update manipulation */
-    union {
-        t_FmPcdManipHdrCustomIpHdrReplace   ipHdrReplace;   /**< Parameters IP header replacement */
-    } u;
-} t_FmPcdManipHdrCustomParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining specific L2 insertion manipulation
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrInsrtSpecificL2Params {
-    e_FmPcdManipHdrInsrtSpecificL2  specificL2;     /**< Selects which L2 headers to insert */
-    bool                            update;         /**< TRUE to update MPLS header */
-    uint8_t                         size;           /**< size of inserted section */
-    uint8_t                         *p_Data;        /**< data to be inserted */
-} t_FmPcdManipHdrInsrtSpecificL2Params;
-
-#if (DPAA_VERSION >= 11)
-/**************************************************************************//**
- @Description   Parameters for defining IP insertion manipulation
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrInsrtIpParams {
-    bool    calcL4Checksum; /**< Calculate L4 checksum. */
-    e_FmPcdManipHdrQosMappingMode   mappingMode; /**< TODO */
-    uint8_t lastPidOffset;     /**< the offset of the last Protocol within
-                                 the inserted header */
-    uint16_t  id;           /**< 16 bit New IP ID */
-    t_FmPcdManipHdrInsrt insrt; /**< size and data to be inserted. */
-} t_FmPcdManipHdrInsrtIpParams;
-#endif /* (DPAA_VERSION >= 11) */
-
-/**************************************************************************//**
- @Description   Parameters for defining header insertion manipulation by header type
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrInsrtByHdrParams {
-    e_FmPcdManipHdrInsrtByHdrType               type;   /**< Selects manipulation type */
-    union {
-
-        t_FmPcdManipHdrInsrtSpecificL2Params    specificL2Params;
-                                                             /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2:
-                                                              Selects which L2 headers to insert */
-#if (DPAA_VERSION >= 11)
-        t_FmPcdManipHdrInsrtIpParams             ipParams;  /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_IP */
-        t_FmPcdManipHdrInsrt                    insrt;     /**< Used when type is one of e_FM_PCD_MANIP_INSRT_BY_HDR_UDP,
-                                                                e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE, or
-                                                                e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP */
-#endif /* (DPAA_VERSION >= 11) */
-    } u;
-} t_FmPcdManipHdrInsrtByHdrParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining header insertion manipulation
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrInsrtParams {
-    e_FmPcdManipHdrInsrtType                    type;       /**< Type of insertion manipulation */
-    union {
-        t_FmPcdManipHdrInsrtByHdrParams         byHdr;      /**< Parameters for defining header insertion manipulation by header type,
-                                                                 relevant if 'type' = e_FM_PCD_MANIP_INSRT_BY_HDR */
-        t_FmPcdManipHdrInsrtGenericParams       generic;    /**< Parameters for defining generic header insertion manipulation,
-                                                                 relevant if 'type' = e_FM_PCD_MANIP_INSRT_GENERIC */
-#ifdef FM_CAPWAP_SUPPORT
-        t_FmPcdManipHdrInsrtByTemplateParams    byTemplate; /**< Parameters for defining header insertion manipulation by template,
-                                                                 relevant if 'type' = e_FM_PCD_MANIP_INSRT_BY_TEMPLATE */
-#endif /* FM_CAPWAP_SUPPORT */
-    } u;
-} t_FmPcdManipHdrInsrtParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining header removal manipulation
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrRmvParams {
-    e_FmPcdManipHdrRmvType                  type;       /**< Type of header removal manipulation */
-    union {
-        t_FmPcdManipHdrRmvByHdrParams       byHdr;      /**< Parameters for defining header removal manipulation by header type,
-                                                             relevant if type = e_FM_PCD_MANIP_RMV_BY_HDR */
-        t_FmPcdManipHdrRmvGenericParams     generic;    /**< Parameters for defining generic header removal manipulation,
-                                                             relevant if type = e_FM_PCD_MANIP_RMV_GENERIC */
-    } u;
-} t_FmPcdManipHdrRmvParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining header manipulation node
-*//***************************************************************************/
-typedef struct t_FmPcdManipHdrParams {
-    bool                                        rmv;                /**< TRUE, to define removal manipulation */
-    t_FmPcdManipHdrRmvParams                    rmvParams;          /**< Parameters for removal manipulation, relevant if 'rmv' = TRUE */
-
-    bool                                        insrt;              /**< TRUE, to define insertion manipulation */
-    t_FmPcdManipHdrInsrtParams                  insrtParams;        /**< Parameters for insertion manipulation, relevant if 'insrt' = TRUE */
-
-    bool                                        fieldUpdate;        /**< TRUE, to define field update manipulation */
-    t_FmPcdManipHdrFieldUpdateParams            fieldUpdateParams;  /**< Parameters for field update manipulation, relevant if 'fieldUpdate' = TRUE */
-
-    bool                                        custom;             /**< TRUE, to define custom manipulation */
-    t_FmPcdManipHdrCustomParams                 customParams;       /**< Parameters for custom manipulation, relevant if 'custom' = TRUE */
-
-    bool                                        dontParseAfterManip;/**< FALSE to activate the parser a second time after
-                                                                         completing the manipulation on the frame */
-} t_FmPcdManipHdrParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining fragmentation manipulation
-*//***************************************************************************/
-typedef struct t_FmPcdManipFragParams {
-    e_NetHeaderType                     hdr;          /**< Header selection */
-    union {
-#if (DPAA_VERSION >= 11)
-        t_FmPcdManipFragCapwapParams    capwapFrag;   /**< Parameters for defining CAPWAP fragmentation,
-                                                           relevant if 'hdr' = HEADER_TYPE_CAPWAP */
-#endif /* (DPAA_VERSION >= 11) */
-        t_FmPcdManipFragIpParams        ipFrag;       /**< Parameters for defining IP fragmentation,
-                                                           relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
-    } u;
-} t_FmPcdManipFragParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining reassembly manipulation
-*//***************************************************************************/
-typedef struct t_FmPcdManipReassemParams {
-    e_NetHeaderType                     hdr;          /**< Header selection */
-    union {
-#if (DPAA_VERSION >= 11)
-        t_FmPcdManipReassemCapwapParams capwapReassem;  /**< Parameters for defining CAPWAP reassembly,
-                                                           relevant if 'hdr' = HEADER_TYPE_CAPWAP */
-#endif /* (DPAA_VERSION >= 11) */
-
-        t_FmPcdManipReassemIpParams     ipReassem;    /**< Parameters for defining IP reassembly,
-                                                           relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
-    } u;
-} t_FmPcdManipReassemParams;
-
-/**************************************************************************//**
- @Description   Parameters for defining a manipulation node
-*//***************************************************************************/
-typedef struct t_FmPcdManipParams {
-    e_FmPcdManipType                        type;               /**< Selects type of manipulation node */
-    union{
-        t_FmPcdManipHdrParams               hdr;                /**< Parameters for defining header manipulation node */
-        t_FmPcdManipReassemParams           reassem;            /**< Parameters for defining reassembly manipulation node */
-        t_FmPcdManipFragParams              frag;               /**< Parameters for defining fragmentation manipulation node */
-        t_FmPcdManipSpecialOffloadParams    specialOffload;     /**< Parameters for defining special offload manipulation node */
-    } u;
-
-    t_Handle                                h_NextManip;        /**< Supported for Header Manipulation only;
-                                                                     Handle to another (previously defined) manipulation node;
-                                                                     Allows concatenation of manipulation actions;
-                                                                     This parameter is optional and may be NULL. */
-#ifdef FM_CAPWAP_SUPPORT
-    bool                                    fragOrReasm;        /**< TRUE, if defined fragmentation/reassembly manipulation */
-    t_FmPcdManipFragOrReasmParams           fragOrReasmParams;  /**< Parameters for fragmentation/reassembly manipulation,
-                                                                     relevant if fragOrReasm = TRUE */
-#endif /* FM_CAPWAP_SUPPORT */
-} t_FmPcdManipParams;
-
-/**************************************************************************//**
- @Description   Structure for retrieving IP reassembly statistics
-*//***************************************************************************/
-typedef struct t_FmPcdManipReassemIpStats {
-    /* common counters for both IPv4 and IPv6 */
-    uint32_t        timeout;                    /**< Counts the number of timeout occurrences */
-    uint32_t        rfdPoolBusy;                /**< Counts the number of failed attempts to allocate
-                                                     a Reassembly Frame Descriptor */
-    uint32_t        internalBufferBusy;         /**< Counts the number of times an internal buffer busy occurred */
-    uint32_t        externalBufferBusy;         /**< Counts the number of times external buffer busy occurred */
-    uint32_t        sgFragments;                /**< Counts the number of Scatter/Gather fragments */
-    uint32_t        dmaSemaphoreDepletion;      /**< Counts the number of failed attempts to allocate a DMA semaphore */
-#if (DPAA_VERSION >= 11)
-    uint32_t        nonConsistentSp;            /**< Counts the number of Non Consistent Storage Profile events for
-                                                     successfully reassembled frames */
-#endif /* (DPAA_VERSION >= 11) */
-    struct {
-        uint32_t    successfullyReassembled;    /**< Counts the number of successfully reassembled frames */
-        uint32_t    validFragments;             /**< Counts the total number of valid fragments that
-                                                     have been processed for all frames */
-        uint32_t    processedFragments;         /**< Counts the number of processed fragments
-                                                     (valid and error fragments) for all frames */
-        uint32_t    malformedFragments;         /**< Counts the number of malformed fragments processed for all frames */
-        uint32_t    discardedFragments;         /**< Counts the number of fragments discarded by the reassembly process */
-        uint32_t    autoLearnBusy;              /**< Counts the number of times a busy condition occurs when attempting
-                                                     to access an IP-Reassembly Automatic Learning Hash set */
-        uint32_t    moreThan16Fragments;        /**< Counts the fragment occurrences in which the number of fragments-per-frame
-                                                     exceeds 16 */
-    } specificHdrStatistics[2];                 /**< slot '0' is for IPv4, slot '1' is for IPv6 */
-} t_FmPcdManipReassemIpStats;
-
-/**************************************************************************//**
- @Description   Structure for retrieving IP fragmentation statistics
-*//***************************************************************************/
-typedef struct t_FmPcdManipFragIpStats {
-    uint32_t    totalFrames;            /**< Number of frames that passed through the manipulation node */
-    uint32_t    fragmentedFrames;       /**< Number of frames that were fragmented */
-    uint32_t    generatedFragments;     /**< Number of fragments that were generated */
-} t_FmPcdManipFragIpStats;
-
-#if (DPAA_VERSION >= 11)
-/**************************************************************************//**
- @Description   Structure for retrieving CAPWAP reassembly statistics
-*//***************************************************************************/
-typedef struct t_FmPcdManipReassemCapwapStats {
-    uint32_t    timeout;                    /**< Counts the number of timeout occurrences */
-    uint32_t    rfdPoolBusy;                /**< Counts the number of failed attempts to allocate
-                                                 a Reassembly Frame Descriptor */
-    uint32_t    internalBufferBusy;         /**< Counts the number of times an internal buffer busy occurred */
-    uint32_t    externalBufferBusy;         /**< Counts the number of times external buffer busy occurred */
-    uint32_t    sgFragments;                /**< Counts the number of Scatter/Gather fragments */
-    uint32_t    dmaSemaphoreDepletion;      /**< Counts the number of failed attempts to allocate a DMA semaphore */
-    uint32_t    successfullyReassembled;    /**< Counts the number of successfully reassembled frames */
-    uint32_t    validFragments;             /**< Counts the total number of valid fragments that
-                                                 have been processed for all frames */
-    uint32_t    processedFragments;         /**< Counts the number of processed fragments
-                                                 (valid and error fragments) for all frames */
-    uint32_t    malformedFragments;         /**< Counts the number of malformed fragments processed for all frames */
-    uint32_t    autoLearnBusy;              /**< Counts the number of times a busy condition occurs when attempting
-                                                 to access an Reassembly Automatic Learning Hash set */
-    uint32_t    discardedFragments;         /**< Counts the number of fragments discarded by the reassembly process */
-    uint32_t    moreThan16Fragments;        /**< Counts the fragment occurrences in which the number of fragments-per-frame
-                                                 exceeds 16 */
-    uint32_t    exceedMaxReassemblyFrameLen;/**< ounts the number of times that a successful reassembled frame
-                                                 length exceeds MaxReassembledFrameLength value */
-} t_FmPcdManipReassemCapwapStats;
-
-/**************************************************************************//**
- @Description   Structure for retrieving CAPWAP fragmentation statistics
-*//***************************************************************************/
-typedef struct t_FmPcdManipFragCapwapStats {
-    uint32_t    totalFrames;            /**< Number of frames that passed through the manipulation node */
-    uint32_t    fragmentedFrames;       /**< Number of frames that were fragmented */
-    uint32_t    generatedFragments;     /**< Number of fragments that were generated */
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-    uint8_t     sgAllocationFailure;    /**< Number of allocation failure of s/g buffers */
-#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
-} t_FmPcdManipFragCapwapStats;
-#endif /* (DPAA_VERSION >= 11) */
-
-/**************************************************************************//**
- @Description   Structure for retrieving reassembly statistics
-*//***************************************************************************/
-typedef struct t_FmPcdManipReassemStats {
-    union {
-        t_FmPcdManipReassemIpStats  ipReassem;  /**< Structure for IP reassembly statistics */
-#if (DPAA_VERSION >= 11)
-        t_FmPcdManipReassemCapwapStats  capwapReassem;  /**< Structure for CAPWAP reassembly statistics */
-#endif /* (DPAA_VERSION >= 11) */
-    } u;
-} t_FmPcdManipReassemStats;
-
-/**************************************************************************//**
- @Description   Structure for retrieving fragmentation statistics
-*//***************************************************************************/
-typedef struct t_FmPcdManipFragStats {
-    union {
-        t_FmPcdManipFragIpStats     ipFrag;     /**< Structure for IP fragmentation statistics */
-#if (DPAA_VERSION >= 11)
-        t_FmPcdManipFragCapwapStats capwapFrag; /**< Structure for CAPWAP fragmentation statistics */
-#endif /* (DPAA_VERSION >= 11) */
-    } u;
-} t_FmPcdManipFragStats;
-
-/**************************************************************************//**
- @Description   Structure for selecting manipulation statistics
-*//***************************************************************************/
-typedef struct t_FmPcdManipStats {
-    union {
-        t_FmPcdManipReassemStats    reassem;    /**< Structure for reassembly statistics */
-        t_FmPcdManipFragStats       frag;       /**< Structure for fragmentation statistics */
-    } u;
-} t_FmPcdManipStats;
-
-#if (DPAA_VERSION >= 11)
-/**************************************************************************//**
- @Description   Parameters for defining frame replicator group and its members
-*//***************************************************************************/
-typedef struct t_FmPcdFrmReplicGroupParams {
-    uint8_t                     maxNumOfEntries;    /**< Maximal number of members in the group;
-                                                         Must be at least 2. */
-    uint8_t                     numOfEntries;       /**< Number of members in the group;
-                                                         Must be at least 1. */
-    t_FmPcdCcNextEngineParams   nextEngineParams[FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES];
-                                                    /**< Array of members' parameters */
-} t_FmPcdFrmReplicGroupParams;
-#endif /* (DPAA_VERSION >= 11) */
-
-#ifdef FM_CAPWAP_SUPPORT
-/**************************************************************************//**
- @Description   structure for defining statistics node
-*//***************************************************************************/
-typedef struct t_FmPcdStatsParams {
-    e_FmPcdStatsType    type;   /**< type of statistics node */
-} t_FmPcdStatsParams;
-#endif /* FM_CAPWAP_SUPPORT */
-
-
-/**************************************************************************//**
- @Function      FM_PCD_NetEnvCharacteristicsSet
-
- @Description   Define a set of Network Environment Characteristics.
-
-                When setting an environment it is important to understand its
-                application. It is not meant to describe the flows that will run
-                on the ports using this environment, but what the user means TO DO
-                with the PCD mechanisms in order to parse-classify-distribute those
-                frames.
-                By specifying a distinction unit, the user means it would use that option
-                for distinction between frames at either a KeyGen scheme or a coarse
-                classification action descriptor. Using interchangeable headers to define a
-                unit means that the user is indifferent to which of the interchangeable
-                headers is present in the frame, and wants the distinction to be based
-                on the presence of either one of them.
-
-                Depending on context, there are limitations to the use of environments. A
-                port using the PCD functionality is bound to an environment. Some or even
-                all ports may share an environment but also an environment per port is
-                possible. When initializing a scheme, a classification plan group (see below),
-                or a coarse classification tree, one of the initialized environments must be
-                stated and related to. When a port is bound to a scheme, a classification
-                plan group, or a coarse classification tree, it MUST be bound to the same
-                environment.
-
-                The different PCD modules, may relate (for flows definition) ONLY on
-                distinction units as defined by their environment. When initializing a
-                scheme for example, it may not choose to select IPV4 as a match for
-                recognizing flows unless it was defined in the relating environment. In
-                fact, to guide the user through the configuration of the PCD, each module's
-                characterization in terms of flows is not done using protocol names, but using
-                environment indexes.
-
-                In terms of HW implementation, the list of distinction units sets the LCV vectors
-                and later used for match vector, classification plan vectors and coarse classification
-                indexing.
-
- @Param[in]     h_FmPcd         FM PCD module descriptor.
- @Param[in]     p_NetEnvParams  A structure of parameters for the initialization of
-                                the network environment.
-
- @Return        A handle to the initialized object on success; NULL code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams *p_NetEnvParams);
-
-/**************************************************************************//**
- @Function      FM_PCD_NetEnvCharacteristicsDelete
-
- @Description   Deletes a set of Network Environment Characteristics.
-
- @Param[in]     h_NetEnv        A handle to the Network environment.
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error FM_PCD_NetEnvCharacteristicsDelete(t_Handle h_NetEnv);
-
-/**************************************************************************//**
- @Function      FM_PCD_KgSchemeSet
-
- @Description   Initializing or modifying and enabling a scheme for the KeyGen.
-                This routine should be called for adding or modifying a scheme.
-                When a scheme needs modifying, the API requires that it will be
-                rewritten. In such a case 'modify' should be TRUE. If the
-                routine is called for a valid scheme and 'modify' is FALSE,
-                it will return error.
-
- @Param[in]     h_FmPcd         If this is a new scheme - A handle to an FM PCD Module.
-                                Otherwise NULL (ignored by driver).
- @Param[in,out] p_SchemeParams  A structure of parameters for defining the scheme
-
- @Return        A handle to the initialized scheme on success; NULL code otherwise.
-                When used as "modify" (rather than for setting a new scheme),
-                p_SchemeParams->id.h_Scheme will return NULL if action fails due to scheme
-                BUSY state.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-t_Handle FM_PCD_KgSchemeSet(t_Handle                h_FmPcd,
-                            t_FmPcdKgSchemeParams   *p_SchemeParams);
-
-/**************************************************************************//**
- @Function      FM_PCD_KgSchemeDelete
-
- @Description   Deleting an initialized scheme.
-
- @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSchemeSet()
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init() & FM_PCD_KgSchemeSet().
-*//***************************************************************************/
-t_Error     FM_PCD_KgSchemeDelete(t_Handle h_Scheme);
-
-/**************************************************************************//**
- @Function      FM_PCD_KgSchemeGetCounter
-
- @Description   Reads scheme packet counter.
-
- @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSchemeSet().
-
- @Return        Counter's current value.
-
- @Cautions      Allowed only following FM_PCD_Init() & FM_PCD_KgSchemeSet().
-*//***************************************************************************/
-uint32_t  FM_PCD_KgSchemeGetCounter(t_Handle h_Scheme);
-
-/**************************************************************************//**
- @Function      FM_PCD_KgSchemeSetCounter
-
- @Description   Writes scheme packet counter.
-
- @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSchemeSet().
- @Param[in]     value           New scheme counter value - typically '0' for
-                                resetting the counter.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init() & FM_PCD_KgSchemeSet().
-*//***************************************************************************/
-t_Error  FM_PCD_KgSchemeSetCounter(t_Handle h_Scheme, uint32_t value);
-
-/**************************************************************************//**
- @Function      FM_PCD_PlcrProfileSet
-
- @Description   Sets a profile entry in the policer profile table.
-                The routine overrides any existing value.
-
- @Param[in]     h_FmPcd           A handle to an FM PCD Module.
- @Param[in]     p_Profile         A structure of parameters for defining a
-                                  policer profile entry.
-
- @Return        A handle to the initialized object on success; NULL code otherwise.
-                When used as "modify" (rather than for setting a new profile),
-                p_Profile->id.h_Profile will return NULL if action fails due to profile
-                BUSY state.
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-t_Handle FM_PCD_PlcrProfileSet(t_Handle                  h_FmPcd,
-                               t_FmPcdPlcrProfileParams  *p_Profile);
-
-/**************************************************************************//**
- @Function      FM_PCD_PlcrProfileDelete
-
- @Description   Delete a profile entry in the policer profile table.
-                The routine set entry to invalid.
-
- @Param[in]     h_Profile       A handle to the profile.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-t_Error FM_PCD_PlcrProfileDelete(t_Handle h_Profile);
-
-/**************************************************************************//**
- @Function      FM_PCD_PlcrProfileGetCounter
-
- @Description   Sets an entry in the classification plan.
-                The routine overrides any existing value.
-
- @Param[in]     h_Profile       A handle to the profile.
- @Param[in]     counter         Counter selector.
-
- @Return        specific counter value.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-uint32_t FM_PCD_PlcrProfileGetCounter(t_Handle                      h_Profile,
-                                      e_FmPcdPlcrProfileCounters    counter);
-
-/**************************************************************************//**
- @Function      FM_PCD_PlcrProfileSetCounter
-
- @Description   Sets an entry in the classification plan.
-                The routine overrides any existing value.
-
- @Param[in]     h_Profile       A handle to the profile.
- @Param[in]     counter         Counter selector.
- @Param[in]     value           value to set counter with.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-t_Error FM_PCD_PlcrProfileSetCounter(t_Handle                   h_Profile,
-                                     e_FmPcdPlcrProfileCounters counter,
-                                     uint32_t                   value);
-
-/**************************************************************************//**
- @Function      FM_PCD_CcRootBuild
-
- @Description   This routine must be called to define a complete coarse
-                classification tree. This is the way to define coarse
-                classification to a certain flow - the KeyGen schemes
-                may point only to trees defined in this way.
-
- @Param[in]     h_FmPcd         FM PCD module descriptor.
- @Param[in]     p_Params        A structure of parameters to define the tree.
-
- @Return        A handle to the initialized object on success; NULL code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-t_Handle FM_PCD_CcRootBuild (t_Handle             h_FmPcd,
-                             t_FmPcdCcTreeParams  *p_Params);
-
-/**************************************************************************//**
- @Function      FM_PCD_CcRootDelete
-
- @Description   Deleting an built tree.
-
- @Param[in]     h_CcTree        A handle to a CC tree.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree);
-
-/**************************************************************************//**
- @Function      FM_PCD_CcRootModifyNextEngine
-
- @Description   Modify the Next Engine Parameters in the entry of the tree.
-
- @Param[in]     h_CcTree                    A handle to the tree
- @Param[in]     grpId                       A Group index in the tree
- @Param[in]     index                       Entry index in the group defined by grpId
- @Param[in]     p_FmPcdCcNextEngineParams   Pointer to new next engine parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_CcBuildTree().
-*//***************************************************************************/
-t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
-                                      uint8_t                   grpId,
-                                      uint8_t                   index,
-                                      t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableSet
-
- @Description   This routine should be called for each CC (coarse classification)
-                node. The whole CC tree should be built bottom up so that each
-                node points to already defined nodes.
-
- @Param[in]     h_FmPcd         FM PCD module descriptor.
- @Param[in]     p_Param         A structure of parameters defining the CC node
-
- @Return        A handle to the initialized object on success; NULL code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-t_Handle   FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_Param);
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableDelete
-
- @Description   Deleting an built node.
-
- @Param[in]     h_CcNode        A handle to a CC node.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode);
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableModifyMissNextEngine
-
- @Description   Modify the Next Engine Parameters of the Miss key case of the node.
-
- @Param[in]     h_CcNode                    A handle to the node
- @Param[in]     p_FmPcdCcNextEngineParams   Parameters for defining next engine
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_MatchTableSet();
-                Not relevant in the case the node is of type 'INDEXED_LOOKUP'.
-                When configuring nextEngine = e_FM_PCD_CC, note that
-                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
-                from the currently changed table.
-
-*//***************************************************************************/
-t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle                  h_CcNode,
-                                              t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableRemoveKey
-
- @Description   Remove the key (including next engine parameters of this key)
-                defined by the index of the relevant node.
-
- @Param[in]     h_CcNode                    A handle to the node
- @Param[in]     keyIndex                    Key index for removing
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
-                node and the nodes that lead to it.
-*//***************************************************************************/
-t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex);
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableAddKey
-
- @Description   Add the key (including next engine parameters of this key in the
-                index defined by the keyIndex. Note that 'FM_PCD_LAST_KEY_INDEX'
-                may be used by user that don't care about the position of the
-                key in the table - in that case, the key will be automatically
-                added by the driver in the last available entry.
-
- @Param[in]     h_CcNode     A handle to the node
- @Param[in]     keyIndex     Key index for adding.
- @Param[in]     keySize      Key size of added key
- @Param[in]     p_KeyParams  A pointer to the parameters includes
-                             new key with Next Engine Parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
-                node and the nodes that lead to it.
-*//***************************************************************************/
-t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
-                                uint16_t            keyIndex,
-                                uint8_t             keySize,
-                                t_FmPcdCcKeyParams  *p_KeyParams);
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableModifyNextEngine
-
- @Description   Modify the Next Engine Parameters in the relevant key entry of the node.
-
- @Param[in]     h_CcNode                    A handle to the node
- @Param[in]     keyIndex                    Key index for Next Engine modifications
- @Param[in]     p_FmPcdCcNextEngineParams   Parameters for defining next engine
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_MatchTableSet().
-                When configuring nextEngine = e_FM_PCD_CC, note that
-                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
-                from the currently changed table.
-
-*//***************************************************************************/
-t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle                  h_CcNode,
-                                          uint16_t                  keyIndex,
-                                          t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableModifyKeyAndNextEngine
-
- @Description   Modify the key and Next Engine Parameters of this key in the
-                index defined by the keyIndex.
-
- @Param[in]     h_CcNode                    A handle to the node
- @Param[in]     keyIndex                    Key index for adding
- @Param[in]     keySize                     Key size of added key
- @Param[in]     p_KeyParams                 A pointer to the parameters includes
-                                            modified key and modified Next Engine Parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
-                node and the nodes that lead to it.
-                When configuring nextEngine = e_FM_PCD_CC, note that
-                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
-                from the currently changed table.
-*//***************************************************************************/
-t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle            h_CcNode,
-                                                uint16_t            keyIndex,
-                                                uint8_t             keySize,
-                                                t_FmPcdCcKeyParams  *p_KeyParams);
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableModifyKey
-
- @Description   Modify the key in the index defined by the keyIndex.
-
- @Param[in]     h_CcNode                    A handle to the node
- @Param[in]     keyIndex                    Key index for adding
- @Param[in]     keySize                     Key size of added key
- @Param[in]     p_Key                       A pointer to the new key
- @Param[in]     p_Mask                      A pointer to the new mask if relevant,
-                                            otherwise pointer to NULL
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
-                node and the nodes that lead to it.
-*//***************************************************************************/
-t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
-                                   uint16_t keyIndex,
-                                   uint8_t  keySize,
-                                   uint8_t  *p_Key,
-                                   uint8_t  *p_Mask);
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableFindNRemoveKey
-
- @Description   Remove the key (including next engine parameters of this key)
-                defined by the key and mask. Note that this routine will search
-                the node to locate the index of the required key (& mask) to remove.
-
- @Param[in]     h_CcNode                    A handle to the node
- @Param[in]     keySize                     Key size of the one to remove.
- @Param[in]     p_Key                       A pointer to the requested key to remove.
- @Param[in]     p_Mask                      A pointer to the mask if relevant,
-                                            otherwise pointer to NULL
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
-                node and the nodes that lead to it.
-*//***************************************************************************/
-t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
-                                        uint8_t  keySize,
-                                        uint8_t  *p_Key,
-                                        uint8_t  *p_Mask);
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableFindNModifyNextEngine
-
- @Description   Modify the Next Engine Parameters in the relevant key entry of
-                the node. Note that this routine will search the node to locate
-                the index of the required key (& mask) to modify.
-
- @Param[in]     h_CcNode                    A handle to the node
- @Param[in]     keySize                     Key size of the one to modify.
- @Param[in]     p_Key                       A pointer to the requested key to modify.
- @Param[in]     p_Mask                      A pointer to the mask if relevant,
-                                            otherwise pointer to NULL
- @Param[in]     p_FmPcdCcNextEngineParams   Parameters for defining next engine
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_MatchTableSet().
-                When configuring nextEngine = e_FM_PCD_CC, note that
-                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
-                from the currently changed table.
-*//***************************************************************************/
-t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNode,
-                                               uint8_t                   keySize,
-                                               uint8_t                   *p_Key,
-                                               uint8_t                   *p_Mask,
-                                               t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableFindNModifyKeyAndNextEngine
-
- @Description   Modify the key and Next Engine Parameters of this key in the
-                index defined by the keyIndex. Note that this routine will search
-                the node to locate the index of the required key (& mask) to modify.
-
- @Param[in]     h_CcNode                    A handle to the node
- @Param[in]     keySize                     Key size of the one to modify.
- @Param[in]     p_Key                       A pointer to the requested key to modify.
- @Param[in]     p_Mask                      A pointer to the mask if relevant,
-                                            otherwise pointer to NULL
- @Param[in]     p_KeyParams                 A pointer to the parameters includes
-                                            modified key and modified Next Engine Parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
-                node and the nodes that lead to it.
-                When configuring nextEngine = e_FM_PCD_CC, note that
-                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
-                from the currently changed table.
-*//***************************************************************************/
-t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNode,
-                                                     uint8_t             keySize,
-                                                     uint8_t             *p_Key,
-                                                     uint8_t             *p_Mask,
-                                                     t_FmPcdCcKeyParams  *p_KeyParams);
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableFindNModifyKey
-
- @Description   Modify the key  in the index defined by the keyIndex. Note that
-                this routine will search the node to locate the index of the
-                required key (& mask) to modify.
-
- @Param[in]     h_CcNode                    A handle to the node
- @Param[in]     keySize                     Key size of the one to modify.
- @Param[in]     p_Key                       A pointer to the requested key to modify.
- @Param[in]     p_Mask                      A pointer to the mask if relevant,
-                                            otherwise pointer to NULL
- @Param[in]     p_NewKey                    A pointer to the new key
- @Param[in]     p_NewMask                   A pointer to the new mask if relevant,
-                                            otherwise pointer to NULL
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
-                node and the nodes that lead to it.
-*//***************************************************************************/
-t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
-                                        uint8_t  keySize,
-                                        uint8_t  *p_Key,
-                                        uint8_t  *p_Mask,
-                                        uint8_t  *p_NewKey,
-                                        uint8_t  *p_NewMask);
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableGetKeyCounter
-
- @Description   This routine may be used to get a counter of specific key in a CC
-                Node; This counter reflects how many frames passed that were matched
-                this key.
-
- @Param[in]     h_CcNode        A handle to the node
- @Param[in]     keyIndex        Key index for adding
-
- @Return        The specific key counter.
-
- @Cautions      Allowed only following FM_PCD_MatchTableSet().
-*//***************************************************************************/
-uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex);
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableGetKeyStatistics
-
- @Description   This routine may be used to get statistics counters of specific key
-                in a CC Node.
-
-                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
-                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
-                these counters reflect how many frames passed that were matched
-                this key; The total frames count will be returned in the counter
-                of the first range (as only one frame length range was defined).
-                If 'e_FM_PCD_CC_STATS_MODE_RMON' was set for this node, the total
-                frame count will be separated to frame length counters, based on
-                provided frame length ranges.
-
- @Param[in]     h_CcNode        A handle to the node
- @Param[in]     keyIndex        Key index for adding
- @Param[out]    p_KeyStatistics Key statistics counters
-
- @Return        The specific key statistics.
-
- @Cautions      Allowed only following FM_PCD_MatchTableSet().
-*//***************************************************************************/
-t_Error FM_PCD_MatchTableGetKeyStatistics(t_Handle                  h_CcNode,
-                                          uint16_t                  keyIndex,
-                                          t_FmPcdCcKeyStatistics    *p_KeyStatistics);
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableGetMissStatistics
-
- @Description   This routine may be used to get statistics counters of miss entry
-                in a CC Node.
-
-                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
-                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
-                these counters reflect how many frames were not matched to any
-                existing key and therefore passed through the miss entry; The
-                total frames count will be returned in the counter of the
-                first range (as only one frame length range was defined).
-
- @Param[in]     h_CcNode            A handle to the node
- @Param[out]    p_MissStatistics    Statistics counters for 'miss'
-
- @Return        The statistics for 'miss'.
-
- @Cautions      Allowed only following FM_PCD_MatchTableSet().
-*//***************************************************************************/
-t_Error FM_PCD_MatchTableGetMissStatistics(t_Handle                  h_CcNode,
-                                           t_FmPcdCcKeyStatistics    *p_MissStatistics);
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableFindNGetKeyStatistics
-
- @Description   This routine may be used to get statistics counters of specific key
-                in a CC Node.
-
-                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
-                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
-                these counters reflect how many frames passed that were matched
-                this key; The total frames count will be returned in the counter
-                of the first range (as only one frame length range was defined).
-                If 'e_FM_PCD_CC_STATS_MODE_RMON' was set for this node, the total
-                frame count will be separated to frame length counters, based on
-                provided frame length ranges.
-                Note that this routine will search the node to locate the index
-                of the required key based on received key parameters.
-
- @Param[in]     h_CcNode        A handle to the node
- @Param[in]     keySize         Size of the requested key
- @Param[in]     p_Key           A pointer to the requested key
- @Param[in]     p_Mask          A pointer to the mask if relevant,
-                                otherwise pointer to NULL
- @Param[out]    p_KeyStatistics Key statistics counters
-
- @Return        The specific key statistics.
-
- @Cautions      Allowed only following FM_PCD_MatchTableSet().
-*//***************************************************************************/
-t_Error FM_PCD_MatchTableFindNGetKeyStatistics(t_Handle                 h_CcNode,
-                                               uint8_t                  keySize,
-                                               uint8_t                  *p_Key,
-                                               uint8_t                  *p_Mask,
-                                               t_FmPcdCcKeyStatistics   *p_KeyStatistics);
-
-/**************************************************************************//*
- @Function      FM_PCD_MatchTableGetNextEngine
-
- @Description   Gets NextEngine of the relevant keyIndex.
-
- @Param[in]     h_CcNode                    A handle to the node.
- @Param[in]     keyIndex                    keyIndex in the relevant node.
- @Param[out]    p_FmPcdCcNextEngineParams   here updated nextEngine parameters for
-                                            the relevant keyIndex of the CC Node
-                                            received as parameter to this function
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
-                                       uint16_t                     keyIndex,
-                                       t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams);
-
-/**************************************************************************//*
- @Function      FM_PCD_MatchTableGetIndexedHashBucket
-
- @Description   This routine simulates KeyGen operation on the provided key and
-                calculates to which hash bucket it will be mapped.
-
- @Param[in]     h_CcNode                A handle to the node.
- @Param[in]     kgKeySize               Key size as it was configured in the KG
-                                        scheme that leads to this hash.
- @Param[in]     p_KgKey                 Pointer to the key; must be like the key
-                                        that the KG is generated, i.e. the same
-                                        extraction and with mask if exist.
- @Param[in]     kgHashShift             Hash-shift as it was configured in the KG
-                                        scheme that leads to this hash.
- @Param[out]    p_CcNodeBucketHandle    Pointer to the bucket of the provided key.
- @Param[out]    p_BucketIndex           Index to the bucket of the provided key
- @Param[out]    p_LastIndex             Pointer to last index in the bucket of the
-                                        provided key.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_HashTableSet()
-*//***************************************************************************/
-t_Error FM_PCD_MatchTableGetIndexedHashBucket(t_Handle    h_CcNode,
-                                              uint8_t     kgKeySize,
-                                              uint8_t     *p_KgKey,
-                                              uint8_t     kgHashShift,
-                                              t_Handle    *p_CcNodeBucketHandle,
-                                              uint8_t     *p_BucketIndex,
-                                              uint16_t    *p_LastIndex);
-
-/**************************************************************************//**
- @Function      FM_PCD_HashTableSet
-
- @Description   This routine initializes a hash table structure.
-                KeyGen hash result determines the hash bucket.
-                Next, KeyGen key is compared against all keys of this
-                bucket (exact match).
-                Number of sets (number of buckets) of the hash equals to the
-                number of 1-s in 'hashResMask' in the provided parameters.
-                Number of hash table ways is then calculated by dividing
-                'maxNumOfKeys' equally between the hash sets. This is the maximal
-                number of keys that a hash bucket may hold.
-                The hash table is initialized empty and keys may be
-                added to it following the initialization. Keys masks are not
-                supported in current hash table implementation.
-                The initialized hash table can be integrated as a node in a
-                CC tree.
-
- @Param[in]     h_FmPcd     FM PCD module descriptor.
- @Param[in]     p_Param     A structure of parameters defining the hash table
-
- @Return        A handle to the initialized object on success; NULL code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param);
-
-/**************************************************************************//**
- @Function      FM_PCD_HashTableDelete
-
- @Description   This routine deletes the provided hash table and released all
-                its allocated resources.
-
- @Param[in]     h_HashTbl       A handle to a hash table
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_HashTableSet().
-*//***************************************************************************/
-t_Error FM_PCD_HashTableDelete(t_Handle h_HashTbl);
-
-/**************************************************************************//**
- @Function      FM_PCD_HashTableAddKey
-
- @Description   This routine adds the provided key (including next engine
-                parameters of this key) to the hash table.
-                The key is added as the last key of the bucket that it is
-                mapped to.
-
- @Param[in]     h_HashTbl    A handle to a hash table
- @Param[in]     keySize      Key size of added key
- @Param[in]     p_KeyParams  A pointer to the parameters includes
-                             new key with next engine parameters; The pointer
-                             to the key mask must be NULL, as masks are not
-                             supported in hash table implementation.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_HashTableSet().
-*//***************************************************************************/
-t_Error FM_PCD_HashTableAddKey(t_Handle            h_HashTbl,
-                               uint8_t             keySize,
-                               t_FmPcdCcKeyParams  *p_KeyParams);
-
-/**************************************************************************//**
- @Function      FM_PCD_HashTableRemoveKey
-
- @Description   This routine removes the requested key (including next engine
-                parameters of this key) from the hash table.
-
- @Param[in]     h_HashTbl    A handle to a hash table
- @Param[in]     keySize      Key size of the one to remove.
- @Param[in]     p_Key        A pointer to the requested key to remove.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_HashTableSet().
-*//***************************************************************************/
-t_Error FM_PCD_HashTableRemoveKey(t_Handle h_HashTbl,
-                                  uint8_t  keySize,
-                                  uint8_t  *p_Key);
-
-/**************************************************************************//**
- @Function      FM_PCD_HashTableModifyNextEngine
-
- @Description   This routine modifies the next engine for the provided key. The
-                key should be previously added to the hash table.
-
- @Param[in]     h_HashTbl                   A handle to a hash table
- @Param[in]     keySize                     Key size of the key to modify.
- @Param[in]     p_Key                       A pointer to the requested key to modify.
- @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine
-                                            parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_HashTableSet().
-                When configuring nextEngine = e_FM_PCD_CC, note that
-                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
-                from the currently changed table.
-*//***************************************************************************/
-t_Error FM_PCD_HashTableModifyNextEngine(t_Handle                  h_HashTbl,
-                                         uint8_t                   keySize,
-                                         uint8_t                   *p_Key,
-                                         t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
-
-/**************************************************************************//**
- @Function      FM_PCD_HashTableModifyMissNextEngine
-
- @Description   This routine modifies the next engine on key match miss.
-
- @Param[in]     h_HashTbl                   A handle to a hash table
- @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine
-                                            parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_HashTableSet().
-                When configuring nextEngine = e_FM_PCD_CC, note that
-                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
-                from the currently changed table.
-*//***************************************************************************/
-t_Error FM_PCD_HashTableModifyMissNextEngine(t_Handle                  h_HashTbl,
-                                             t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
-
-/**************************************************************************//*
- @Function      FM_PCD_HashTableGetMissNextEngine
-
- @Description   Gets NextEngine in case of key match miss.
-
- @Param[in]     h_HashTbl                   A handle to a hash table
- @Param[out]    p_FmPcdCcNextEngineParams   Next engine parameters for the specified
-                                            hash table.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_HashTableSet().
-*//***************************************************************************/
-t_Error FM_PCD_HashTableGetMissNextEngine(t_Handle                     h_HashTbl,
-                                          t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams);
-
-/**************************************************************************//**
- @Function      FM_PCD_HashTableFindNGetKeyStatistics
-
- @Description   This routine may be used to get statistics counters of specific key
-                in a hash table.
-
-                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
-                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
-                these counters reflect how many frames passed that were matched
-                this key; The total frames count will be returned in the counter
-                of the first range (as only one frame length range was defined).
-                If 'e_FM_PCD_CC_STATS_MODE_RMON' was set for this node, the total
-                frame count will be separated to frame length counters, based on
-                provided frame length ranges.
-                Note that this routine will identify the bucket of this key in
-                the hash table and will search the bucket to locate the index
-                of the required key based on received key parameters.
-
- @Param[in]     h_HashTbl       A handle to a hash table
- @Param[in]     keySize         Size of the requested key
- @Param[in]     p_Key           A pointer to the requested key
- @Param[out]    p_KeyStatistics Key statistics counters
-
- @Return        The specific key statistics.
-
- @Cautions      Allowed only following FM_PCD_HashTableSet().
-*//***************************************************************************/
-t_Error FM_PCD_HashTableFindNGetKeyStatistics(t_Handle                 h_HashTbl,
-                                              uint8_t                  keySize,
-                                              uint8_t                  *p_Key,
-                                              t_FmPcdCcKeyStatistics   *p_KeyStatistics);
-
-/**************************************************************************//**
- @Function      FM_PCD_HashTableGetMissStatistics
-
- @Description   This routine may be used to get statistics counters of 'miss'
-                entry of the a hash table.
-
-                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
-                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
-                these counters reflect how many frames were not matched to any
-                existing key and therefore passed through the miss entry;
-
- @Param[in]     h_HashTbl           A handle to a hash table
- @Param[out]    p_MissStatistics    Statistics counters for 'miss'
-
- @Return        The statistics for 'miss'.
-
- @Cautions      Allowed only following FM_PCD_HashTableSet().
-*//***************************************************************************/
-t_Error FM_PCD_HashTableGetMissStatistics(t_Handle                 h_HashTbl,
-                                          t_FmPcdCcKeyStatistics   *p_MissStatistics);
-
-/**************************************************************************//**
- @Function      FM_PCD_ManipNodeSet
-
- @Description   This routine should be called for defining a manipulation
-                node. A manipulation node must be defined before the CC node
-                that precedes it.
-
- @Param[in]     h_FmPcd             FM PCD module descriptor.
- @Param[in]     p_FmPcdManipParams  A structure of parameters defining the manipulation
-
- @Return        A handle to the initialized object on success; NULL code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_FmPcdManipParams);
-
-/**************************************************************************//**
- @Function      FM_PCD_ManipNodeDelete
-
- @Description   Delete an existing manipulation node.
-
- @Param[in]     h_ManipNode     A handle to a manipulation node.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_ManipNodeSet().
-*//***************************************************************************/
-t_Error  FM_PCD_ManipNodeDelete(t_Handle h_ManipNode);
-
-/**************************************************************************//**
- @Function      FM_PCD_ManipGetStatistics
-
- @Description   Retrieve the manipulation statistics.
-
- @Param[in]     h_ManipNode         A handle to a manipulation node.
- @Param[out]    p_FmPcdManipStats   A structure for retrieving the manipulation statistics
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_ManipNodeSet().
-*//***************************************************************************/
-t_Error FM_PCD_ManipGetStatistics(t_Handle h_ManipNode, t_FmPcdManipStats *p_FmPcdManipStats);
-
-/**************************************************************************//**
- @Function      FM_PCD_ManipNodeReplace
-
- @Description   Change existing manipulation node to be according to new requirement.
-
- @Param[in]     h_ManipNode         A handle to a manipulation node.
- @Param[out]    p_ManipParams       A structure of parameters defining the change requirement
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_ManipNodeSet().
-*//***************************************************************************/
-t_Error FM_PCD_ManipNodeReplace(t_Handle h_ManipNode, t_FmPcdManipParams *p_ManipParams);
-
-#if (DPAA_VERSION >= 11)
-/**************************************************************************//**
- @Function      FM_PCD_FrmReplicSetGroup
-
- @Description   Initialize a Frame Replicator group.
-
- @Param[in]     h_FmPcd                FM PCD module descriptor.
- @Param[in]     p_FrmReplicGroupParam  A structure of parameters for the initialization of
-                                       the frame replicator group.
-
- @Return        A handle to the initialized object on success; NULL code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-t_Handle FM_PCD_FrmReplicSetGroup(t_Handle h_FmPcd, t_FmPcdFrmReplicGroupParams *p_FrmReplicGroupParam);
-
-/**************************************************************************//**
- @Function      FM_PCD_FrmReplicDeleteGroup
-
- @Description   Delete a Frame Replicator group.
-
- @Param[in]     h_FrmReplicGroup  A handle to the frame replicator group.
-
- @Return        E_OK on success;  Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup().
-*//***************************************************************************/
-t_Error FM_PCD_FrmReplicDeleteGroup(t_Handle h_FrmReplicGroup);
-
-/**************************************************************************//**
- @Function      FM_PCD_FrmReplicAddMember
-
- @Description   Add the member in the index defined by the memberIndex.
-
- @Param[in]     h_FrmReplicGroup   A handle to the frame replicator group.
- @Param[in]     memberIndex        member index for adding.
- @Param[in]     p_MemberParams     A pointer to the new member parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup() of this group.
-*//***************************************************************************/
-t_Error FM_PCD_FrmReplicAddMember(t_Handle                   h_FrmReplicGroup,
-                                  uint16_t                   memberIndex,
-                                  t_FmPcdCcNextEngineParams *p_MemberParams);
-
-/**************************************************************************//**
- @Function      FM_PCD_FrmReplicRemoveMember
-
- @Description   Remove the member defined by the index from the relevant group.
-
- @Param[in]     h_FrmReplicGroup   A handle to the frame replicator group.
- @Param[in]     memberIndex        member index for removing.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup() of this group.
-*//***************************************************************************/
-t_Error FM_PCD_FrmReplicRemoveMember(t_Handle h_FrmReplicGroup,
-                                     uint16_t memberIndex);
-#endif /* (DPAA_VERSION >= 11) */
-
-#ifdef FM_CAPWAP_SUPPORT
-/**************************************************************************//**
- @Function      FM_PCD_StatisticsSetNode
-
- @Description   This routine should be called for defining a statistics node.
-
- @Param[in]     h_FmPcd             FM PCD module descriptor.
- @Param[in]     p_FmPcdstatsParams  A structure of parameters defining the statistics
-
- @Return        A handle to the initialized object on success; NULL code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_FmPcdstatsParams);
-#endif /* FM_CAPWAP_SUPPORT */
-
-/** @} */ /* end of FM_PCD_Runtime_build_grp group */
-/** @} */ /* end of FM_PCD_Runtime_grp group */
-/** @} */ /* end of FM_PCD_grp group */
-/** @} */ /* end of FM_grp group */
-
-
-#ifdef NCSW_BACKWARD_COMPATIBLE_API
-#define FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS   FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
-#define e_FM_PCD_MANIP_ONE_WAYS_HASH            e_FM_PCD_MANIP_ONE_WAY_HASH
-#define e_FM_PCD_MANIP_TOW_WAYS_HASH            e_FM_PCD_MANIP_TWO_WAYS_HASH
-
-#define e_FM_PCD_MANIP_FRAGMENT_PACKECT         e_FM_PCD_MANIP_FRAGMENT_PACKET /* Feb13 */
-
-#define FM_PCD_SetNetEnvCharacteristics(_pcd, _params)  \
-    FM_PCD_NetEnvCharacteristicsSet(_pcd, _params)
-#define FM_PCD_KgSetScheme(_pcd, _params)       FM_PCD_KgSchemeSet(_pcd, _params)
-#define FM_PCD_CcBuildTree(_pcd, _params)       FM_PCD_CcRootBuild(_pcd, _params)
-#define FM_PCD_CcSetNode(_pcd, _params)         FM_PCD_MatchTableSet(_pcd, _params)
-#define FM_PCD_PlcrSetProfile(_pcd, _params)    FM_PCD_PlcrProfileSet(_pcd, _params)
-#define FM_PCD_ManipSetNode(_pcd, _params)      FM_PCD_ManipNodeSet(_pcd, _params)
-
-#define FM_PCD_DeleteNetEnvCharacteristics(_pcd, ...)   \
-    FM_PCD_NetEnvCharacteristicsDelete(__VA_ARGS__)
-#define FM_PCD_KgDeleteScheme(_pcd, ...)   \
-    FM_PCD_KgSchemeDelete(__VA_ARGS__)
-#define FM_PCD_KgGetSchemeCounter(_pcd, ...)   \
-    FM_PCD_KgSchemeGetCounter(__VA_ARGS__)
-#define FM_PCD_KgSetSchemeCounter(_pcd, ...)   \
-    FM_PCD_KgSchemeSetCounter(__VA_ARGS__)
-#define FM_PCD_PlcrDeleteProfile(_pcd, ...)   \
-    FM_PCD_PlcrProfileDelete(__VA_ARGS__)
-#define FM_PCD_PlcrGetProfileCounter(_pcd, ...)   \
-    FM_PCD_PlcrProfileGetCounter(__VA_ARGS__)
-#define FM_PCD_PlcrSetProfileCounter(_pcd, ...)   \
-    FM_PCD_PlcrProfileSetCounter(__VA_ARGS__)
-#define FM_PCD_CcDeleteTree(_pcd, ...)   \
-    FM_PCD_CcRootDelete(__VA_ARGS__)
-#define FM_PCD_CcTreeModifyNextEngine(_pcd, ...)   \
-    FM_PCD_CcRootModifyNextEngine(__VA_ARGS__)
-#define FM_PCD_CcDeleteNode(_pcd, ...)   \
-    FM_PCD_MatchTableDelete(__VA_ARGS__)
-#define FM_PCD_CcNodeModifyMissNextEngine(_pcd, ...)   \
-    FM_PCD_MatchTableModifyMissNextEngine(__VA_ARGS__)
-#define FM_PCD_CcNodeRemoveKey(_pcd, ...)   \
-    FM_PCD_MatchTableRemoveKey(__VA_ARGS__)
-#define FM_PCD_CcNodeAddKey(_pcd, ...)   \
-    FM_PCD_MatchTableAddKey(__VA_ARGS__)
-#define FM_PCD_CcNodeModifyNextEngine(_pcd, ...)   \
-    FM_PCD_MatchTableModifyNextEngine(__VA_ARGS__)
-#define FM_PCD_CcNodeModifyKeyAndNextEngine(_pcd, ...)   \
-    FM_PCD_MatchTableModifyKeyAndNextEngine(__VA_ARGS__)
-#define FM_PCD_CcNodeModifyKey(_pcd, ...)   \
-    FM_PCD_MatchTableModifyKey(__VA_ARGS__)
-#define FM_PCD_CcNodeFindNRemoveKey(_pcd, ...)   \
-    FM_PCD_MatchTableFindNRemoveKey(__VA_ARGS__)
-#define FM_PCD_CcNodeFindNModifyNextEngine(_pcd, ...)   \
-    FM_PCD_MatchTableFindNModifyNextEngine(__VA_ARGS__)
-#define FM_PCD_CcNodeFindNModifyKeyAndNextEngine(_pcd, ...) \
-    FM_PCD_MatchTableFindNModifyKeyAndNextEngine(__VA_ARGS__)
-#define FM_PCD_CcNodeFindNModifyKey(_pcd, ...)   \
-    FM_PCD_MatchTableFindNModifyKey(__VA_ARGS__)
-#define FM_PCD_CcIndexedHashNodeGetBucket(_pcd, ...)   \
-    FM_PCD_MatchTableGetIndexedHashBucket(__VA_ARGS__)
-#define FM_PCD_CcNodeGetNextEngine(_pcd, ...)   \
-    FM_PCD_MatchTableGetNextEngine(__VA_ARGS__)
-#define FM_PCD_CcNodeGetKeyCounter(_pcd, ...)   \
-    FM_PCD_MatchTableGetKeyCounter(__VA_ARGS__)
-#define FM_PCD_ManipDeleteNode(_pcd, ...)   \
-    FM_PCD_ManipNodeDelete(__VA_ARGS__)
-#endif /* NCSW_BACKWARD_COMPATIBLE_API */
-
-
-#endif /* __FM_PCD_EXT */
--- fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/fsl_fman_kg.h.orig	2022-05-26 11:28:30.982977418 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/fsl_fman_kg.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,514 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __FSL_FMAN_KG_H
-#define __FSL_FMAN_KG_H
-
-#include "common/general.h"
-
-#define FM_KG_NUM_OF_GENERIC_REGS	8 /**< Num of generic KeyGen regs */
-#define FMAN_MAX_NUM_OF_HW_PORTS	64
-/**< Total num of masks allowed on KG extractions */
-#define FM_KG_EXTRACT_MASKS_NUM		4
-#define FM_KG_NUM_CLS_PLAN_ENTR		8 /**< Num of class. plan regs */
-#define FM_KG_CLS_PLAN_GRPS_NUM		32 /**< Max num of class. groups */
-
-struct fman_kg_regs {
-	uint32_t fmkg_gcr;
-	uint32_t res004;
-	uint32_t res008;
-	uint32_t fmkg_eer;
-	uint32_t fmkg_eeer;
-	uint32_t res014;
-	uint32_t res018;
-	uint32_t fmkg_seer;
-	uint32_t fmkg_seeer;
-	uint32_t fmkg_gsr;
-	uint32_t fmkg_tpc;
-	uint32_t fmkg_serc;
-	uint32_t res030[4];
-	uint32_t fmkg_fdor;
-	uint32_t fmkg_gdv0r;
-	uint32_t fmkg_gdv1r;
-	uint32_t res04c[6];
-	uint32_t fmkg_feer;
-	uint32_t res068[38];
-	uint32_t fmkg_indirect[63];
-	uint32_t fmkg_ar;
-};
-
-struct fman_kg_scheme_regs {
-	uint32_t kgse_mode; /**< MODE */
-	uint32_t kgse_ekfc; /**< Extract Known Fields Command */
-	uint32_t kgse_ekdv; /**< Extract Known Default Value */
-	uint32_t kgse_bmch; /**< Bit Mask Command High */
-	uint32_t kgse_bmcl; /**< Bit Mask Command Low */
-	uint32_t kgse_fqb; /**< Frame Queue Base */
-	uint32_t kgse_hc; /**< Hash Command */
-	uint32_t kgse_ppc; /**< Policer Profile Command */
-	uint32_t kgse_gec[FM_KG_NUM_OF_GENERIC_REGS];
-				/**< Generic Extract Command */
-	uint32_t kgse_spc; /**< KeyGen Scheme Entry Statistic Packet Counter */
-	uint32_t kgse_dv0; /**< KeyGen Scheme Entry Default Value 0 */
-	uint32_t kgse_dv1; /**< KeyGen Scheme Entry Default Value 1 */
-	uint32_t kgse_ccbs; /**< KeyGen Scheme Entry Coarse Classification Bit*/
-	uint32_t kgse_mv; /**< KeyGen Scheme Entry Match vector */
-	uint32_t kgse_om; /**< KeyGen Scheme Entry Operation Mode bits */
-	uint32_t kgse_vsp; /**< KeyGen Scheme Entry Virtual Storage Profile */
-};
-
-struct fman_kg_pe_regs{
-	uint32_t fmkg_pe_sp;
-	uint32_t fmkg_pe_cpp;
-};
-
-struct fman_kg_cp_regs {
-	uint32_t kgcpe[FM_KG_NUM_CLS_PLAN_ENTR];
-};
-
-
-#define FM_KG_KGAR_GO				0x80000000
-#define FM_KG_KGAR_READ				0x40000000
-#define FM_KG_KGAR_WRITE			0x00000000
-#define FM_KG_KGAR_SEL_SCHEME_ENTRY		0x00000000
-#define FM_KG_KGAR_SCM_WSEL_UPDATE_CNT		0x00008000
-
-#define KG_SCH_PP_SHIFT_HIGH			0x80000000
-#define KG_SCH_PP_NO_GEN			0x10000000
-#define KG_SCH_PP_SHIFT_LOW			0x0000F000
-#define KG_SCH_MODE_NIA_PLCR			0x40000000
-#define KG_SCH_GEN_EXTRACT_TYPE			0x00008000
-#define KG_SCH_BITMASK_MASK			0x000000FF
-#define KG_SCH_GEN_VALID			0x80000000
-#define KG_SCH_GEN_MASK				0x00FF0000
-#define FM_PCD_KG_KGAR_ERR			0x20000000
-#define FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY	0x01000000
-#define FM_PCD_KG_KGAR_SEL_PORT_ENTRY		0x02000000
-#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP		0x00008000
-#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP	0x00004000
-#define FM_PCD_KG_KGAR_WSEL_MASK		0x0000FF00
-#define KG_SCH_HASH_CONFIG_NO_FQID		0x80000000
-#define KG_SCH_HASH_CONFIG_SYM			0x40000000
-
-#define FM_EX_KG_DOUBLE_ECC			0x80000000
-#define FM_EX_KG_KEYSIZE_OVERFLOW		0x40000000
-
-/* ECC capture register */
-#define KG_FMKG_SERC_CAP			0x80000000
-#define KG_FMKG_SERC_CET			0x40000000
-#define KG_FMKG_SERC_CNT_MSK			0x00FF0000
-#define KG_FMKG_SERC_CNT_SHIFT			16
-#define KG_FMKG_SERC_ADDR_MSK			0x000003FF
-
-/* Masks */
-#define FM_KG_KGGCR_EN				0x80000000
-#define KG_SCH_GEN_VALID			0x80000000
-#define KG_SCH_GEN_EXTRACT_TYPE			0x00008000
-#define KG_ERR_TYPE_DOUBLE			0x40000000
-#define KG_ERR_ADDR_MASK			0x00000FFF
-#define KG_SCH_MODE_EN				0x80000000
-
-/* shifts */
-#define FM_KG_KGAR_NUM_SHIFT			16
-#define FM_KG_PE_CPP_MASK_SHIFT			16
-#define FM_KG_KGAR_WSEL_SHIFT			8
-
-#define FM_KG_SCH_GEN_HT_INVALID		0
-
-#define FM_KG_MASK_SEL_GEN_BASE			0x20
-
-#define KG_GET_MASK_SEL_SHIFT(shift, i)	\
-switch (i)				\
-{					\
-	case 0: (shift) = 26; break;	\
-	case 1: (shift) = 20; break;	\
-	case 2: (shift) = 10; break;	\
-	case 3: (shift) = 4; break;	\
-	default: (shift) = 0;		\
-}
-
-#define KG_GET_MASK_OFFSET_SHIFT(shift, i)	\
-switch (i)				\
-{					\
-	case 0: (shift) = 16; break;	\
-	case 1: (shift) = 0; break;	\
-	case 2: (shift) = 28; break;	\
-	case 3: (shift) = 24; break;	\
-	default: (shift) = 0;		\
-}
-
-#define KG_GET_MASK_SHIFT(shift, i)	\
-switch (i)				\
-{					\
-	case 0: shift = 24; break;	\
-	case 1: shift = 16; break;	\
-	case 2: shift = 8;  break;	\
-	case 3: shift = 0;  break;	\
-	default: shift = 0;		\
-}
-
-/* Port entry CPP register */
-#define FMAN_KG_PE_CPP_MASK_SHIFT	16
-
-/* Scheme registers */
-#define FMAN_KG_SCH_MODE_EN		0x80000000
-#define FMAN_KG_SCH_MODE_NIA_PLCR	0x40000000
-#define FMAN_KG_SCH_MODE_CCOBASE_SHIFT	24
-
-#define FMAN_KG_SCH_DEF_MAC_ADDR_SHIFT	30
-#define FMAN_KG_SCH_DEF_VLAN_TCI_SHIFT	28
-#define FMAN_KG_SCH_DEF_ETYPE_SHIFT	26
-#define FMAN_KG_SCH_DEF_PPP_SID_SHIFT	24
-#define FMAN_KG_SCH_DEF_PPP_PID_SHIFT	22
-#define FMAN_KG_SCH_DEF_MPLS_SHIFT	20
-#define FMAN_KG_SCH_DEF_IP_ADDR_SHIFT	18
-#define FMAN_KG_SCH_DEF_PTYPE_SHIFT	16
-#define FMAN_KG_SCH_DEF_IP_TOS_TC_SHIFT	14
-#define FMAN_KG_SCH_DEF_IPv6_FL_SHIFT	12
-#define FMAN_KG_SCH_DEF_IPSEC_SPI_SHIFT	10
-#define FMAN_KG_SCH_DEF_L4_PORT_SHIFT	8
-#define FMAN_KG_SCH_DEF_TCP_FLG_SHIFT	6
-
-#define FMAN_KG_SCH_GEN_VALID		0x80000000
-#define FMAN_KG_SCH_GEN_SIZE_MAX	16
-#define FMAN_KG_SCH_GEN_OR		0x00008000
-
-#define FMAN_KG_SCH_GEN_DEF_SHIFT	29
-#define FMAN_KG_SCH_GEN_SIZE_SHIFT	24
-#define FMAN_KG_SCH_GEN_MASK_SHIFT	16
-#define FMAN_KG_SCH_GEN_HT_SHIFT	8
-
-#define FMAN_KG_SCH_HASH_HSHIFT_SHIFT	24
-#define FMAN_KG_SCH_HASH_HSHIFT_MAX	0x28
-#define FMAN_KG_SCH_HASH_SYM		0x40000000
-#define FMAN_KG_SCH_HASH_NO_FQID_GEN	0x80000000
-
-#define FMAN_KG_SCH_PP_SH_SHIFT		27
-#define FMAN_KG_SCH_PP_SL_SHIFT		12
-#define FMAN_KG_SCH_PP_SH_MASK		0x80000000
-#define FMAN_KG_SCH_PP_SL_MASK		0x0000F000
-#define FMAN_KG_SCH_PP_SHIFT_MAX	0x17
-#define FMAN_KG_SCH_PP_MASK_SHIFT	16
-#define FMAN_KG_SCH_PP_NO_GEN		0x10000000
-
-enum fman_kg_gen_extract_src {
-	E_FMAN_KG_GEN_EXTRACT_ETH,
-	E_FMAN_KG_GEN_EXTRACT_ETYPE,
-	E_FMAN_KG_GEN_EXTRACT_SNAP,
-	E_FMAN_KG_GEN_EXTRACT_VLAN_TCI_1,
-	E_FMAN_KG_GEN_EXTRACT_VLAN_TCI_N,
-	E_FMAN_KG_GEN_EXTRACT_PPPoE,
-	E_FMAN_KG_GEN_EXTRACT_MPLS_1,
-	E_FMAN_KG_GEN_EXTRACT_MPLS_2,
-	E_FMAN_KG_GEN_EXTRACT_MPLS_3,
-	E_FMAN_KG_GEN_EXTRACT_MPLS_N,
-	E_FMAN_KG_GEN_EXTRACT_IPv4_1,
-	E_FMAN_KG_GEN_EXTRACT_IPv6_1,
-	E_FMAN_KG_GEN_EXTRACT_IPv4_2,
-	E_FMAN_KG_GEN_EXTRACT_IPv6_2,
-	E_FMAN_KG_GEN_EXTRACT_MINENCAP,
-	E_FMAN_KG_GEN_EXTRACT_IP_PID,
-	E_FMAN_KG_GEN_EXTRACT_GRE,
-	E_FMAN_KG_GEN_EXTRACT_TCP,
-	E_FMAN_KG_GEN_EXTRACT_UDP,
-	E_FMAN_KG_GEN_EXTRACT_SCTP,
-	E_FMAN_KG_GEN_EXTRACT_DCCP,
-	E_FMAN_KG_GEN_EXTRACT_IPSEC_AH,
-	E_FMAN_KG_GEN_EXTRACT_IPSEC_ESP,
-	E_FMAN_KG_GEN_EXTRACT_SHIM_1,
-	E_FMAN_KG_GEN_EXTRACT_SHIM_2,
-	E_FMAN_KG_GEN_EXTRACT_FROM_DFLT,
-	E_FMAN_KG_GEN_EXTRACT_FROM_FRAME_START,
-	E_FMAN_KG_GEN_EXTRACT_FROM_PARSE_RESULT,
-	E_FMAN_KG_GEN_EXTRACT_FROM_END_OF_PARSE,
-	E_FMAN_KG_GEN_EXTRACT_FROM_FQID
-};
-
-struct fman_kg_ex_ecc_attr
-{
-	bool		valid;
-	bool		double_ecc;
-	uint16_t	addr;
-	uint8_t		single_ecc_count;
-};
-
-enum fman_kg_def_select
-{
-	E_FMAN_KG_DEF_GLOBAL_0,
-	E_FMAN_KG_DEF_GLOBAL_1,
-	E_FMAN_KG_DEF_SCHEME_0,
-	E_FMAN_KG_DEF_SCHEME_1
-};
-
-struct fman_kg_extract_def
-{
-	enum fman_kg_def_select	mac_addr;
-	enum fman_kg_def_select	vlan_tci;
-	enum fman_kg_def_select	etype;
-	enum fman_kg_def_select	ppp_sid;
-	enum fman_kg_def_select	ppp_pid;
-	enum fman_kg_def_select	mpls;
-	enum fman_kg_def_select	ip_addr;
-	enum fman_kg_def_select	ptype;
-	enum fman_kg_def_select	ip_tos_tc;
-	enum fman_kg_def_select	ipv6_fl;
-	enum fman_kg_def_select	ipsec_spi;
-	enum fman_kg_def_select	l4_port;
-	enum fman_kg_def_select	tcp_flg;
-};
-
-enum fman_kg_gen_extract_type
-{
-	E_FMAN_KG_HASH_EXTRACT,
-	E_FMAN_KG_OR_EXTRACT
-};
-
-struct fman_kg_gen_extract_params
-{
-	/* Hash or Or-ed extract */
-	enum fman_kg_gen_extract_type	type;
-	enum fman_kg_gen_extract_src	src;
-	bool				no_validation;
-	/* Extraction offset from the header location specified above */
-	uint8_t				offset;
-	/* Size of extraction for FMAN_KG_HASH_EXTRACT,
-	 * hash result shift for FMAN_KG_OR_EXTRACT */
-	uint8_t				extract;
-	uint8_t				mask;
-	/* Default value to use when header specified
-	 * by fman_kg_gen_extract_src doesn't present */
-	enum fman_kg_def_select		def_val;
-};
-
-struct fman_kg_extract_mask
-{
-	/**< Indication if mask is on known field extraction or
-	 * on general extraction; TRUE for known field */
-	bool		is_known;
-	/**< One of FMAN_KG_EXTRACT_xxx defines for known fields mask and
-	 * generic register index for generic extracts mask */
-	uint32_t	field_or_gen_idx;
-	/**< Byte offset from start of the extracted data specified
-	 * by field_or_gen_idx */
-	uint8_t		offset;
-	/**< Byte mask (selected bits will be used) */
-	uint8_t		mask;
-};
-
-struct fman_kg_extract_params
-{
-	/* Or-ed mask of FMAN_KG_EXTRACT_xxx defines */
-	uint32_t				known_fields;
-	struct fman_kg_extract_def		known_fields_def;
-	/* Number of entries in gen_extract */
-	uint8_t					gen_extract_num;
-	struct fman_kg_gen_extract_params	gen_extract[FM_KG_NUM_OF_GENERIC_REGS];
-	/* Number of entries in masks */
-	uint8_t					masks_num;
-	struct fman_kg_extract_mask		masks[FM_KG_EXTRACT_MASKS_NUM];
-	uint32_t				def_scheme_0;
-	uint32_t				def_scheme_1;
-};
-
-struct fman_kg_hash_params
-{
-	bool		use_hash;
-	uint8_t		shift_r;
-	uint32_t	mask; /**< 24-bit mask */
-	bool		sym; /**< Symmetric hash for src and dest pairs */
-};
-
-struct fman_kg_pp_params
-{
-	uint8_t		base;
-	uint8_t		shift;
-	uint8_t		mask;
-	bool		bypass_pp_gen;
-};
-
-struct fman_kg_cc_params
-{
-	uint8_t		base_offset;
-	uint32_t	qlcv_bits_sel;
-};
-
-enum fman_pcd_engine
-{
-	E_FMAN_PCD_INVALID = 0,	/**< Invalid PCD engine indicated*/
-	E_FMAN_PCD_DONE,	/**< No PCD Engine indicated */
-	E_FMAN_PCD_KG,		/**< Keygen indicated */
-	E_FMAN_PCD_CC,		/**< Coarse classification indicated */
-	E_FMAN_PCD_PLCR,	/**< Policer indicated */
-	E_FMAN_PCD_PRS		/**< Parser indicated */
-};
-
-struct fman_kg_cls_plan_params
-{
-	uint8_t entries_mask;
-	uint32_t mask_vector[FM_KG_NUM_CLS_PLAN_ENTR];
-};
-
-struct fman_kg_scheme_params
-{
-	uint32_t			match_vector;
-	struct fman_kg_extract_params	extract_params;
-	struct fman_kg_hash_params	hash_params;
-	uint32_t			base_fqid;
-	/* What we do w/features supported per FM version ?? */
-	bool				bypass_fqid_gen;
-	struct fman_kg_pp_params	policer_params;
-	struct fman_kg_cc_params	cc_params;
-	bool				update_counter;
-	/**< counter_value: Set scheme counter to the specified value;
-	 * relevant only when update_counter = TRUE. */
-	uint32_t			counter_value;
-	enum fman_pcd_engine		next_engine;
-	/**< Next engine action code */
-	uint32_t			next_engine_action;
-};
-
-
-
-int fman_kg_write_ar_wait(struct fman_kg_regs *regs, uint32_t fmkg_ar);
-void fman_kg_write_sp(struct fman_kg_regs *regs, uint32_t sp, bool add);
-void fman_kg_write_cpp(struct fman_kg_regs *regs, uint32_t cpp);
-void fman_kg_get_event(struct fman_kg_regs *regs,
-			uint32_t *event,
-			uint32_t *scheme_idx);
-void fman_kg_init(struct fman_kg_regs *regs,
-			uint32_t exceptions,
-			uint32_t dflt_nia);
-void fman_kg_enable_scheme_interrupts(struct fman_kg_regs *regs);
-void fman_kg_enable(struct fman_kg_regs *regs);
-void fman_kg_disable(struct fman_kg_regs *regs);
-int fman_kg_write_bind_cls_plans(struct fman_kg_regs *regs,
-					uint8_t hwport_id,
-					uint32_t bind_cls_plans);
-int fman_kg_build_bind_cls_plans(uint8_t grp_base,
-					uint8_t grp_mask,
-					uint32_t *bind_cls_plans);
-int fman_kg_write_bind_schemes(struct fman_kg_regs *regs,
-				uint8_t hwport_id,
-				uint32_t schemes);
-int fman_kg_write_cls_plan(struct fman_kg_regs *regs,
-				uint8_t grp_id,
-				uint8_t entries_mask,
-				uint8_t hwport_id,
-				struct fman_kg_cp_regs *cls_plan_regs);
-int fman_kg_build_cls_plan(struct fman_kg_cls_plan_params *params,
-				struct fman_kg_cp_regs *cls_plan_regs);
-uint32_t fman_kg_get_schemes_total_counter(struct fman_kg_regs *regs);
-int fman_kg_set_scheme_counter(struct fman_kg_regs *regs,
-				uint8_t scheme_id,
-				uint8_t hwport_id,
-				uint32_t counter);
-int fman_kg_get_scheme_counter(struct fman_kg_regs *regs,
-				uint8_t scheme_id,
-				uint8_t hwport_id,
-				uint32_t *counter);
-int fman_kg_delete_scheme(struct fman_kg_regs *regs,
-				uint8_t scheme_id,
-				uint8_t hwport_id);
-int fman_kg_write_scheme(struct fman_kg_regs *regs,
-				uint8_t scheme_id,
-				uint8_t hwport_id,
-				struct fman_kg_scheme_regs *scheme_regs,
-				bool update_counter);
-int fman_kg_build_scheme(struct fman_kg_scheme_params *params,
-				struct fman_kg_scheme_regs *scheme_regs);
-void fman_kg_get_capture(struct fman_kg_regs *regs,
-				struct fman_kg_ex_ecc_attr *ecc_attr,
-				bool clear);
-void fman_kg_get_exception(struct fman_kg_regs *regs,
-				uint32_t *events,
-				uint32_t *scheme_ids,
-				bool clear);
-void fman_kg_set_exception(struct fman_kg_regs *regs,
-				uint32_t exception,
-				bool enable);
-void fman_kg_set_dflt_val(struct fman_kg_regs *regs,
-				uint8_t def_id,
-				uint32_t val);
-void fman_kg_set_data_after_prs(struct fman_kg_regs *regs, uint8_t offset);
-
-
-	
-/**************************************************************************//**
-  @Description       NIA Description
-*//***************************************************************************/
-#define KG_NIA_ORDER_RESTOR	0x00800000
-#define KG_NIA_ENG_FM_CTL	0x00000000
-#define KG_NIA_ENG_PRS		0x00440000
-#define KG_NIA_ENG_KG		0x00480000
-#define KG_NIA_ENG_PLCR		0x004C0000
-#define KG_NIA_ENG_BMI		0x00500000
-#define KG_NIA_ENG_QMI_ENQ	0x00540000
-#define KG_NIA_ENG_QMI_DEQ	0x00580000
-#define KG_NIA_ENG_MASK		0x007C0000
-
-#define KG_NIA_AC_MASK		0x0003FFFF
-
-#define KG_NIA_INVALID		0xFFFFFFFF
-
-static __inline__ uint32_t fm_kg_build_nia(enum fman_pcd_engine next_engine,
-					uint32_t next_engine_action)
-{
-	uint32_t nia;
-
-	if (next_engine_action & ~KG_NIA_AC_MASK)
-		return KG_NIA_INVALID;
-
-	switch (next_engine) {
-	case E_FMAN_PCD_DONE:
-		nia = KG_NIA_ENG_BMI | next_engine_action;
-		break;
-
-	case E_FMAN_PCD_KG:
-		nia = KG_NIA_ENG_KG | next_engine_action;
-		break;
-
-	case E_FMAN_PCD_CC:
-		nia = KG_NIA_ENG_FM_CTL | next_engine_action;
-		break;
-
-	case E_FMAN_PCD_PLCR:
-		nia = KG_NIA_ENG_PLCR | next_engine_action;
-		break;
-
-	default:
-		nia = KG_NIA_INVALID;
-	}
-
-	return nia;
-}
-
-#endif /* __FSL_FMAN_KG_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/fsl_enet.h.orig	2022-05-26 11:28:30.982977418 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/fsl_enet.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,76 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __FSL_ENET_H
-#define __FSL_ENET_H
-
-/**
- @Description  Ethernet MAC-PHY Interface
-*/
-
-enum enet_interface {
-	E_ENET_IF_MII		= 0x00010000, /**< MII interface */
-	E_ENET_IF_RMII		= 0x00020000, /**< RMII interface */
-	E_ENET_IF_SMII		= 0x00030000, /**< SMII interface */
-	E_ENET_IF_GMII		= 0x00040000, /**< GMII interface */
-	E_ENET_IF_RGMII		= 0x00050000, /**< RGMII interface */
-	E_ENET_IF_TBI		= 0x00060000, /**< TBI interface */
-	E_ENET_IF_RTBI		= 0x00070000, /**< RTBI interface */
-	E_ENET_IF_SGMII		= 0x00080000, /**< SGMII interface */
-	E_ENET_IF_XGMII		= 0x00090000, /**< XGMII interface */
-	E_ENET_IF_QSGMII	= 0x000a0000, /**< QSGMII interface */
-	E_ENET_IF_XFI		= 0x000b0000  /**< XFI interface */
-};
-
-/**
- @Description  Ethernet Speed (nominal data rate)
-*/
-enum enet_speed {
-	E_ENET_SPEED_10		= 10,	/**< 10 Mbps */
-	E_ENET_SPEED_100	= 100,	/**< 100 Mbps */
-	E_ENET_SPEED_1000	= 1000,	/**< 1000 Mbps = 1 Gbps */
-	E_ENET_SPEED_10000	= 10000	/**< 10000 Mbps = 10 Gbps */
-};
-
-enum mac_stat_level {
-	/* No statistics */
-	E_MAC_STAT_NONE = 0,
-	/* Only RMON MIB group 1 (ether stats). Optimized for performance */
-	E_MAC_STAT_MIB_GRP1,
-	/* Only error counters are available. Optimized for performance */
-	E_MAC_STAT_PARTIAL,
-	/* All counters available. Not optimized for performance */
-	E_MAC_STAT_FULL
-};
-
-
-#endif /* __FSL_ENET_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/common/general.h.orig	2022-05-26 11:28:30.970977909 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/common/general.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,51 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __GENERAL_H
-#define __GENERAL_H
-
-#include "std_ext.h"
-#if !defined(NCSW_LINUX)
-#include "errno.h"
-#endif
-
-
-extern uint32_t get_mac_addr_crc(uint64_t _addr);
-
-
-#define iowrite32be(val, addr)  WRITE_UINT32(*addr, val)
-#define ioread32be(addr)        GET_UINT32(*addr)
-
-#define ether_crc(len, addr)    get_mac_addr_crc(*(uint64_t *)(addr)>>16)
-
-
-#endif /* __GENERAL_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/fm_ext.h.orig	2022-05-26 11:28:30.974977746 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/fm_ext.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,598 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-
-/**************************************************************************//**
- @File          fm_ext.h
-
- @Description   FM Application Programming Interface.
-*//***************************************************************************/
-#ifndef __FM_EXT
-#define __FM_EXT
-
-#include "error_ext.h"
-#include "std_ext.h"
-#include "dpaa_ext.h"
-
-
-/**************************************************************************//**
- @Group         lnx_usr_FM_grp Frame Manager API
-
- @Description   FM API functions, definitions and enums.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Group         lnx_usr_FM_lib_grp FM library
-
- @Description   FM API functions, definitions and enums
-
-                The FM module is the main driver module and is a mandatory module
-                for FM driver users. This module must be initialized first prior
-                to any other drivers modules.
-                The FM is a "singleton" module. It is responsible of the common
-                HW modules: FPM, DMA, common QMI and common BMI initializations and
-                run-time control routines. This module must be initialized always
-                when working with any of the FM modules.
-                NOTE - We assume that the FM library will be initialized only by core No. 0!
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   Enum for defining port types
-*//***************************************************************************/
-typedef enum e_FmPortType {
-    e_FM_PORT_TYPE_OH_OFFLINE_PARSING = 0,  /**< Offline parsing port */
-    e_FM_PORT_TYPE_RX,                      /**< 1G Rx port */
-    e_FM_PORT_TYPE_RX_10G,                  /**< 10G Rx port */
-    e_FM_PORT_TYPE_TX,                      /**< 1G Tx port */
-    e_FM_PORT_TYPE_TX_10G,                  /**< 10G Tx port */
-    e_FM_PORT_TYPE_DUMMY
-} e_FmPortType;
-
-/**************************************************************************//**
- @Description   Parse results memory layout
-*//***************************************************************************/
-typedef _Packed struct t_FmPrsResult {
-    volatile uint8_t     lpid;               /**< Logical port id */
-    volatile uint8_t     shimr;              /**< Shim header result  */
-    volatile uint16_t    l2r;                /**< Layer 2 result */
-    volatile uint16_t    l3r;                /**< Layer 3 result */
-    volatile uint8_t     l4r;                /**< Layer 4 result */
-    volatile uint8_t     cplan;              /**< Classification plan id */
-    volatile uint16_t    nxthdr;             /**< Next Header  */
-    volatile uint16_t    cksum;              /**< Running-sum */
-    volatile uint16_t    flags_frag_off;     /**< Flags & fragment-offset field of the last IP-header */
-    volatile uint8_t     route_type;         /**< Routing type field of a IPv6 routing extension header */
-    volatile uint8_t     rhp_ip_valid;       /**< Routing Extension Header Present; last bit is IP valid */
-    volatile uint8_t     shim_off[2];        /**< Shim offset */
-    volatile uint8_t     ip_pid_off;         /**< IP PID (last IP-proto) offset */
-    volatile uint8_t     eth_off;            /**< ETH offset */
-    volatile uint8_t     llc_snap_off;       /**< LLC_SNAP offset */
-    volatile uint8_t     vlan_off[2];        /**< VLAN offset */
-    volatile uint8_t     etype_off;          /**< ETYPE offset */
-    volatile uint8_t     pppoe_off;          /**< PPP offset */
-    volatile uint8_t     mpls_off[2];        /**< MPLS offset */
-    volatile uint8_t     ip_off[2];          /**< IP offset */
-    volatile uint8_t     gre_off;            /**< GRE offset */
-    volatile uint8_t     l4_off;             /**< Layer 4 offset */
-    volatile uint8_t     nxthdr_off;         /**< Parser end point */
-} _PackedType t_FmPrsResult;
-
-/**************************************************************************//**
- @Collection   FM Parser results
-*//***************************************************************************/
-#define FM_PR_L2_VLAN_STACK         0x00000100  /**< Parse Result: VLAN stack */
-#define FM_PR_L2_ETHERNET           0x00008000  /**< Parse Result: Ethernet*/
-#define FM_PR_L2_VLAN               0x00004000  /**< Parse Result: VLAN */
-#define FM_PR_L2_LLC_SNAP           0x00002000  /**< Parse Result: LLC_SNAP */
-#define FM_PR_L2_MPLS               0x00001000  /**< Parse Result: MPLS */
-#define FM_PR_L2_PPPoE              0x00000800  /**< Parse Result: PPPoE */
-/* @} */
-
-/**************************************************************************//**
- @Collection   FM Frame descriptor macros
-*//***************************************************************************/
-#define FM_FD_CMD_FCO                   0x80000000  /**< Frame queue Context Override */
-#define FM_FD_CMD_RPD                   0x40000000  /**< Read Prepended Data */
-#define FM_FD_CMD_UPD                   0x20000000  /**< Update Prepended Data */
-#define FM_FD_CMD_DTC                   0x10000000  /**< Do L4 Checksum */
-#define FM_FD_CMD_DCL4C                 0x10000000  /**< Didn't calculate L4 Checksum */
-#define FM_FD_CMD_CFQ                   0x00ffffff  /**< Confirmation Frame Queue */
-
-#define FM_FD_ERR_UNSUPPORTED_FORMAT    0x04000000  /**< Not for Rx-Port! Unsupported Format */
-#define FM_FD_ERR_LENGTH                0x02000000  /**< Not for Rx-Port! Length Error */
-#define FM_FD_ERR_DMA                   0x01000000  /**< DMA Data error */
-
-#define FM_FD_IPR                       0x00000001  /**< IPR frame (not error) */
-
-#define FM_FD_ERR_IPR_NCSP              (0x00100000 | FM_FD_IPR)    /**< IPR non-consistent-sp */
-#define FM_FD_ERR_IPR                   (0x00200000 | FM_FD_IPR)    /**< IPR error */
-#define FM_FD_ERR_IPR_TO                (0x00300000 | FM_FD_IPR)    /**< IPR timeout */
-
-#ifdef FM_CAPWAP_SUPPORT
-#define FM_FD_ERR_CRE                   0x00200000
-#define FM_FD_ERR_CHE                   0x00100000
-#endif /* FM_CAPWAP_SUPPORT */
-
-#define FM_FD_ERR_PHYSICAL              0x00080000  /**< Rx FIFO overflow, FCS error, code error, running disparity
-                                                         error (SGMII and TBI modes), FIFO parity error. PHY
-                                                         Sequence error, PHY error control character detected. */
-#define FM_FD_ERR_SIZE                  0x00040000  /**< Frame too long OR Frame size exceeds max_length_frame  */
-#define FM_FD_ERR_CLS_DISCARD           0x00020000  /**< classification discard */
-#define FM_FD_ERR_EXTRACTION            0x00008000  /**< Extract Out of Frame */
-#define FM_FD_ERR_NO_SCHEME             0x00004000  /**< No Scheme Selected */
-#define FM_FD_ERR_KEYSIZE_OVERFLOW      0x00002000  /**< Keysize Overflow */
-#define FM_FD_ERR_COLOR_RED             0x00000800  /**< Frame color is red */
-#define FM_FD_ERR_COLOR_YELLOW          0x00000400  /**< Frame color is yellow */
-#define FM_FD_ERR_ILL_PLCR              0x00000200  /**< Illegal Policer Profile selected */
-#define FM_FD_ERR_PLCR_FRAME_LEN        0x00000100  /**< Policer frame length error */
-#define FM_FD_ERR_PRS_TIMEOUT           0x00000080  /**< Parser Time out Exceed */
-#define FM_FD_ERR_PRS_ILL_INSTRUCT      0x00000040  /**< Invalid Soft Parser instruction */
-#define FM_FD_ERR_PRS_HDR_ERR           0x00000020  /**< Header error was identified during parsing */
-#define FM_FD_ERR_BLOCK_LIMIT_EXCEEDED  0x00000008  /**< Frame parsed beyind 256 first bytes */
-
-#define FM_FD_TX_STATUS_ERR_MASK        (FM_FD_ERR_UNSUPPORTED_FORMAT   | \
-                                         FM_FD_ERR_LENGTH               | \
-                                         FM_FD_ERR_DMA) /**< TX Error FD bits */
-
-#define FM_FD_RX_STATUS_ERR_MASK        (FM_FD_ERR_UNSUPPORTED_FORMAT   | \
-                                         FM_FD_ERR_LENGTH               | \
-                                         FM_FD_ERR_DMA                  | \
-                                         FM_FD_ERR_IPR                  | \
-                                         FM_FD_ERR_IPR_TO               | \
-                                         FM_FD_ERR_IPR_NCSP             | \
-                                         FM_FD_ERR_PHYSICAL             | \
-                                         FM_FD_ERR_SIZE                 | \
-                                         FM_FD_ERR_CLS_DISCARD          | \
-                                         FM_FD_ERR_COLOR_RED            | \
-                                         FM_FD_ERR_COLOR_YELLOW         | \
-                                         FM_FD_ERR_ILL_PLCR             | \
-                                         FM_FD_ERR_PLCR_FRAME_LEN       | \
-                                         FM_FD_ERR_EXTRACTION           | \
-                                         FM_FD_ERR_NO_SCHEME            | \
-                                         FM_FD_ERR_KEYSIZE_OVERFLOW     | \
-                                         FM_FD_ERR_PRS_TIMEOUT          | \
-                                         FM_FD_ERR_PRS_ILL_INSTRUCT     | \
-                                         FM_FD_ERR_PRS_HDR_ERR          | \
-                                         FM_FD_ERR_BLOCK_LIMIT_EXCEEDED) /**< RX Error FD bits */
-
-#define FM_FD_RX_STATUS_ERR_NON_FM      0x00400000  /**< non Frame-Manager error */
-/* @} */
-
-
-/**************************************************************************//**
- @Description   FM Exceptions
-*//***************************************************************************/
-typedef enum e_FmExceptions {
-    e_FM_EX_DMA_BUS_ERROR = 0,          /**< DMA bus error. */
-    e_FM_EX_DMA_READ_ECC,               /**< Read Buffer ECC error (Valid for FM rev < 6)*/
-    e_FM_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side (Valid for FM rev < 6)*/
-    e_FM_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side (Valid for FM rev < 6)*/
-    e_FM_EX_DMA_SINGLE_PORT_ECC,        /**< Single Port ECC error on FM side (Valid for FM rev > 6)*/
-    e_FM_EX_FPM_STALL_ON_TASKS,         /**< Stall of tasks on FPM */
-    e_FM_EX_FPM_SINGLE_ECC,             /**< Single ECC on FPM. */
-    e_FM_EX_FPM_DOUBLE_ECC,             /**< Double ECC error on FPM ram access */
-    e_FM_EX_QMI_SINGLE_ECC,             /**< Single ECC on QMI. */
-    e_FM_EX_QMI_DOUBLE_ECC,             /**< Double bit ECC occurred on QMI */
-    e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,/**< Dequeue from unknown port id */
-    e_FM_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
-    e_FM_EX_BMI_STORAGE_PROFILE_ECC,    /**< Storage Profile ECC Error */
-    e_FM_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
-    e_FM_EX_BMI_DISPATCH_RAM_ECC,       /**< Dispatch RAM ECC Error Enable */
-    e_FM_EX_IRAM_ECC,                   /**< Double bit ECC occurred on IRAM*/
-    e_FM_EX_MURAM_ECC                   /**< Double bit ECC occurred on MURAM*/
-} e_FmExceptions;
-
-/**************************************************************************//**
- @Description   Enum for defining port DMA swap mode
-*//***************************************************************************/
-typedef enum e_FmDmaSwapOption {
-    e_FM_DMA_NO_SWP,           /**< No swap, transfer data as is.*/
-    e_FM_DMA_SWP_PPC_LE,       /**< The transferred data should be swapped
-                                    in PowerPc Little Endian mode. */
-    e_FM_DMA_SWP_BE            /**< The transferred data should be swapped
-                                    in Big Endian mode */
-} e_FmDmaSwapOption;
-
-/**************************************************************************//**
- @Description   Enum for defining port DMA cache attributes
-*//***************************************************************************/
-typedef enum e_FmDmaCacheOption {
-    e_FM_DMA_NO_STASH = 0,     /**< Cacheable, no Allocate (No Stashing) */
-    e_FM_DMA_STASH = 1         /**< Cacheable and Allocate (Stashing on) */
-} e_FmDmaCacheOption;
-/**************************************************************************//**
- @Group         lnx_usr_FM_init_grp FM Initialization Unit
-
- @Description   FM Initialization Unit
-
-                Initialization Flow
-                Initialization of the FM Module will be carried out by the application
-                according to the following sequence:
-                -  Calling the configuration routine with basic parameters.
-                -  Calling the advance initialization routines to change driver's defaults.
-                -  Calling the initialization routine.
-
- @{
-*//***************************************************************************/
-
-t_Handle FM_Open(uint8_t id);
-void     FM_Close(t_Handle h_Fm);
-
-
-/**************************************************************************//**
- @Description   A structure for defining buffer prefix area content.
-*//***************************************************************************/
-typedef struct t_FmBufferPrefixContent {
-    uint16_t    privDataSize;       /**< Number of bytes to be left at the beginning
-                                         of the external buffer; Note that the private-area will
-                                         start from the base of the buffer address. */
-    bool        passPrsResult;      /**< TRUE to pass the parse result to/from the FM;
-                                         User may use FM_PORT_GetBufferPrsResult() in order to
-                                         get the parser-result from a buffer. */
-    bool        passTimeStamp;      /**< TRUE to pass the timeStamp to/from the FM
-                                         User may use FM_PORT_GetBufferTimeStamp() in order to
-                                         get the parser-result from a buffer. */
-    bool        passHashResult;     /**< TRUE to pass the KG hash result to/from the FM
-                                         User may use FM_PORT_GetBufferHashResult() in order to
-                                         get the parser-result from a buffer. */
-    bool        passAllOtherPCDInfo;/**< Add all other Internal-Context information:
-                                         AD, hash-result, key, etc. */
-    uint16_t    dataAlign;          /**< 0 to use driver's default alignment [64],
-                                         other value for selecting a data alignment (must be a power of 2);
-                                         if write optimization is used, must be >= 16. */
-    uint8_t     manipExtraSpace;    /**< Maximum extra size needed (insertion-size minus removal-size);
-                                         Note that this field impacts the size of the buffer-prefix
-                                         (i.e. it pushes the data offset);
-                                         This field is irrelevant if DPAA_VERSION==10 */
-} t_FmBufferPrefixContent;
-
-/**************************************************************************//**
- @Description   A structure of information about each of the external
-                buffer pools used by a port or storage-profile.
-*//***************************************************************************/
-typedef struct t_FmExtPoolParams {
-    uint8_t                 id;     /**< External buffer pool id */
-    uint16_t                size;   /**< External buffer pool buffer size */
-} t_FmExtPoolParams;
-
-/**************************************************************************//**
- @Description   A structure for informing the driver about the external
-                buffer pools allocated in the BM and used by a port or a
-                storage-profile.
-*//***************************************************************************/
-typedef struct t_FmExtPools {
-    uint8_t                 numOfPoolsUsed;     /**< Number of pools use by this port */
-    t_FmExtPoolParams       extBufPool[FM_PORT_MAX_NUM_OF_EXT_POOLS];
-                                                /**< Parameters for each port */
-} t_FmExtPools;
-
-/**************************************************************************//**
- @Description   A structure for defining backup BM Pools.
-*//***************************************************************************/
-typedef struct t_FmBackupBmPools {
-    uint8_t     numOfBackupPools;       /**< Number of BM backup pools -
-                                             must be smaller than the total number of
-                                             pools defined for the specified port.*/
-    uint8_t     poolIds[FM_PORT_MAX_NUM_OF_EXT_POOLS];
-                                        /**< numOfBackupPools pool id's, specifying which
-                                             pools should be used only as backup. Pool
-                                             id's specified here must be a subset of the
-                                             pools used by the specified port.*/
-} t_FmBackupBmPools;
-
-/**************************************************************************//**
- @Description   A structure for defining BM pool depletion criteria
-*//***************************************************************************/
-typedef struct t_FmBufPoolDepletion {
-    bool        poolsGrpModeEnable;                 /**< select mode in which pause frames will be sent after
-                                                         a number of pools (all together!) are depleted */
-    uint8_t     numOfPools;                         /**< the number of depleted pools that will invoke
-                                                         pause frames transmission. */
-    bool        poolsToConsider[BM_MAX_NUM_OF_POOLS];
-                                                    /**< For each pool, TRUE if it should be considered for
-                                                         depletion (Note - this pool must be used by this port!). */
-    bool        singlePoolModeEnable;               /**< select mode in which pause frames will be sent after
-                                                         a single-pool is depleted; */
-    bool        poolsToConsiderForSingleMode[BM_MAX_NUM_OF_POOLS];
-                                                    /**< For each pool, TRUE if it should be considered for
-                                                         depletion (Note - this pool must be used by this port!) */
-#if (DPAA_VERSION >= 11)
-    bool        pfcPrioritiesEn[FM_MAX_NUM_OF_PFC_PRIORITIES];
-                                                    /**< This field is used by the MAC as the Priority Enable Vector in the PFC frame which is transmitted */
-#endif /* (DPAA_VERSION >= 11) */
-} t_FmBufPoolDepletion;
-
-
-/** @} */ /* end of lnx_usr_FM_init_grp group */
-
-
-/**************************************************************************//**
- @Group         lnx_usr_FM_runtime_control_grp FM Runtime Control Unit
-
- @Description   FM Runtime control unit API functions, definitions and enums.
-                The FM driver provides a set of control routines.
-                These routines may only be called after the module was fully
-                initialized (both configuration and initialization routines were
-                called). They are typically used to get information from hardware
-                (status, counters/statistics, revision etc.), to modify a current
-                state or to force/enable a required action. Run-time control may
-                be called whenever necessary and as many times as needed.
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Collection   General FM defines.
-*//***************************************************************************/
-#define FM_MAX_NUM_OF_VALID_PORTS   (FM_MAX_NUM_OF_OH_PORTS +       \
-                                     FM_MAX_NUM_OF_1G_RX_PORTS +    \
-                                     FM_MAX_NUM_OF_10G_RX_PORTS +   \
-                                     FM_MAX_NUM_OF_1G_TX_PORTS +    \
-                                     FM_MAX_NUM_OF_10G_TX_PORTS)      /**< Number of available FM ports */
-/* @} */
-
-/**************************************************************************//**
- @Description   A structure for Port bandwidth requirement. Port is identified
-                by type and relative id.
-*//***************************************************************************/
-typedef struct t_FmPortBandwidth {
-    e_FmPortType        type;           /**< FM port type */
-    uint8_t             relativePortId; /**< Type relative port id */
-    uint8_t             bandwidth;      /**< bandwidth - (in term of percents) */
-} t_FmPortBandwidth;
-
-/**************************************************************************//**
- @Description   A Structure containing an array of Port bandwidth requirements.
-                The user should state the ports requiring bandwidth in terms of
-                percentage - i.e. all port's bandwidths in the array must add
-                up to 100.
-*//***************************************************************************/
-typedef struct t_FmPortsBandwidthParams {
-    uint8_t             numOfPorts;         /**< The number of relevant ports, which is the
-                                                 number of valid entries in the array below */
-    t_FmPortBandwidth   portsBandwidths[FM_MAX_NUM_OF_VALID_PORTS];
-                                            /**< for each port, it's bandwidth (all port's
-                                                 bandwidths must add up to 100.*/
-} t_FmPortsBandwidthParams;
-
-/**************************************************************************//**
- @Description   Enum for defining FM counters
-*//***************************************************************************/
-typedef enum e_FmCounters {
-    e_FM_COUNTERS_ENQ_TOTAL_FRAME = 0,              /**< QMI total enqueued frames counter */
-    e_FM_COUNTERS_DEQ_TOTAL_FRAME,                  /**< QMI total dequeued frames counter */
-    e_FM_COUNTERS_DEQ_0,                            /**< QMI 0 frames from QMan counter */
-    e_FM_COUNTERS_DEQ_1,                            /**< QMI 1 frames from QMan counter */
-    e_FM_COUNTERS_DEQ_2,                            /**< QMI 2 frames from QMan counter */
-    e_FM_COUNTERS_DEQ_3,                            /**< QMI 3 frames from QMan counter */
-    e_FM_COUNTERS_DEQ_FROM_DEFAULT,                 /**< QMI dequeue from default queue counter */
-    e_FM_COUNTERS_DEQ_FROM_CONTEXT,                 /**< QMI dequeue from FQ context counter */
-    e_FM_COUNTERS_DEQ_FROM_FD,                      /**< QMI dequeue from FD command field counter */
-    e_FM_COUNTERS_DEQ_CONFIRM                       /**< QMI dequeue confirm counter */
-} e_FmCounters;
-
-/**************************************************************************//**
- @Description   A structure for returning FM revision information
-*//***************************************************************************/
-typedef struct t_FmRevisionInfo {
-    uint8_t         majorRev;               /**< Major revision */
-    uint8_t         minorRev;               /**< Minor revision */
-} t_FmRevisionInfo;
-
-/**************************************************************************//**
- @Description   A structure for returning FM ctrl code revision information
-*//***************************************************************************/
-typedef struct t_FmCtrlCodeRevisionInfo {
-    uint16_t        packageRev;             /**< Package revision */
-    uint8_t         majorRev;               /**< Major revision */
-    uint8_t         minorRev;               /**< Minor revision */
-} t_FmCtrlCodeRevisionInfo;
-
-/**************************************************************************//**
- @Description   A Structure for obtaining FM controller monitor values
-*//***************************************************************************/
-typedef struct t_FmCtrlMon {
-    uint8_t percentCnt[1];          /**< Percentage value */
-} t_FmCtrlMon;
-
-/**************************************************************************//**
- @Function      FM_SetPortsBandwidth
-
- @Description   Sets relative weights between ports when accessing common resources.
-
- @Param[in]     h_Fm                A handle to an FM Module.
- @Param[in]     p_PortsBandwidth    A structure of ports bandwidths in percentage, i.e.
-                                    total must equal 100.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBandwidth);
-
-/**************************************************************************//**
- @Function      FM_GetRevision
-
- @Description   Returns the FM revision
-
- @Param[in]     h_Fm                A handle to an FM Module.
- @Param[out]    p_FmRevisionInfo    A structure of revision information parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-t_Error  FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo);
-
-/**************************************************************************//**
- @Function      FM_GetFmanCtrlCodeRevision
-
- @Description   Returns the Fman controller code revision
-		(Not implemented in fm-lib just yet!)
-
- @Param[in]     h_Fm                A handle to an FM Module.
- @Param[out]    p_RevisionInfo      A structure of revision information parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-t_Error FM_GetFmanCtrlCodeRevision(t_Handle h_Fm, t_FmCtrlCodeRevisionInfo *p_RevisionInfo);
-
-/**************************************************************************//**
- @Function      FM_GetCounter
-
- @Description   Reads one of the FM counters.
-
- @Param[in]     h_Fm        A handle to an FM Module.
- @Param[in]     counter     The requested counter.
-
- @Return        Counter's current value.
-
- @Cautions      Allowed only following FM_Init().
-                Note that it is user's responsibility to call this routine only
-                for enabled counters, and there will be no indication if a
-                disabled counter is accessed.
-*//***************************************************************************/
-uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter);
-
-/**************************************************************************//**
- @Function      FM_ModifyCounter
-
- @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
-
- @Param[in]     h_Fm        A handle to an FM Module.
- @Param[in]     counter     The requested counter.
- @Param[in]     val         The requested value to be written into the counter.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val);
-
-/**************************************************************************//**
- @Function      FM_CtrlMonStart
-
- @Description   Start monitoring utilization of all available FM controllers.
-
-                In order to obtain FM controllers utilization the following sequence
-                should be used:
-                -# FM_CtrlMonStart()
-                -# FM_CtrlMonStop()
-                -# FM_CtrlMonGetCounters() - issued for each FM controller
-
- @Param[in]     h_Fm            A handle to an FM Module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID).
-*//***************************************************************************/
-t_Error FM_CtrlMonStart(t_Handle h_Fm);
-
-/**************************************************************************//**
- @Function      FM_CtrlMonStop
-
- @Description   Stop monitoring utilization of all available FM controllers.
-
-                In order to obtain FM controllers utilization the following sequence
-                should be used:
-                -# FM_CtrlMonStart()
-                -# FM_CtrlMonStop()
-                -# FM_CtrlMonGetCounters() - issued for each FM controller
-
- @Param[in]     h_Fm            A handle to an FM Module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID).
-*//***************************************************************************/
-t_Error FM_CtrlMonStop(t_Handle h_Fm);
-
-/**************************************************************************//**
- @Function      FM_CtrlMonGetCounters
-
- @Description   Obtain FM controller utilization parameters.
-
-                In order to obtain FM controllers utilization the following sequence
-                should be used:
-                -# FM_CtrlMonStart()
-                -# FM_CtrlMonStop()
-                -# FM_CtrlMonGetCounters() - issued for each FM controller
-
- @Param[in]     h_Fm            A handle to an FM Module.
- @Param[in]     fmCtrlIndex     FM Controller index for that utilization results
-                                are requested.
- @Param[in]     p_Mon           Pointer to utilization results structure.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID).
-*//***************************************************************************/
-t_Error FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p_Mon);
-
-
-/**************************************************************************//*
- @Function      FM_ForceIntr
-
- @Description   Causes an interrupt event on the requested source.
-
- @Param[in]     h_Fm            A handle to an FM Module.
- @Param[in]     exception       An exception to be forced.
-
- @Return        E_OK on success; Error code if the exception is not enabled,
-                or is not able to create interrupt.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception);
-
-/** @} */ /* end of lnx_usr_FM_runtime_control_grp group */
-/** @} */ /* end of lnx_usr_FM_lib_grp group */
-/** @} */ /* end of lnx_usr_FM_grp group */
-
-#ifdef NCSW_BACKWARD_COMPATIBLE_API
-typedef t_FmBackupBmPools           t_FmPortBackupBmPools;
-typedef t_FmBufPoolDepletion        t_FmPortBufPoolDepletion;
-#define e_FM_EX_BMI_PIPELINE_ECC    e_FM_EX_BMI_STORAGE_PROFILE_ECC
-#endif /* NCSW_BACKWARD_COMPATIBLE_API */
-
-#endif /* __FM_EXT */
--- fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/fm_mac_ext.h.orig	2022-05-26 11:28:30.974977746 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/fm_mac_ext.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,819 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-/**************************************************************************//**
- @File          fm_mac_ext.h
-
- @Description   FM MAC ...
-*//***************************************************************************/
-#ifndef __FM_MAC_EXT_H
-#define __FM_MAC_EXT_H
-
-#include "std_ext.h"
-#include "enet_ext.h"
-
-
-/**************************************************************************//**
-
- @Group         FM_grp Frame Manager API
-
- @Description   FM API functions, definitions and enums
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Group         FM_mac_grp FM MAC
-
- @Description   FM MAC API functions, definitions and enums
-
- @{
-*//***************************************************************************/
-
-#define FM_MAC_NO_PFC   0xff
-
-
-/**************************************************************************//**
- @Description   FM MAC Exceptions
-*//***************************************************************************/
-typedef enum e_FmMacExceptions {
-    e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO = 0                     /**< 10GEC MDIO scan event interrupt */
-   ,e_FM_MAC_EX_10G_MDIO_CMD_CMPL                               /**< 10GEC MDIO command completion interrupt */
-   ,e_FM_MAC_EX_10G_REM_FAULT                                   /**< 10GEC, mEMAC Remote fault interrupt */
-   ,e_FM_MAC_EX_10G_LOC_FAULT                                   /**< 10GEC, mEMAC Local fault interrupt */
-   ,e_FM_MAC_EX_10G_1TX_ECC_ER                                  /**< 10GEC, mEMAC Transmit frame ECC error interrupt */
-   ,e_FM_MAC_EX_10G_TX_FIFO_UNFL                                /**< 10GEC, mEMAC Transmit FIFO underflow interrupt */
-   ,e_FM_MAC_EX_10G_TX_FIFO_OVFL                                /**< 10GEC, mEMAC Transmit FIFO overflow interrupt */
-   ,e_FM_MAC_EX_10G_TX_ER                                       /**< 10GEC Transmit frame error interrupt */
-   ,e_FM_MAC_EX_10G_RX_FIFO_OVFL                                /**< 10GEC, mEMAC Receive FIFO overflow interrupt */
-   ,e_FM_MAC_EX_10G_RX_ECC_ER                                   /**< 10GEC, mEMAC Receive frame ECC error interrupt */
-   ,e_FM_MAC_EX_10G_RX_JAB_FRM                                  /**< 10GEC Receive jabber frame interrupt */
-   ,e_FM_MAC_EX_10G_RX_OVRSZ_FRM                                /**< 10GEC Receive oversized frame interrupt */
-   ,e_FM_MAC_EX_10G_RX_RUNT_FRM                                 /**< 10GEC Receive runt frame interrupt */
-   ,e_FM_MAC_EX_10G_RX_FRAG_FRM                                 /**< 10GEC Receive fragment frame interrupt */
-   ,e_FM_MAC_EX_10G_RX_LEN_ER                                   /**< 10GEC Receive payload length error interrupt */
-   ,e_FM_MAC_EX_10G_RX_CRC_ER                                   /**< 10GEC Receive CRC error interrupt */
-   ,e_FM_MAC_EX_10G_RX_ALIGN_ER                                 /**< 10GEC Receive alignment error interrupt */
-   ,e_FM_MAC_EX_1G_BAB_RX                                       /**< dTSEC Babbling receive error */
-   ,e_FM_MAC_EX_1G_RX_CTL                                       /**< dTSEC Receive control (pause frame) interrupt */
-   ,e_FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET                      /**< dTSEC Graceful transmit stop complete */
-   ,e_FM_MAC_EX_1G_BAB_TX                                       /**< dTSEC Babbling transmit error */
-   ,e_FM_MAC_EX_1G_TX_CTL                                       /**< dTSEC Transmit control (pause frame) interrupt */
-   ,e_FM_MAC_EX_1G_TX_ERR                                       /**< dTSEC Transmit error */
-   ,e_FM_MAC_EX_1G_LATE_COL                                     /**< dTSEC Late collision */
-   ,e_FM_MAC_EX_1G_COL_RET_LMT                                  /**< dTSEC Collision retry limit */
-   ,e_FM_MAC_EX_1G_TX_FIFO_UNDRN                                /**< dTSEC Transmit FIFO underrun */
-   ,e_FM_MAC_EX_1G_MAG_PCKT                                     /**< dTSEC Magic Packet detection */
-   ,e_FM_MAC_EX_1G_MII_MNG_RD_COMPLET                           /**< dTSEC MII management read completion */
-   ,e_FM_MAC_EX_1G_MII_MNG_WR_COMPLET                           /**< dTSEC MII management write completion */
-   ,e_FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET                      /**< dTSEC Graceful receive stop complete */
-   ,e_FM_MAC_EX_1G_TX_DATA_ERR                                  /**< dTSEC Internal data error on transmit */
-   ,e_FM_MAC_EX_1G_RX_DATA_ERR                                  /**< dTSEC Internal data error on receive */
-   ,e_FM_MAC_EX_1G_1588_TS_RX_ERR                               /**< dTSEC Time-Stamp Receive Error */
-   ,e_FM_MAC_EX_1G_RX_MIB_CNT_OVFL                              /**< dTSEC MIB counter overflow */
-} e_FmMacExceptions;
-
-/**************************************************************************//**
- @Description   TM MAC statistics level
-*//***************************************************************************/
-typedef enum e_FmMacStatisticsLevel {
-    e_FM_MAC_NONE_STATISTICS = 0,       /**< No statistics */
-    e_FM_MAC_PARTIAL_STATISTICS,        /**< Only error counters are available; Optimized for performance */
-    e_FM_MAC_FULL_STATISTICS            /**< All counters available; Not optimized for performance */
-} e_FmMacStatisticsLevel;
-
-
-#if (DPAA_VERSION >= 11)
-/**************************************************************************//**
- @Description   Priority Flow Control Parameters
-*//***************************************************************************/
-typedef struct t_FmMacPfcParams {
-    bool        pfcEnable;                                      /**< Enable/Disable PFC */
-
-    uint16_t    pauseQuanta[FM_MAX_NUM_OF_PFC_PRIORITIES];      /**< Pause Quanta per priority to be sent in a pause frame. Each quanta represents a 512 bit-times*/
-
-    uint16_t    pauseThresholdQuanta[FM_MAX_NUM_OF_PFC_PRIORITIES];/**< Pause threshold per priority, when timer passes this threshold time a PFC frames is sent again if the port is still congested or BM pool in depletion*/
-
-
-} t_FmMacPfcParams;
-#endif /* (DPAA_VERSION >= 11) */
-
-/**************************************************************************//**
- @Function      t_FmMacExceptionCallback
-
- @Description   Fm Mac Exception Callback from FM MAC to the user
-
- @Param[in]     h_App             - Handle to the upper layer handler
-
- @Param[in]     exceptions        - The exception that occurred
-
- @Return        void.
-*//***************************************************************************/
-typedef void (t_FmMacExceptionCallback)(t_Handle h_App, e_FmMacExceptions exceptions);
-
-
-/**************************************************************************//**
- @Description   TM MAC statistics rfc3635
-*//***************************************************************************/
-typedef struct t_FmMacStatistics {
-/* RMON */
-    uint64_t  eStatPkts64;             /**< r-10G tr-DT 64 byte frame counter */
-    uint64_t  eStatPkts65to127;        /**< r-10G 65 to 127 byte frame counter */
-    uint64_t  eStatPkts128to255;       /**< r-10G 128 to 255 byte frame counter */
-    uint64_t  eStatPkts256to511;       /**< r-10G 256 to 511 byte frame counter */
-    uint64_t  eStatPkts512to1023;      /**< r-10G 512 to 1023 byte frame counter */
-    uint64_t  eStatPkts1024to1518;     /**< r-10G 1024 to 1518 byte frame counter */
-    uint64_t  eStatPkts1519to1522;     /**< r-10G 1519 to 1522 byte good frame count */
-/* */
-    uint64_t  eStatFragments;          /**< Total number of packets that were less than 64 octets long with a wrong CRC.*/
-    uint64_t  eStatJabbers;            /**< Total number of packets longer than valid maximum length octets */
-    uint64_t  eStatsDropEvents;        /**< number of dropped packets due to internal errors of the MAC Client (during recieve). */
-    uint64_t  eStatCRCAlignErrors;     /**< Incremented when frames of correct length but with CRC error are received.*/
-    uint64_t  eStatUndersizePkts;      /**< Incremented for frames under 64 bytes with a valid FCS and otherwise well formed;
-                                            This count does not include range length errors */
-    uint64_t  eStatOversizePkts;       /**< Incremented for frames which exceed 1518 (non VLAN) or 1522 (VLAN) and contains
-                                            a valid FCS and otherwise well formed */
-/* Pause */
-    uint64_t  teStatPause;             /**< Pause MAC Control received */
-    uint64_t  reStatPause;             /**< Pause MAC Control sent */
-/* MIB II */
-    uint64_t  ifInOctets;              /**< Total number of byte received. */
-    uint64_t  ifInPkts;                /**< Total number of packets received.*/
-    uint64_t  ifInUcastPkts;           /**< Total number of unicast frame received;
-                                            NOTE: this counter is not supported on dTSEC MAC */
-    uint64_t  ifInMcastPkts;           /**< Total number of multicast frame received*/
-    uint64_t  ifInBcastPkts;           /**< Total number of broadcast frame received */
-    uint64_t  ifInDiscards;            /**< Frames received, but discarded due to problems within the MAC RX. */
-    uint64_t  ifInErrors;              /**< Number of frames received with error:
-                                               - FIFO Overflow Error
-                                               - CRC Error
-                                               - Frame Too Long Error
-                                               - Alignment Error
-                                               - The dedicated Error Code (0xfe, not a code error) was received */
-    uint64_t  ifOutOctets;             /**< Total number of byte sent. */
-    uint64_t  ifOutPkts;               /**< Total number of packets sent .*/
-    uint64_t  ifOutUcastPkts;          /**< Total number of unicast frame sent;
-                                            NOTE: this counter is not supported on dTSEC MAC */
-    uint64_t  ifOutMcastPkts;          /**< Total number of multicast frame sent */
-    uint64_t  ifOutBcastPkts;          /**< Total number of multicast frame sent */
-    uint64_t  ifOutDiscards;           /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
-    uint64_t  ifOutErrors;             /**< Number of frames transmitted with error:
-                                               - FIFO Overflow Error
-                                               - FIFO Underflow Error
-                                               - Other */
-} t_FmMacStatistics;
-
-
-/**************************************************************************//**
- @Group         FM_mac_init_grp FM MAC Initialization Unit
-
- @Description   FM MAC Initialization Unit
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   FM MAC config input
-*//***************************************************************************/
-typedef struct t_FmMacParams {
-    uintptr_t                   baseAddr;           /**< Base of memory mapped FM MAC registers */
-    t_EnetAddr                  addr;               /**< MAC address of device; First octet is sent first */
-    uint8_t                     macId;              /**< MAC ID <dTSEC 0-3> <10G-MAC 0>      */
-    e_EnetMode                  enetMode;           /**< Ethernet operation mode (MAC-PHY interface and speed);
-                                                         Note that the speed should indicate the maximum rate that
-                                                         this MAC should support rather than the actuall speed;
-                                                         i.e. user should use the FM_MAC_AdjustLink() routine to
-                                                         provide accurate speed;
-                                                         In addition, in mEMAC, in case where user is using the higher MACs
-                                                         (i.e. the MACs that should support 10G), user should pass here
-                                                         speed=10000 even if the interface is not allowing that (e.g. SGMII). */
-    t_Handle                    h_Fm;               /**< A handle to the FM object this port related to */
-    int                         mdioIrq;            /**< MDIO exceptions interrupt source - not valid for all
-                                                         MACs; MUST be set to 'NO_IRQ' for MACs that don't have
-                                                         mdio-irq, or for polling */
-    t_FmMacExceptionCallback    *f_Event;           /**< MDIO Events Callback Routine         */
-    t_FmMacExceptionCallback    *f_Exception;       /**< Exception Callback Routine         */
-    t_Handle                    h_App;              /**< A handle to an application layer object; This handle will
-                                                         be passed by the driver upon calling the above callbacks */
-} t_FmMacParams;
-
-
-/**************************************************************************//**
- @Function      FM_MAC_Config
-
- @Description   Creates descriptor for the FM MAC module.
-
-                The routine returns a handle (descriptor) to the FM MAC object.
-                This descriptor must be passed as first parameter to all other
-                FM MAC function calls.
-
-                No actual initialization or configuration of FM MAC hardware is
-                done by this routine.
-
- @Param[in]     p_FmMacParam   - Pointer to data structure of parameters
-
- @Retval        Handle to FM MAC object, or NULL for Failure.
-*//***************************************************************************/
-t_Handle FM_MAC_Config(t_FmMacParams *p_FmMacParam);
-
-/**************************************************************************//**
- @Function      FM_MAC_Init
-
- @Description   Initializes the FM MAC module
-
- @Param[in]     h_FmMac - FM module descriptor
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error  FM_MAC_Init(t_Handle h_FmMac);
-
-/**************************************************************************//**
- @Function      FM_Free
-
- @Description   Frees all resources that were assigned to FM MAC module.
-
-                Calling this routine invalidates the descriptor.
-
- @Param[in]     h_FmMac - FM module descriptor
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error  FM_MAC_Free(t_Handle h_FmMac);
-
-
-/**************************************************************************//**
- @Group         FM_mac_advanced_init_grp    FM MAC Advanced Configuration Unit
-
- @Description   Configuration functions used to change default values.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Function      FM_MAC_ConfigResetOnInit
-
- @Description   Tell the driver whether to reset the FM MAC before initialization or
-                not. It changes the default configuration [FALSE].
-
- @Param[in]     h_FmMac    A handle to a FM MAC Module.
- @Param[in]     enable     When TRUE, FM will be reset before any initialization.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_ConfigResetOnInit(t_Handle h_FmMac, bool enable);
-
-/**************************************************************************//**
- @Function      FM_MAC_ConfigLoopback
-
- @Description   Enable/Disable internal loopback mode
-
- @Param[in]     h_FmMac    A handle to a FM MAC Module.
- @Param[in]     enable     TRUE to enable or FALSE to disable.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_ConfigLoopback(t_Handle h_FmMac, bool enable);
-
-/**************************************************************************//**
- @Function      FM_MAC_ConfigMaxFrameLength
-
- @Description   Setup maximum Rx Frame Length (in 1G MAC, effects also Tx)
-
- @Param[in]     h_FmMac    A handle to a FM MAC Module.
- @Param[in]     newVal     MAX Frame length
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_ConfigMaxFrameLength(t_Handle h_FmMac, uint16_t newVal);
-
-/**************************************************************************//**
- @Function      FM_MAC_ConfigWan
-
- @Description   ENABLE WAN mode in 10G-MAC
-
- @Param[in]     h_FmMac    A handle to a FM MAC Module.
- @Param[in]     enable     TRUE to enable or FALSE to disable.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_ConfigWan(t_Handle h_FmMac, bool enable);
-
-/**************************************************************************//**
- @Function      FM_MAC_ConfigPadAndCrc
-
- @Description   Config PAD and CRC mode
-
- @Param[in]     h_FmMac    A handle to a FM MAC Module.
- @Param[in]     enable     TRUE to enable or FALSE to disable.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
-                Not supported on 10G-MAC (i.e. CRC & PAD are added automatically
-                by HW); on mEMAC, this routine supports only PAD (i.e. CRC is
-                added automatically by HW).
-*//***************************************************************************/
-t_Error FM_MAC_ConfigPadAndCrc(t_Handle h_FmMac, bool enable);
-
-/**************************************************************************//**
- @Function      FM_MAC_ConfigHalfDuplex
-
- @Description   Config Half Duplex Mode
-
- @Param[in]     h_FmMac    A handle to a FM MAC Module.
- @Param[in]     enable     TRUE to enable or FALSE to disable.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_ConfigHalfDuplex(t_Handle h_FmMac, bool enable);
-
-/**************************************************************************//**
- @Function      FM_MAC_ConfigTbiPhyAddr
-
- @Description   Configures the address of internal TBI PHY.
-
- @Param[in]     h_FmMac    A handle to a FM MAC Module.
- @Param[in]     newVal     TBI PHY address (1-31).
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_ConfigTbiPhyAddr(t_Handle h_FmMac, uint8_t newVal);
-
-/**************************************************************************//**
- @Function      FM_MAC_ConfigLengthCheck
-
- @Description   Configure the frame length checking.
-
- @Param[in]     h_FmMac    A handle to a FM MAC Module.
- @Param[in]     enable     TRUE to enable or FALSE to disable.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_ConfigLengthCheck(t_Handle h_FmMac, bool enable);
-
-/**************************************************************************//**
- @Function      FM_MAC_ConfigException
-
- @Description   Change Exception selection from default
-
- @Param[in]     h_FmMac         A handle to a FM MAC Module.
- @Param[in]     ex              Type of the desired exceptions
- @Param[in]     enable          TRUE to enable the specified exception, FALSE to disable it.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_ConfigException(t_Handle h_FmMac, e_FmMacExceptions ex, bool enable);
-
-#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-t_Error FM_MAC_ConfigSkipFman11Workaround (t_Handle h_FmMac);
-#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
-/** @} */ /* end of FM_mac_advanced_init_grp group */
-/** @} */ /* end of FM_mac_init_grp group */
-
-
-/**************************************************************************//**
- @Group         FM_mac_runtime_control_grp FM MAC Runtime Control Unit
-
- @Description   FM MAC Runtime control unit API functions, definitions and enums.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Function      FM_MAC_Enable
-
- @Description   Enable the MAC
-
- @Param[in]     h_FmMac    A handle to a FM MAC Module.
- @Param[in]     mode       Mode of operation (RX, TX, Both)
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_Enable(t_Handle h_FmMac,  e_CommMode mode);
-
-/**************************************************************************//**
- @Function      FM_MAC_Disable
-
- @Description   DISABLE the MAC
-
- @Param[in]     h_FmMac    A handle to a FM MAC Module.
- @Param[in]     mode       Define what part to Disable (RX,  TX or BOTH)
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_Disable(t_Handle h_FmMac, e_CommMode mode);
-
-/**************************************************************************//**
- @Function      FM_MAC_Enable1588TimeStamp
-
- @Description   Enables the TSU operation.
-
- @Param[in]     h_Fm   - Handle to the PTP as returned from the FM_MAC_PtpConfig.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_Enable1588TimeStamp(t_Handle h_Fm);
-
-/**************************************************************************//**
- @Function      FM_MAC_Disable1588TimeStamp
-
- @Description   Disables the TSU operation.
-
- @Param[in]     h_Fm   - Handle to the PTP as returned from the FM_MAC_PtpConfig.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_Disable1588TimeStamp(t_Handle h_Fm);
-
-/**************************************************************************//**
- @Function      FM_MAC_SetTxAutoPauseFrames
-
- @Description   Enable/Disable transmission of Pause-Frames.
-                The routine changes the default configuration [0xf000].
-
- @Param[in]     h_FmMac       -  A handle to a FM MAC Module.
- @Param[in]     pauseTime     -  Pause quanta value used with transmitted pause frames.
-                                 Each quanta represents a 512 bit-times; Note that '0'
-                                 as an input here will be used as disabling the
-                                 transmission of the pause-frames.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_SetTxAutoPauseFrames(t_Handle h_FmMac,
-                                    uint16_t pauseTime);
-
- /**************************************************************************//**
- @Function      FM_MAC_SetTxPauseFrames
-
- @Description   Enable/Disable transmission of Pause-Frames.
-                The routine changes the default configuration:
-                pause-time - [0xf000]
-                threshold-time - [0]
-
- @Param[in]     h_FmMac       -  A handle to a FM MAC Module.
- @Param[in]     priority      -  the PFC class of service; use 'FM_MAC_NO_PFC'
-                                 to indicate legacy pause support (i.e. no PFC).
- @Param[in]     pauseTime     -  Pause quanta value used with transmitted pause frames.
-                                 Each quanta represents a 512 bit-times;
-                                 Note that '0' as an input here will be used as disabling the
-                                 transmission of the pause-frames.
- @Param[in]     threshTime    -  Pause Threshold equanta value used by the MAC to retransmit pause frame.
-                                 if the situation causing a pause frame to be sent didn't finish when the timer
-                                 reached the threshold quanta, the MAC will retransmit the pause frame.
-                                 Each quanta represents a 512 bit-times.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Init().
-                PFC is supported only on new mEMAC; i.e. in MACs that don't have
-                PFC support (10G-MAC and dTSEC), user should use 'FM_MAC_NO_PFC'
-                in the 'priority' field.
-*//***************************************************************************/
-t_Error FM_MAC_SetTxPauseFrames(t_Handle h_FmMac,
-                                uint8_t  priority,
-                                uint16_t pauseTime,
-                                uint16_t threshTime);
-
-/**************************************************************************//**
- @Function      FM_MAC_SetRxIgnorePauseFrames
-
- @Description   Enable/Disable ignoring of Pause-Frames.
-
- @Param[in]     h_FmMac    - A handle to a FM MAC Module.
- @Param[in]     en         - boolean indicates whether to ignore the incoming pause
-                             frames or not.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_SetRxIgnorePauseFrames(t_Handle h_FmMac, bool en);
-
-/**************************************************************************//**
- @Function      FM_MAC_ResetCounters
-
- @Description   reset all statistics counters
-
- @Param[in]     h_FmMac    - A handle to a FM MAC Module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_ResetCounters(t_Handle h_FmMac);
-
-/**************************************************************************//**
- @Function      FM_MAC_SetException
-
- @Description   Enable/Disable a specific Exception
-
- @Param[in]     h_FmMac        - A handle to a FM MAC Module.
- @Param[in]     ex             - Type of the desired exceptions
- @Param[in]     enable         - TRUE to enable the specified exception, FALSE to disable it.
-
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_SetException(t_Handle h_FmMac, e_FmMacExceptions ex, bool enable);
-
-/**************************************************************************//**
- @Function      FM_MAC_SetStatistics
-
- @Description   Define Statistics level.
-                Where applicable, the routine also enables the MIB counters
-                overflow interrupt in order to keep counters accurate
-                and account for overflows.
-                This routine is relevant only for dTSEC.
-
- @Param[in]     h_FmMac         - A handle to a FM MAC Module.
- @Param[in]     statisticsLevel - Full statistics level provides all standard counters but may
-                                  reduce performance. Partial statistics provides only special
-                                  event counters (errors etc.). If selected, regular counters (such as
-                                  byte/packet) will be invalid and will return -1.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_SetStatistics(t_Handle h_FmMac, e_FmMacStatisticsLevel statisticsLevel);
-
-/**************************************************************************//**
- @Function      FM_MAC_GetStatistics
-
- @Description   get all statistics counters
-
- @Param[in]     h_FmMac       -  A handle to a FM MAC Module.
- @Param[in]     p_Statistics  -  Structure with statistics
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-t_Error FM_MAC_GetStatistics(t_Handle h_FmMac, t_FmMacStatistics *p_Statistics);
-
-/**************************************************************************//**
- @Function      FM_MAC_ModifyMacAddr
-
- @Description   Replace the main MAC Address
-
- @Param[in]     h_FmMac     -   A handle to a FM Module.
- @Param[in]     p_EnetAddr  -   Ethernet Mac address
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only after FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_ModifyMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
-
-/**************************************************************************//**
- @Function      FM_MAC_AddHashMacAddr
-
- @Description   Add an Address to the hash table. This is for filter purpose only.
-
- @Param[in]     h_FmMac     -   A handle to a FM Module.
- @Param[in]     p_EnetAddr  -   Ethernet Mac address
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Init(). It is a filter only address.
- @Cautions      Some address need to be filterd out in upper FM blocks.
-*//***************************************************************************/
-t_Error FM_MAC_AddHashMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
-
-/**************************************************************************//**
- @Function      FM_MAC_RemoveHashMacAddr
-
- @Description   Delete an Address to the hash table. This is for filter purpose only.
-
- @Param[in]     h_FmMac     -   A handle to a FM Module.
- @Param[in]     p_EnetAddr  -   Ethernet Mac address
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_RemoveHashMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
-
-/**************************************************************************//**
- @Function      FM_MAC_AddExactMatchMacAddr
-
- @Description   Add a unicast or multicast mac address for exact-match filtering
-                (8 on dTSEC, 2 for 10G-MAC)
-
- @Param[in]     h_FmMac     -   A handle to a FM Module.
- @Param[in]     p_EnetAddr  -   MAC Address to ADD
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only after FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_AddExactMatchMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
-
-/**************************************************************************//**
- @Function      FM_MAC_RemovelExactMatchMacAddr
-
- @Description   Remove a uni cast or multi cast mac address.
-
- @Param[in]     h_FmMac     -   A handle to a FM Module.
- @Param[in]     p_EnetAddr  -   MAC Address to remove
-
- @Return        E_OK on success; Error code otherwise..
-
- @Cautions      Allowed only after FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_RemovelExactMatchMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
-
-/**************************************************************************//**
- @Function      FM_MAC_SetPromiscuous
-
- @Description   Enable/Disable MAC Promiscuous mode for ALL mac addresses.
-
- @Param[in]     h_FmMac    - A handle to a FM MAC Module.
- @Param[in]     enable     - TRUE to enable or FALSE to disable.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only after FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_SetPromiscuous(t_Handle h_FmMac, bool enable);
-
-/**************************************************************************//**
- @Function      FM_MAC_AdjustLink
-
- @Description   Adjusts the Ethernet link with new speed/duplex setup.
-                This routine is relevant only for dTSEC.
-
- @Param[in]     h_FmMac     - A handle to a FM Module.
- @Param[in]     speed       - Ethernet speed.
- @Param[in]     fullDuplex  - TRUE for Full-Duplex mode;
-                              FALSE for Half-Duplex mode.
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error FM_MAC_AdjustLink(t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex);
-
-/**************************************************************************//**
- @Function      FM_MAC_RestartAutoneg
-
- @Description   Restarts the autonegotiation process.
-                When autonegegotiation process is invoked under traffic the
-                autonegotiation process between the internal TBI PHY and the
-                external PHY does not always complete succesfuly. Calling this
-                function will restart the autonegotiation process that will end
-                succesfuly. It is recomended to call this function after issuing
-                autoneg restart command to the Eth Phy.
-                This routine is relevant only for dTSEC.
-
- @Param[in]     h_FmMac     - A handle to a FM Module.
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error FM_MAC_RestartAutoneg(t_Handle h_FmMac);
-
-/**************************************************************************//**
- @Function      FM_MAC_GetId
-
- @Description   Return the MAC ID
-
- @Param[in]     h_FmMac     -   A handle to a FM Module.
- @Param[out]    p_MacId     -   MAC ID of device
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only after FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_GetId(t_Handle h_FmMac, uint32_t *p_MacId);
-
-/**************************************************************************//**
- @Function      FM_MAC_GetVesrion
-
- @Description   Return Mac HW chip version
-
- @Param[in]     h_FmMac      -   A handle to a FM Module.
- @Param[out]    p_MacVresion -   Mac version as defined by the chip
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only after FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_GetVesrion(t_Handle h_FmMac, uint32_t *p_MacVresion);
-
-/**************************************************************************//**
- @Function      FM_MAC_MII_WritePhyReg
-
- @Description   Write data into Phy Register
-
- @Param[in]     h_FmMac     -   A handle to a FM Module.
- @Param[in]     phyAddr     -   Phy Address on the MII bus
- @Param[in]     reg         -   Register Number.
- @Param[in]     data        -   Data to write.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only after FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_MII_WritePhyReg(t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg, uint16_t data);
-
-/**************************************************************************//**
- @Function      FM_MAC_MII_ReadPhyReg
-
- @Description   Read data from Phy Register
-
- @Param[in]     h_FmMac     -   A handle to a FM Module.
- @Param[in]     phyAddr     -   Phy Address on the MII bus
- @Param[in]     reg         -   Register Number.
- @Param[out]    p_Data      -   Data from PHY.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only after FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_MII_ReadPhyReg(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
-
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-/**************************************************************************//**
- @Function      FM_MAC_DumpRegs
-
- @Description   Dump internal registers
-
- @Param[in]     h_FmMac     -   A handle to a FM Module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only after FM_MAC_Init().
-*//***************************************************************************/
-t_Error FM_MAC_DumpRegs(t_Handle h_FmMac);
-#endif /* (defined(DEBUG_ERRORS) && ... */
-
-/** @} */ /* end of FM_mac_runtime_control_grp group */
-/** @} */ /* end of FM_mac_grp group */
-/** @} */ /* end of FM_grp group */
-
-/**************************************************************************//**
- @Function      DtsecRestartTbiAN
-
- @Description   Restart TBI autonegotiation for a given Dtsec TBI interface.
-
- @Param[in]     h_Dtsec     -   A handle to the Dtsec.
-*//***************************************************************************/
-void DtsecRestartTbiAN(t_Handle h_Dtsec);
-
-#endif /* __FM_MAC_EXT_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/fm_vsp_ext.h.orig	2022-05-26 11:28:30.982977418 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/fm_vsp_ext.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,409 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-
-/**************************************************************************//**
- @File          fm_vsp_ext.h
-
- @Description   FM Virtual Storage-Profile ...
-*//***************************************************************************/
-#ifndef __FM_VSP_EXT_H
-#define __FM_VSP_EXT_H
-
-#include "std_ext.h"
-#include "error_ext.h"
-
-#include "fm_ext.h"
-
-
-/**************************************************************************//**
-
- @Group         FM_grp Frame Manager API
-
- @Description   FM API functions, definitions and enums
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Group         FM_VSP_grp FM Virtual-Storage-Profile
-
- @Description   FM Virtual-Storage-Profile API
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Group         FM_VSP_init_grp FM VSP Initialization Unit
-
- @Description   FM VSP initialization API.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   Virtual Storage Profile
-*//***************************************************************************/
-typedef struct t_FmVspParams {
-    t_Handle            h_Fm;               /**< A handle to the FM object this VSP related to */
-    t_FmExtPools        extBufPools;        /**< Which external buffer pools are used
-                                                 (up to FM_PORT_MAX_NUM_OF_EXT_POOLS), and their sizes.
-                                                 parameter associated with Rx / OP port */
-    uint16_t            liodnOffset;        /**< VSP's LIODN offset */
-    struct {
-        e_FmPortType    portType;           /**< Port type */
-        uint8_t         portId;             /**< Port Id - relative to type */
-    } portParams;
-    uint8_t             relativeProfileId;  /**< VSP Id - relative to VSP's range
-                                                 defined in relevant FM object */
-} t_FmVspParams;
-
-
-/**************************************************************************//**
- @Function      FM_VSP_Config
-
- @Description   Creates descriptor for the FM VSP module.
-
-                The routine returns a handle (descriptor) to the FM VSP object.
-                This descriptor must be passed as first parameter to all other
-                FM VSP function calls.
-
-                No actual initialization or configuration of FM hardware is
-                done by this routine.
-
-@Param[in]      p_FmVspParams   Pointer to data structure of parameters
-
- @Retval        Handle to FM VSP object, or NULL for Failure.
-*//***************************************************************************/
-t_Handle FM_VSP_Config(t_FmVspParams *p_FmVspParams);
-
-/**************************************************************************//**
- @Function      FM_VSP_Init
-
- @Description   Initializes the FM VSP module
-
- @Param[in]     h_FmVsp - FM VSP module descriptor
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error FM_VSP_Init(t_Handle h_FmVsp);
-
-/**************************************************************************//**
- @Function      FM_VSP_Free
-
- @Description   Frees all resources that were assigned to FM VSP module.
-
-                Calling this routine invalidates the descriptor.
-
- @Param[in]     h_FmVsp - FM VSP module descriptor
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error FM_VSP_Free(t_Handle h_FmVsp);
-
-
-/**************************************************************************//**
- @Group         FM_VSP_adv_config_grp  FM VSP Advanced Configuration Unit
-
- @Description   FM VSP advanced configuration functions.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Function      FM_VSP_ConfigBufferPrefixContent
-
- @Description   Defines the structure, size and content of the application buffer.
-
-                The prefix will
-                In VSPs defined for Tx ports, if 'passPrsResult', the application
-                should set a value to their offsets in the prefix of
-                the FM will save the first 'privDataSize', than,
-                depending on 'passPrsResult' and 'passTimeStamp', copy parse result
-                and timeStamp, and the packet itself (in this order), to the
-                application buffer, and to offset.
-
-                Calling this routine changes the buffer margins definitions
-                in the internal driver data base from its default
-                configuration: Data size:  [DEFAULT_FM_SP_bufferPrefixContent_privDataSize]
-                               Pass Parser result: [DEFAULT_FM_SP_bufferPrefixContent_passPrsResult].
-                               Pass timestamp: [DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp].
-
- @Param[in]     h_FmVsp                         A handle to a FM VSP module.
- @Param[in,out] p_FmBufferPrefixContent         A structure of parameters describing the
-                                                structure of the buffer.
-                                                Out parameter: Start margin - offset
-                                                of data from start of external buffer.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
-*//***************************************************************************/
-t_Error FM_VSP_ConfigBufferPrefixContent(t_Handle                   h_FmVsp,
-                                         t_FmBufferPrefixContent    *p_FmBufferPrefixContent);
-
-/**************************************************************************//**
- @Function      FM_VSP_ConfigDmaSwapData
-
- @Description   Calling this routine changes the DMA swap data parameter
-                in the internal driver data base from its default
-                configuration  [DEFAULT_FM_SP_dmaSwapData]
-
- @Param[in]     h_FmVsp     A handle to a FM VSP module.
- @Param[in]     swapData    New selection
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
-*//***************************************************************************/
-t_Error FM_VSP_ConfigDmaSwapData(t_Handle h_FmVsp, e_FmDmaSwapOption swapData);
-
-/**************************************************************************//**
- @Function      FM_VSP_ConfigDmaIcCacheAttr
-
- @Description   Calling this routine changes the internal context cache
-                attribute parameter in the internal driver data base
-                from its default configuration  [DEFAULT_FM_SP_dmaIntContextCacheAttr]
-
- @Param[in]     h_FmVsp                 A handle to a FM VSP module.
- @Param[in]     intContextCacheAttr     New selection
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
-*//***************************************************************************/
-t_Error FM_VSP_ConfigDmaIcCacheAttr(t_Handle            h_FmVsp,
-                                    e_FmDmaCacheOption  intContextCacheAttr);
-
-/**************************************************************************//**
- @Function      FM_VSP_ConfigDmaHdrAttr
-
- @Description   Calling this routine changes the header cache
-                attribute parameter in the internal driver data base
-                from its default configuration  [DEFAULT_FM_SP_dmaHeaderCacheAttr]
-
- @Param[in]     h_FmVsp                     A handle to a FM VSP module.
- @Param[in]     headerCacheAttr             New selection
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
-*//***************************************************************************/
-t_Error FM_VSP_ConfigDmaHdrAttr(t_Handle h_FmVsp, e_FmDmaCacheOption headerCacheAttr);
-
-/**************************************************************************//**
- @Function      FM_VSP_ConfigDmaScatterGatherAttr
-
- @Description   Calling this routine changes the scatter gather cache
-                attribute parameter in the internal driver data base
-                from its default configuration [DEFAULT_FM_SP_dmaScatterGatherCacheAttr]
-
- @Param[in]     h_FmVsp                     A handle to a FM VSP module.
- @Param[in]     scatterGatherCacheAttr      New selection
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
-*//***************************************************************************/
-t_Error FM_VSP_ConfigDmaScatterGatherAttr(t_Handle              h_FmVsp,
-                                          e_FmDmaCacheOption    scatterGatherCacheAttr);
-
-/**************************************************************************//**
- @Function      FM_VSP_ConfigDmaWriteOptimize
-
- @Description   Calling this routine changes the write optimization
-                parameter in the internal driver data base
-                from its default configuration: optimize = [DEFAULT_FM_SP_dmaWriteOptimize]
-
- @Param[in]     h_FmVsp     A handle to a FM VSP module.
- @Param[in]     optimize    TRUE to enable optimization, FALSE for normal operation
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
-*//***************************************************************************/
-t_Error FM_VSP_ConfigDmaWriteOptimize(t_Handle h_FmVsp, bool optimize);
-
-/**************************************************************************//**
- @Function      FM_VSP_ConfigNoScatherGather
-
- @Description   Calling this routine changes the possibility to receive S/G frame
-                in the internal driver data base
-                from its default configuration: optimize = [DEFAULT_FM_SP_noScatherGather]
-
- @Param[in]     h_FmVsp             A handle to a FM VSP module.
- @Param[in]     noScatherGather     TRUE to operate without scatter/gather capability.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
-*//***************************************************************************/
-t_Error FM_VSP_ConfigNoScatherGather(t_Handle h_FmVsp, bool noScatherGather);
-
-/**************************************************************************//**
- @Function      FM_VSP_ConfigPoolDepletion
-
- @Description   Calling this routine enables pause frame generation depending on the
-                depletion status of BM pools. It also defines the conditions to activate
-                this functionality. By default, this functionality is disabled.
-
- @Param[in]     h_FmVsp                 A handle to a FM VSP module.
- @Param[in]     p_BufPoolDepletion      A structure of pool depletion parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
-*//***************************************************************************/
-t_Error FM_VSP_ConfigPoolDepletion(t_Handle h_FmVsp, t_FmBufPoolDepletion *p_BufPoolDepletion);
-
-/**************************************************************************//**
- @Function      FM_VSP_ConfigBackupPools
-
- @Description   Calling this routine allows the configuration of some of the BM pools
-                defined for this port as backup pools.
-                A pool configured to be a backup pool will be used only if all other
-                enabled non-backup pools are depleted.
-
- @Param[in]     h_FmVsp                 A handle to a FM VSP module.
- @Param[in]     p_BackupBmPools         An array of pool id's. All pools specified here will
-                                        be defined as backup pools.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
-*//***************************************************************************/
-t_Error FM_VSP_ConfigBackupPools(t_Handle h_FmVsp, t_FmBackupBmPools *p_BackupBmPools);
-
-/** @} */ /* end of FM_VSP_adv_config_grp group */
-/** @} */ /* end of FM_VSP_init_grp group */
-
-
-/**************************************************************************//**
- @Group         FM_VSP_control_grp FM VSP Control Unit
-
- @Description   FM VSP runtime control API.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Function      FM_VSP_GetBufferDataOffset
-
- @Description   Relevant for Rx ports.
-                Returns the data offset from the beginning of the data buffer
-
- @Param[in]     h_FmVsp - FM PORT module descriptor
-
- @Return        data offset.
-
- @Cautions      Allowed only following FM_VSP_Init().
-*//***************************************************************************/
-uint32_t FM_VSP_GetBufferDataOffset(t_Handle h_FmVsp);
-
-/**************************************************************************//**
- @Function      FM_VSP_GetBufferICInfo
-
- @Description   Returns the Internal Context offset from the beginning of the data buffer
-
- @Param[in]     h_FmVsp - FM PORT module descriptor
- @Param[in]     p_Data   - A pointer to the data buffer.
-
- @Return        Internal context info pointer on success, NULL if 'allOtherInfo' was not
-                configured for this port.
-
- @Cautions      Allowed only following FM_VSP_Init().
-*//***************************************************************************/
-uint8_t * FM_VSP_GetBufferICInfo(t_Handle h_FmVsp, char *p_Data);
-
-/**************************************************************************//**
- @Function      FM_VSP_GetBufferPrsResult
-
- @Description   Returns the pointer to the parse result in the data buffer.
-                In Rx ports this is relevant after reception, if parse
-                result is configured to be part of the data passed to the
-                application. For non Rx ports it may be used to get the pointer
-                of the area in the buffer where parse result should be
-                initialized - if so configured.
-                See FM_VSP_ConfigBufferPrefixContent for data buffer prefix
-                configuration.
-
- @Param[in]     h_FmVsp    - FM PORT module descriptor
- @Param[in]     p_Data      - A pointer to the data buffer.
-
- @Return        Parse result pointer on success, NULL if parse result was not
-                configured for this port.
-
- @Cautions      Allowed only following FM_VSP_Init().
-*//***************************************************************************/
-t_FmPrsResult * FM_VSP_GetBufferPrsResult(t_Handle h_FmVsp, char *p_Data);
-
-/**************************************************************************//**
- @Function      FM_VSP_GetBufferTimeStamp
-
- @Description   Returns the time stamp in the data buffer.
-                Relevant for Rx ports for getting the buffer time stamp.
-                See FM_VSP_ConfigBufferPrefixContent for data buffer prefix
-                configuration.
-
- @Param[in]     h_FmVsp    - FM PORT module descriptor
- @Param[in]     p_Data      - A pointer to the data buffer.
-
- @Return        A pointer to the hash result on success, NULL otherwise.
-
- @Cautions      Allowed only following FM_VSP_Init().
-*//***************************************************************************/
-uint64_t * FM_VSP_GetBufferTimeStamp(t_Handle h_FmVsp, char *p_Data);
-
-/**************************************************************************//**
- @Function      FM_VSP_GetBufferHashResult
-
- @Description   Given a data buffer, on the condition that hash result was defined
-                as a part of the buffer content (see FM_VSP_ConfigBufferPrefixContent)
-                this routine will return the pointer to the hash result location in the
-                buffer prefix.
-
- @Param[in]     h_FmVsp    - FM PORT module descriptor
- @Param[in]     p_Data      - A pointer to the data buffer.
-
- @Return        A pointer to the hash result on success, NULL otherwise.
-
- @Cautions      Allowed only following FM_VSP_Init().
-*//***************************************************************************/
-uint8_t * FM_VSP_GetBufferHashResult(t_Handle h_FmVsp, char *p_Data);
-
-
-/** @} */ /* end of FM_VSP_control_grp group */
-/** @} */ /* end of FM_VSP_grp group */
-/** @} */ /* end of FM_grp group */
-
-
-#endif /* __FM_VSP_EXT_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/fm_port_ext.h.orig	2022-05-26 11:28:30.978977583 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/Peripherals/fm_port_ext.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,2576 +0,0 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-/**************************************************************************//**
- @File          fm_port_ext.h
-
- @Description   FM-Port Application Programming Interface.
-*//***************************************************************************/
-#ifndef __FM_PORT_EXT
-#define __FM_PORT_EXT
-
-#include "error_ext.h"
-#include "std_ext.h"
-#include "fm_pcd_ext.h"
-#include "fm_ext.h"
-#include "net_ext.h"
-
-
-/**************************************************************************//**
-
- @Group         FM_grp Frame Manager API
-
- @Description   FM API functions, definitions and enums
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Group         FM_PORT_grp FM Port
-
- @Description   FM Port API
-
-                The FM uses a general module called "port" to represent a Tx port
-                (MAC), an Rx port (MAC) or Offline Parsing port.
-                The number of ports in an FM varies between SOCs.
-                The SW driver manages these ports as sub-modules of the FM, i.e.
-                after an FM is initialized, its ports may be initialized and
-                operated upon.
-
-                The port is initialized aware of its type, but other functions on
-                a port may be indifferent to its type. When necessary, the driver
-                verifies coherence and returns error if applicable.
-
-                On initialization, user specifies the port type and it's index
-                (relative to the port's type) - always starting at 0.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   An enum for defining port PCD modes.
-                This enum defines the superset of PCD engines support - i.e. not
-                all engines have to be used, but all have to be enabled. The real
-                flow of a specific frame depends on the PCD configuration and the
-                frame headers and payload.
-                Note: the first engine and the first engine after the parser (if
-                exists) should be in order, the order is important as it will
-                define the flow of the port. However, as for the rest engines
-                (the ones that follows), the order is not important anymore as
-                it is defined by the PCD graph itself.
-*//***************************************************************************/
-typedef enum e_FmPortPcdSupport {
-      e_FM_PORT_PCD_SUPPORT_NONE = 0                /**< BMI to BMI, PCD is not used */
-    , e_FM_PORT_PCD_SUPPORT_PRS_ONLY                /**< Use only Parser */
-    , e_FM_PORT_PCD_SUPPORT_PLCR_ONLY               /**< Use only Policer */
-    , e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR            /**< Use Parser and Policer */
-    , e_FM_PORT_PCD_SUPPORT_PRS_AND_KG              /**< Use Parser and Keygen */
-    , e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC       /**< Use Parser, Keygen and Coarse Classification */
-    , e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR
-                                                    /**< Use all PCD engines */
-    , e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR     /**< Use Parser, Keygen and Policer */
-    , e_FM_PORT_PCD_SUPPORT_PRS_AND_CC              /**< Use Parser and Coarse Classification */
-    , e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR     /**< Use Parser and Coarse Classification and Policer */
-    , e_FM_PORT_PCD_SUPPORT_CC_ONLY                 /**< Use only Coarse Classification */
-#ifdef FM_CAPWAP_SUPPORT
-    , e_FM_PORT_PCD_SUPPORT_CC_AND_KG               /**< Use Coarse Classification,and Keygen */
-    , e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR      /**< Use Coarse Classification, Keygen and Policer */
-#endif /* FM_CAPWAP_SUPPORT */
-} e_FmPortPcdSupport;
-
-/**************************************************************************//**
- @Description   Port interrupts
-*//***************************************************************************/
-typedef enum e_FmPortExceptions {
-    e_FM_PORT_EXCEPTION_IM_BUSY                 /**< Independent-Mode Rx-BUSY */
-} e_FmPortExceptions;
-
-
-/**************************************************************************//**
- @Collection    General FM Port defines
-*//***************************************************************************/
-#define FM_PORT_PRS_RESULT_NUM_OF_WORDS     8   /**< Number of 4 bytes words in parser result */
-/* @} */
-
-/**************************************************************************//**
- @Collection   FM Frame error
-*//***************************************************************************/
-typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef for defining Frame Descriptor errors */
-
-#define FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT      FM_FD_ERR_UNSUPPORTED_FORMAT    /**< Not for Rx-Port! Unsupported Format */
-#define FM_PORT_FRM_ERR_LENGTH                  FM_FD_ERR_LENGTH                /**< Not for Rx-Port! Length Error */
-#define FM_PORT_FRM_ERR_DMA                     FM_FD_ERR_DMA                   /**< DMA Data error */
-#define FM_PORT_FRM_ERR_NON_FM                  FM_FD_RX_STATUS_ERR_NON_FM      /**< non Frame-Manager error; probably come from SEC that
-                                                                                     was chained to FM */
-
-#define FM_PORT_FRM_ERR_IPRE                    (FM_FD_ERR_IPR & ~FM_FD_IPR)        /**< IPR error */
-#define FM_PORT_FRM_ERR_IPR_NCSP                (FM_FD_ERR_IPR_NCSP & ~FM_FD_IPR)   /**< IPR non-consistent-sp */
-
-#define FM_PORT_FRM_ERR_IPFE                    0                                   /**< Obsolete; will be removed in the future */
-
-#ifdef FM_CAPWAP_SUPPORT
-#define FM_PORT_FRM_ERR_CRE                     FM_FD_ERR_CRE
-#define FM_PORT_FRM_ERR_CHE                     FM_FD_ERR_CHE
-#endif /* FM_CAPWAP_SUPPORT */
-
-#define FM_PORT_FRM_ERR_PHYSICAL                FM_FD_ERR_PHYSICAL              /**< Rx FIFO overflow, FCS error, code error, running disparity
-                                                                                     error (SGMII and TBI modes), FIFO parity error. PHY
-                                                                                     Sequence error, PHY error control character detected. */
-#define FM_PORT_FRM_ERR_SIZE                    FM_FD_ERR_SIZE                  /**< Frame too long OR Frame size exceeds max_length_frame  */
-#define FM_PORT_FRM_ERR_CLS_DISCARD             FM_FD_ERR_CLS_DISCARD           /**< indicates a classifier "drop" operation */
-#define FM_PORT_FRM_ERR_EXTRACTION              FM_FD_ERR_EXTRACTION            /**< Extract Out of Frame */
-#define FM_PORT_FRM_ERR_NO_SCHEME               FM_FD_ERR_NO_SCHEME             /**< No Scheme Selected */
-#define FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW        FM_FD_ERR_KEYSIZE_OVERFLOW      /**< Keysize Overflow */
-#define FM_PORT_FRM_ERR_COLOR_RED               FM_FD_ERR_COLOR_RED             /**< Frame color is red */
-#define FM_PORT_FRM_ERR_COLOR_YELLOW            FM_FD_ERR_COLOR_YELLOW          /**< Frame color is yellow */
-#define FM_PORT_FRM_ERR_ILL_PLCR                FM_FD_ERR_ILL_PLCR              /**< Illegal Policer Profile selected */
-#define FM_PORT_FRM_ERR_PLCR_FRAME_LEN          FM_FD_ERR_PLCR_FRAME_LEN        /**< Policer frame length error */
-#define FM_PORT_FRM_ERR_PRS_TIMEOUT             FM_FD_ERR_PRS_TIMEOUT           /**< Parser Time out Exceed */
-#define FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT        FM_FD_ERR_PRS_ILL_INSTRUCT      /**< Invalid Soft Parser instruction */
-#define FM_PORT_FRM_ERR_PRS_HDR_ERR             FM_FD_ERR_PRS_HDR_ERR           /**< Header error was identified during parsing */
-#define FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED    FM_FD_ERR_BLOCK_LIMIT_EXCEEDED  /**< Frame parsed beyind 256 first bytes */
-#define FM_PORT_FRM_ERR_PROCESS_TIMEOUT         0x00000001                      /**< FPM Frame Processing Timeout Exceeded */
-/* @} */
-
-
-
-/**************************************************************************//**
- @Group         FM_PORT_init_grp FM Port Initialization Unit
-
- @Description   FM Port Initialization Unit
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   Exceptions user callback routine, will be called upon an
-                exception passing the exception identification.
-
- @Param[in]     h_App      - User's application descriptor.
- @Param[in]     exception  - The exception.
-  *//***************************************************************************/
-typedef void (t_FmPortExceptionCallback) (t_Handle h_App, e_FmPortExceptions exception);
-
-/**************************************************************************//**
- @Description   User callback function called by driver with received data.
-
-                User provides this function. Driver invokes it.
-
- @Param[in]     h_App           Application's handle originally specified to
-                                the API Config function
- @Param[in]     p_Data          A pointer to data received
- @Param[in]     length          length of received data
- @Param[in]     status          receive status and errors
- @Param[in]     position        position of buffer in frame
- @Param[in]     h_BufContext    A handle of the user acossiated with this buffer
-
- @Retval        e_RX_STORE_RESPONSE_CONTINUE - order the driver to continue Rx
-                                               operation for all ready data.
- @Retval        e_RX_STORE_RESPONSE_PAUSE    - order the driver to stop Rx operation.
-*//***************************************************************************/
-typedef e_RxStoreResponse (t_FmPortImRxStoreCallback) (t_Handle h_App,
-                                                       uint8_t  *p_Data,
-                                                       uint16_t length,
-                                                       uint16_t status,
-                                                       uint8_t  position,
-                                                       t_Handle h_BufContext);
-
-/**************************************************************************//**
- @Description   User callback function called by driver when transmit completed.
-
-                User provides this function. Driver invokes it.
-
- @Param[in]     h_App           Application's handle originally specified to
-                                the API Config function
- @Param[in]     p_Data          A pointer to data received
- @Param[in]     status          transmit status and errors
- @Param[in]     lastBuffer      is last buffer in frame
- @Param[in]     h_BufContext    A handle of the user acossiated with this buffer
- *//***************************************************************************/
-typedef void (t_FmPortImTxConfCallback) (t_Handle   h_App,
-                                         uint8_t    *p_Data,
-                                         uint16_t   status,
-                                         t_Handle   h_BufContext);
-
-/**************************************************************************//**
- @Description   A structure for additional Rx port parameters
-*//***************************************************************************/
-typedef struct t_FmPortRxParams {
-    uint32_t                errFqid;            /**< Error Queue Id. */
-    uint32_t                dfltFqid;           /**< Default Queue Id.  */
-    uint16_t                liodnOffset;        /**< Port's LIODN offset. */
-    t_FmExtPools            extBufPools;        /**< Which external buffer pools are used
-                                                     (up to FM_PORT_MAX_NUM_OF_EXT_POOLS), and their sizes. */
-} t_FmPortRxParams;
-
-/**************************************************************************//**
- @Description   A structure for additional non-Rx port parameters
-*//***************************************************************************/
-typedef struct t_FmPortNonRxParams {
-    uint32_t                errFqid;            /**< Error Queue Id. */
-    uint32_t                dfltFqid;           /**< For Tx - Default Confirmation queue,
-                                                     0 means no Tx confirmation for processed
-                                                     frames. For OP port - default Rx queue. */
-    uint32_t                qmChannel;          /**< QM-channel dedicated to this port; will be used
-                                                     by the FM for dequeue. */
-} t_FmPortNonRxParams;
-
-/**************************************************************************//**
- @Description   A structure for additional Rx port parameters
-*//***************************************************************************/
-typedef struct t_FmPortImRxTxParams {
-    t_Handle                    h_FmMuram;          /**< A handle of the FM-MURAM partition */
-    uint16_t                    liodnOffset;        /**< For Rx ports only. Port's LIODN Offset. */
-    uint8_t                     dataMemId;          /**< Memory partition ID for data buffers */
-    uint32_t                    dataMemAttributes;  /**< Memory attributes for data buffers */
-    t_BufferPoolInfo            rxPoolParams;       /**< For Rx ports only. */
-    t_FmPortImRxStoreCallback   *f_RxStore;         /**< For Rx ports only. */
-    t_FmPortImTxConfCallback    *f_TxConf;          /**< For Tx ports only. */
-} t_FmPortImRxTxParams;
-
-/**************************************************************************//**
- @Description   A union for additional parameters depending on port type
-*//***************************************************************************/
-typedef union u_FmPortSpecificParams {
-    t_FmPortImRxTxParams        imRxTxParams;       /**< Rx/Tx Independent-Mode port parameter structure */
-    t_FmPortRxParams            rxParams;           /**< Rx port parameters structure */
-    t_FmPortNonRxParams         nonRxParams;        /**< Non-Rx port parameters structure */
-} u_FmPortSpecificParams;
-
-/**************************************************************************//**
- @Description   A structure representing FM initialization parameters
-*//***************************************************************************/
-typedef struct t_FmPortParams {
-    uintptr_t                   baseAddr;           /**< Virtual Address of memory mapped FM Port registers.*/
-    t_Handle                    h_Fm;               /**< A handle to the FM object this port related to */
-    e_FmPortType                portType;           /**< Port type */
-    uint8_t                     portId;             /**< Port Id - relative to type;
-                                                         NOTE: When configuring Offline Parsing port for
-                                                         FMANv3 devices (DPAA_VERSION 11 and higher),
-                                                         it is highly recommended NOT to use portId=0 due to lack
-                                                         of HW resources on portId=0. */
-    bool                        independentModeEnable;
-                                                    /**< This port is Independent-Mode - Used for Rx/Tx ports only! */
-    uint16_t                    liodnBase;          /**< Irrelevant for P4080 rev 1. LIODN base for this port, to be
-                                                         used together with LIODN offset. */
-    u_FmPortSpecificParams      specificParams;     /**< Additional parameters depending on port
-                                                         type. */
-
-    t_FmPortExceptionCallback   *f_Exception;       /**< Relevant for IM only Callback routine to be called on BUSY exception */
-    t_Handle                    h_App;              /**< A handle to an application layer object; This handle will
-                                                         be passed by the driver upon calling the above callbacks */
-} t_FmPortParams;
-
-
-/**************************************************************************//**
- @Function      FM_PORT_Config
-
- @Description   Creates a descriptor for the FM PORT module.
-
-                The routine returns a handle (descriptor) to the FM PORT object.
-                This descriptor must be passed as first parameter to all other
-                FM PORT function calls.
-
-                No actual initialization or configuration of FM hardware is
-                done by this routine.
-
- @Param[in]     p_FmPortParams   - Pointer to data structure of parameters
-
- @Retval        Handle to FM object, or NULL for Failure.
-*//***************************************************************************/
-t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams);
-
-/**************************************************************************//**
- @Function      FM_PORT_Init
-
- @Description   Initializes the FM PORT module by defining the software structure
-                and configuring the hardware registers.
-
- @Param[in]     h_FmPort - FM PORT module descriptor
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error FM_PORT_Init(t_Handle h_FmPort);
-
-/**************************************************************************//**
- @Function      FM_PORT_Free
-
- @Description   Frees all resources that were assigned to FM PORT module.
-
-                Calling this routine invalidates the descriptor.
-
- @Param[in]     h_FmPort - FM PORT module descriptor
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error FM_PORT_Free(t_Handle h_FmPort);
-
-t_Handle FM_PORT_Open(t_FmPortParams *p_FmPortParams);
-void FM_PORT_Close(t_Handle h_FmPort);
-
-
-
-/**************************************************************************//**
- @Group         FM_PORT_advanced_init_grp    FM Port Advanced Configuration Unit
-
- @Description   Configuration functions used to change default values.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   enum for defining QM frame dequeue
-*//***************************************************************************/
-typedef enum e_FmPortDeqType {
-   e_FM_PORT_DEQ_TYPE1,             /**< Dequeue from the SP channel - with priority precedence,
-                                         and Intra-Class Scheduling respected. */
-   e_FM_PORT_DEQ_TYPE2,             /**< Dequeue from the SP channel - with active FQ precedence,
-                                         and Intra-Class Scheduling respected. */
-   e_FM_PORT_DEQ_TYPE3              /**< Dequeue from the SP channel - with active FQ precedence,
-                                         and override Intra-Class Scheduling */
-} e_FmPortDeqType;
-
-/**************************************************************************//**
- @Description   enum for defining QM frame dequeue
-*//***************************************************************************/
-typedef enum e_FmPortDeqPrefetchOption {
-   e_FM_PORT_DEQ_NO_PREFETCH,       /**< QMI preforms a dequeue action for a single frame
-                                         only when a dedicated portID Tnum is waiting. */
-   e_FM_PORT_DEQ_PARTIAL_PREFETCH,  /**< QMI preforms a dequeue action for 3 frames when
-                                         one dedicated portId tnum is waiting. */
-   e_FM_PORT_DEQ_FULL_PREFETCH      /**< QMI preforms a dequeue action for 3 frames when
-                                         no dedicated portId tnums are waiting. */
-
-} e_FmPortDeqPrefetchOption;
-
-/**************************************************************************//**
- @Description   enum for defining port default color
-*//***************************************************************************/
-typedef enum e_FmPortColor {
-    e_FM_PORT_COLOR_GREEN,          /**< Default port color is green */
-    e_FM_PORT_COLOR_YELLOW,         /**< Default port color is yellow */
-    e_FM_PORT_COLOR_RED,            /**< Default port color is red */
-    e_FM_PORT_COLOR_OVERRIDE        /**< Ignore color */
-} e_FmPortColor;
-
-/**************************************************************************//**
- @Description   A structure for defining Dual Tx rate limiting scale
-*//***************************************************************************/
-typedef enum e_FmPortDualRateLimiterScaleDown {
-    e_FM_PORT_DUAL_RATE_LIMITER_NONE = 0,           /**< Use only single rate limiter  */
-    e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2,    /**< Divide high rate limiter by 2 */
-    e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4,    /**< Divide high rate limiter by 4 */
-    e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8     /**< Divide high rate limiter by 8 */
-} e_FmPortDualRateLimiterScaleDown;
-
-
-/**************************************************************************//**
- @Description   A structure for defining FM port resources
-*//***************************************************************************/
-typedef struct t_FmPortRsrc {
-    uint32_t    num;                /**< Committed required resource */
-    uint32_t    extra;              /**< Extra (not committed) required resource */
-} t_FmPortRsrc;
-
-/**************************************************************************//**
- @Description   A structure for defining observed pool depletion
-*//***************************************************************************/
-typedef struct t_FmPortObservedBufPoolDepletion {
-    t_FmBufPoolDepletion    poolDepletionParams;/**< parameters to define pool depletion */
-    t_FmExtPools            poolsParams;        /**< Which external buffer pools are observed
-                                                     (up to FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS),
-                                                     and their sizes. */
-} t_FmPortObservedBufPoolDepletion;
-
-/**************************************************************************//**
- @Description   A structure for defining Tx rate limiting
-*//***************************************************************************/
-typedef struct t_FmPortRateLimit {
-    uint16_t                            maxBurstSize;           /**< in KBytes for Tx ports, in frames
-                                                                     for OP ports. (note that
-                                                                     for early chips burst size is
-                                                                     rounded up to a multiply of 1000 frames).*/
-    uint32_t                            rateLimit;              /**< in Kb/sec for Tx ports, in frame/sec for
-                                                                     OP ports. Rate limit refers to
-                                                                     data rate (rather than line rate). */
-    e_FmPortDualRateLimiterScaleDown    rateLimitDivider;       /**< For OP ports only. Not-valid
-                                                                     for some earlier chip revisions */
-} t_FmPortRateLimit;
-
-/**************************************************************************//**
- @Description   A structure for defining the parameters of
-                the Rx port performance counters
-*//***************************************************************************/
-typedef struct t_FmPortPerformanceCnt {
-    uint8_t     taskCompVal;            /**< Task compare value */
-    uint8_t     queueCompVal;           /**< Rx queue/Tx confirm queue compare
-                                             value (unused for H/O) */
-    uint8_t     dmaCompVal;             /**< Dma compare value */
-    uint32_t    fifoCompVal;            /**< Fifo compare value (in bytes) */
-} t_FmPortPerformanceCnt;
-
-
-/**************************************************************************//**
- @Description   A structure for defining the sizes of the Deep Sleep
-                the Auto Response tables
-*//***************************************************************************/
-typedef struct t_FmPortDsarTablesSizes
-{
-    uint16_t   maxNumOfArpEntries;
-    uint16_t   maxNumOfEchoIpv4Entries;
-    uint16_t   maxNumOfNdpEntries;
-    uint16_t   maxNumOfEchoIpv6Entries;
-    uint16_t   maxNumOfSnmpIPV4Entries;
-    uint16_t   maxNumOfSnmpIPV6Entries;
-    uint16_t   maxNumOfSnmpOidEntries;
-    uint16_t   maxNumOfSnmpOidChar; /* total amount of character needed for the snmp table */
-
-    uint16_t   maxNumOfIpProtFiltering;
-    uint16_t   maxNumOfTcpPortFiltering;
-    uint16_t   maxNumOfUdpPortFiltering;
-} t_FmPortDsarTablesSizes;
-
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigDsarSupport
-
- @Description   This function will allocate the amount of MURAM needed for
-                this max number of entries for Deep Sleep Auto Response.
-                it will calculate all needed MURAM for autoresponse including
-                necesary common stuff.
-
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     params      A pointer to a structure containing the maximum
-                            sizes of the auto response tables
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigDsarSupport(t_Handle h_FmPortRx, t_FmPortDsarTablesSizes *params);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigNumOfOpenDmas
-
- @Description   Calling this routine changes the max number of open DMA's
-                available for this port. It changes this parameter in the
-                internal driver data base from its default configuration
-                [OP: 1]
-                [1G-RX, 1G-TX: 1 (+1)]
-                [10G-RX, 10G-TX: 8 (+8)]
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     p_OpenDmas  A pointer to a structure of parameters defining
-                            the open DMA allocation.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_OpenDmas);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigNumOfTasks
-
- @Description   Calling this routine changes the max number of tasks
-                available for this port. It changes this parameter in the
-                internal driver data base from its default configuration
-                [OP: 1]
-                [1G-RX, 1G-TX: 3 (+2)]
-                [10G-RX, 10G-TX: 16 (+8)]
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     p_NumOfTasks    A pointer to a structure of parameters defining
-                                the tasks allocation.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigSizeOfFifo
-
- @Description   Calling this routine changes the max FIFO size configured for this port.
-
-                This function changes the internal driver data base from its
-                default configuration. Please refer to the driver's User Guide for
-                information on default FIFO sizes in the various devices.
-                [OP: 2KB]
-                [1G-RX, 1G-TX: 11KB]
-                [10G-RX, 10G-TX: 12KB]
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     p_SizeOfFifo    A pointer to a structure of parameters defining
-                                the FIFO allocation.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigDeqHighPriority
-
- @Description   Calling this routine changes the dequeue priority in the
-                internal driver data base from its default configuration
-                1G: [DEFAULT_PORT_deqHighPriority_1G]
-                10G: [DEFAULT_PORT_deqHighPriority_10G]
-
-                May be used for Non-Rx ports only
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     highPri     TRUE to select high priority, FALSE for normal operation.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigDeqType
-
- @Description   Calling this routine changes the dequeue type parameter in the
-                internal driver data base from its default configuration
-                [DEFAULT_PORT_deqType].
-
-                May be used for Non-Rx ports only
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     deqType     According to QM definition.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigDeqPrefetchOption
-
- @Description   Calling this routine changes the dequeue prefetch option parameter in the
-                internal driver data base from its default configuration
-                [DEFAULT_PORT_deqPrefetchOption]
-                Note: Available for some chips only
-
-                May be used for Non-Rx ports only
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     deqPrefetchOption   New option
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOption deqPrefetchOption);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigDeqByteCnt
-
- @Description   Calling this routine changes the dequeue byte count parameter in
-                the internal driver data base from its default configuration
-                1G:[DEFAULT_PORT_deqByteCnt_1G].
-                10G:[DEFAULT_PORT_deqByteCnt_10G].
-
-                May be used for Non-Rx ports only
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     deqByteCnt      New byte count
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigBufferPrefixContent
-
- @Description   Defines the structure, size and content of the application buffer.
-                The prefix will
-                In Tx ports, if 'passPrsResult', the application
-                should set a value to their offsets in the prefix of
-                the FM will save the first 'privDataSize', than,
-                depending on 'passPrsResult' and 'passTimeStamp', copy parse result
-                and timeStamp, and the packet itself (in this order), to the
-                application buffer, and to offset.
-                Calling this routine changes the buffer margins definitions
-                in the internal driver data base from its default
-                configuration: Data size:  [DEFAULT_PORT_bufferPrefixContent_privDataSize]
-                               Pass Parser result: [DEFAULT_PORT_bufferPrefixContent_passPrsResult].
-                               Pass timestamp: [DEFAULT_PORT_bufferPrefixContent_passTimeStamp].
-
-                May be used for all ports
-
- @Param[in]     h_FmPort                        A handle to a FM Port module.
- @Param[in,out] p_FmBufferPrefixContent         A structure of parameters describing the
-                                                structure of the buffer.
-                                                Out parameter: Start margin - offset
-                                                of data from start of external buffer.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle                      h_FmPort,
-                                          t_FmBufferPrefixContent       *p_FmBufferPrefixContent);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigCheksumLastBytesIgnore
-
- @Description   Calling this routine changes the number of checksum bytes to ignore
-                parameter in the internal driver data base from its default configuration
-                [DEFAULT_PORT_cheksumLastBytesIgnore]
-
-                May be used by Tx & Rx ports only
-
- @Param[in]     h_FmPort                A handle to a FM Port module.
- @Param[in]     cheksumLastBytesIgnore  New value
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort, uint8_t cheksumLastBytesIgnore);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigCutBytesFromEnd
-
- @Description   Calling this routine changes the number of bytes to cut from a
-                frame's end parameter in the internal driver data base
-                from its default configuration [DEFAULT_PORT_cutBytesFromEnd]
-                Note that if the result of (frame length before chop - cutBytesFromEnd) is
-                less than 14 bytes, the chop operation is not executed.
-
-                May be used for Rx ports only
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     cutBytesFromEnd     New value
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigPoolDepletion
-
- @Description   Calling this routine enables pause frame generation depending on the
-                depletion status of BM pools. It also defines the conditions to activate
-                this functionality. By default, this functionality is disabled.
-
-                May be used for Rx ports only
-
- @Param[in]     h_FmPort                A handle to a FM Port module.
- @Param[in]     p_BufPoolDepletion      A structure of pool depletion parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmBufPoolDepletion *p_BufPoolDepletion);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigObservedPoolDepletion
-
- @Description   Calling this routine enables a mechanism to stop port enqueue
-                depending on the depletion status of selected BM pools.
-                It also defines the conditions to activate
-                this functionality. By default, this functionality is disabled.
-
-                Note: Available for some chips only
-
-                May be used for OP ports only
-
- @Param[in]     h_FmPort                            A handle to a FM Port module.
- @Param[in]     p_FmPortObservedBufPoolDepletion    A structure of parameters for pool depletion.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigObservedPoolDepletion(t_Handle                            h_FmPort,
-                                            t_FmPortObservedBufPoolDepletion    *p_FmPortObservedBufPoolDepletion);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigExtBufPools
-
- @Description   This routine should be called for OP ports
-                that internally use BM buffer pools. In such cases, e.g. for fragmentation and
-                re-assembly, the FM needs new BM buffers. By calling this routine the user
-                specifies the BM buffer pools that should be used.
-
-                Note: Available for some chips only
-
-                May be used for OP ports only
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     p_FmExtPools        A structure of parameters for the external pools.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmExtPools *p_FmExtPools);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigBackupPools
-
- @Description   Calling this routine allows the configuration of some of the BM pools
-                defined for this port as backup pools.
-                A pool configured to be a backup pool will be used only if all other
-                enabled non-backup pools are depleted.
-
-                May be used for Rx ports only
-
- @Param[in]     h_FmPort                A handle to a FM Port module.
- @Param[in]     p_FmPortBackupBmPools   An array of pool id's. All pools specified here will
-                                        be defined as backup pools.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmBackupBmPools *p_FmPortBackupBmPools);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigFrmDiscardOverride
-
- @Description   Calling this routine changes the error frames destination parameter
-                in the internal driver data base from its default configuration:
-                override = [DEFAULT_PORT_frmDiscardOverride]
-
-                May be used for Rx and OP ports only
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     override    TRUE to override discarding of error frames and
-                            enqueueing them to error queue.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigErrorsToDiscard
-
- @Description   Calling this routine changes the behaviour on error parameter
-                in the internal driver data base from its default configuration:
-                [DEFAULT_PORT_errorsToDiscard].
-                If a requested error was previously defined as "ErrorsToEnqueue" it's
-                definition will change and the frame will be discarded.
-                Errors that were not defined either as "ErrorsToEnqueue" nor as
-                "ErrorsToDiscard", will be forwarded to CPU.
-
-                May be used for Rx and OP ports only
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     errs        A list of errors to discard
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigDmaSwapData
-
- @Description   Calling this routine changes the DMA swap data aparameter
-                in the internal driver data base from its default
-                configuration  [DEFAULT_PORT_dmaSwapData]
-
-                May be used for all port types
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     swapData    New selection
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmDmaSwapOption swapData);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigDmaIcCacheAttr
-
- @Description   Calling this routine changes the internal context cache
-                attribute parameter in the internal driver data base
-                from its default configuration  [DEFAULT_PORT_dmaIntContextCacheAttr]
-
-                May be used for all port types
-
- @Param[in]     h_FmPort               A handle to a FM Port module.
- @Param[in]     intContextCacheAttr    New selection
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmDmaCacheOption intContextCacheAttr);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigDmaHdrAttr
-
- @Description   Calling this routine changes the header cache
-                attribute parameter in the internal driver data base
-                from its default configuration  [DEFAULT_PORT_dmaHeaderCacheAttr]
-
-                May be used for all port types
-
- @Param[in]     h_FmPort                    A handle to a FM Port module.
- @Param[in]     headerCacheAttr             New selection
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmDmaCacheOption headerCacheAttr);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigDmaScatterGatherAttr
-
- @Description   Calling this routine changes the scatter gather cache
-                attribute parameter in the internal driver data base
-                from its default configuration  [DEFAULT_PORT_dmaScatterGatherCacheAttr]
-
-                May be used for all port types
-
- @Param[in]     h_FmPort                    A handle to a FM Port module.
- @Param[in]     scatterGatherCacheAttr      New selection
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmDmaCacheOption scatterGatherCacheAttr);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigDmaWriteOptimize
-
- @Description   Calling this routine changes the write optimization
-                parameter in the internal driver data base
-                from its default configuration:  By default optimize = [DEFAULT_PORT_dmaWriteOptimize].
-                Note:
-
-                1. For head optimization, data alignment must be >= 16 (supported by default).
-
-                3. For tail optimization, note that the optimization is performed by extending the write transaction
-                of the frame payload at the tail as needed to achieve optimal bus transfers, so that the last write
-                is extended to be on 16/64 bytes aligned block (chip dependent).
-
-                Relevant for non-Tx port types
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     optimize    TRUE to enable optimization, FALSE for normal operation
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigNoScatherGather
-
- @Description    Calling this routine changes the noScatherGather parameter in internal driver data base
-                 from its default configuration.
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     noScatherGather (TRUE - frame is discarded if can not be stored in single buffer,
-                                 FALSE - frame can be stored in scatter gather (S/G) format).
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigNoScatherGather(t_Handle h_FmPort, bool noScatherGather);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigDfltColor
-
- @Description   Calling this routine changes the internal default color parameter
-                in the internal driver data base
-                from its default configuration  [DEFAULT_PORT_color]
-
-                May be used for all port types
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     color           New selection
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigDfltColor(t_Handle h_FmPort, e_FmPortColor color);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigSyncReq
-
- @Description   Calling this routine changes the synchronization attribute parameter
-                in the internal driver data base from its default configuration:
-                syncReq = [DEFAULT_PORT_syncReq]
-
-                May be used for all port types
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     syncReq         TRUE to request synchronization, FALSE otherwize.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigForwardReuseIntContext
-
- @Description   This routine is relevant for Rx ports that are routed to OP port.
-                It changes the internal context reuse option in the internal
-                driver data base from its default configuration:
-                reuse = [DEFAULT_PORT_forwardIntContextReuse]
-
-                May be used for Rx ports only
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     reuse           TRUE to reuse internal context on frames
-                                forwarded to OP port.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool reuse);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigDontReleaseTxBufToBM
-
- @Description   This routine should be called if no Tx confirmation
-                is done, and yet buffers should not be released to the BM.
-                Normally, buffers are returned using the Tx confirmation
-                process. When Tx confirmation is not used (defFqid=0),
-                buffers are typically released to the BM. This routine
-                may be called to avoid this behavior and not release the
-                buffers.
-
-                May be used for Tx ports only
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigDontReleaseTxBufToBM(t_Handle h_FmPort);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigIMMaxRxBufLength
-
- @Description   Changes the maximum receive buffer length from its default
-                configuration: Closest rounded down power of 2 value of the
-                data buffer size.
-
-                The maximum receive buffer length directly affects the structure
-                of received frames (single- or multi-buffered) and the performance
-                of both the FM and the driver.
-
-                The selection between single- or multi-buffered frames should be
-                done according to the characteristics of the specific application.
-                The recommended mode is to use a single data buffer per packet,
-                as this mode provides the best performance. However, the user can
-                select to use multiple data buffers per packet.
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     newVal          Maximum receive buffer length (in bytes).
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-                This routine is to be used only if Independent-Mode is enabled.
-*//***************************************************************************/
-t_Error FM_PORT_ConfigIMMaxRxBufLength(t_Handle h_FmPort, uint16_t newVal);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigIMRxBdRingLength
-
- @Description   Changes the receive BD ring length from its default
-                configuration:[DEFAULT_PORT_rxBdRingLength]
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     newVal          The desired BD ring length.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-                This routine is to be used only if Independent-Mode is enabled.
-*//***************************************************************************/
-t_Error FM_PORT_ConfigIMRxBdRingLength(t_Handle h_FmPort, uint16_t newVal);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigIMTxBdRingLength
-
- @Description   Changes the transmit BD ring length from its default
-                configuration:[DEFAULT_PORT_txBdRingLength]
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     newVal          The desired BD ring length.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-                This routine is to be used only if Independent-Mode is enabled.
-*//***************************************************************************/
-t_Error FM_PORT_ConfigIMTxBdRingLength(t_Handle h_FmPort, uint16_t newVal);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigIMFmanCtrlExternalStructsMemory
-
- @Description   Configures memory partition and attributes for FMan-Controller
-                data structures (e.g. BD rings).
-                Calling this routine changes the internal driver data base
-                from its default configuration
-                [DEFAULT_PORT_ImfwExtStructsMemId, DEFAULT_PORT_ImfwExtStructsMemAttr].
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     memId           Memory partition ID.
- @Param[in]     memAttributes   Memory attributes mask (a combination of MEMORY_ATTR_x flags).
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error  FM_PORT_ConfigIMFmanCtrlExternalStructsMemory(t_Handle h_FmPort,
-                                                       uint8_t  memId,
-                                                       uint32_t memAttributes);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigIMPolling
-
- @Description   Changes the Rx flow from interrupt driven (default) to polling.
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-                This routine is to be used only if Independent-Mode is enabled.
-*//***************************************************************************/
-t_Error FM_PORT_ConfigIMPolling(t_Handle h_FmPort);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigMaxFrameLength
-
- @Description   Changes the definition of the max size of frame that should be
-                transmitted/received on this port from its default value [DEFAULT_PORT_maxFrameLength].
-                This parameter is used for confirmation of the minimum Fifo
-                size calculations and only for Tx ports or ports working in
-                independent mode. This should be larger than the maximum possible
-                MTU that will be used for this port (i.e. its MAC).
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     length          Max size of frame
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-                This routine is to be used only if Independent-Mode is enabled.
-*//***************************************************************************/
-t_Error FM_PORT_ConfigMaxFrameLength(t_Handle h_FmPort, uint16_t length);
-
-/**************************************************************************//*
- @Function      FM_PORT_ConfigTxFifoMinFillLevel
-
- @Description   Calling this routine changes the fifo minimum
-                fill level parameter in the internal driver data base
-                from its default configuration  [DEFAULT_PORT_txFifoMinFillLevel]
-
-                May be used for Tx ports only
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     minFillLevel    New value
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel);
-
-/**************************************************************************//*
- @Function      FM_PORT_ConfigFifoDeqPipelineDepth
-
- @Description   Calling this routine changes the fifo dequeue
-                pipeline depth parameter in the internal driver data base
-
-                from its default configuration: 1G ports: [DEFAULT_PORT_fifoDeqPipelineDepth_1G],
-                10G port: [DEFAULT_PORT_fifoDeqPipelineDepth_10G],
-                OP port: [DEFAULT_PORT_fifoDeqPipelineDepth_OH]
-
-                May be used for Tx/OP ports only
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     deqPipelineDepth    New value
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelineDepth);
-
-/**************************************************************************//*
- @Function      FM_PORT_ConfigTxFifoLowComfLevel
-
- @Description   Calling this routine changes the fifo low comfort level
-                parameter in internal driver data base
-                from its default configuration [DEFAULT_PORT_txFifoLowComfLevel]
-
-                May be used for Tx ports only
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     fifoLowComfLevel    New value
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComfLevel);
-
-/**************************************************************************//*
- @Function      FM_PORT_ConfigRxFifoThreshold
-
- @Description   Calling this routine changes the threshold of the FIFO
-                fill level parameter in the internal driver data base
-                from its default configuration [DEFAULT_PORT_rxFifoThreshold]
-
-                If the total number of buffers which are
-                currently in use and associated with the
-                specific RX port exceed this threshold, the
-                BMI will signal the MAC to send a pause frame
-                over the link.
-
-                May be used for Rx ports only
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     fifoThreshold       New value
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold);
-
-/**************************************************************************//*
- @Function      FM_PORT_ConfigRxFifoPriElevationLevel
-
- @Description   Calling this routine changes the priority elevation level
-                parameter in the internal driver data base from its default
-                configuration  [DEFAULT_PORT_rxFifoPriElevationLevel]
-
-                If the total number of buffers which are currently in use and
-                associated with the specific RX port exceed the amount specified
-                in priElevationLevel, BMI will signal the main FM's DMA to
-                elevate the FM priority on the system bus.
-
-                May be used for Rx ports only
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     priElevationLevel   New value
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel);
-
-#ifdef FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
-/**************************************************************************//*
- @Function      FM_PORT_ConfigBCBWorkaround
-
- @Description   Configures BCB errata workaround.
-
-                When BCB errata is applicable, the workaround is always
-                performed by FM Controller. Thus, this functions doesn't
-                actually enable errata workaround but rather allows driver
-                to perform adjustments required due to errata workaround
-                execution in FM controller.
-
-                Applying BCB workaround also configures FM_PORT_FRM_ERR_PHYSICAL
-                errors to be discarded. Thus FM_PORT_FRM_ERR_PHYSICAL can't be
-                set by FM_PORT_SetErrorsRoute() function.
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigBCBWorkaround(t_Handle h_FmPort);
-#endif /* FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669 */
-
-#if (DPAA_VERSION >= 11)
-/**************************************************************************//*
- @Function      FM_PORT_ConfigInternalBuffOffset
-
- @Description   Configures internal buffer offset.
-
-                May be used for Rx and OP ports only
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     val                 New value
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigInternalBuffOffset(t_Handle h_FmPort, uint8_t val);
-#endif /* (DPAA_VERSION >= 11) */
-
-/** @} */ /* end of FM_PORT_advanced_init_grp group */
-/** @} */ /* end of FM_PORT_init_grp group */
-
-
-/**************************************************************************//**
- @Group         FM_PORT_runtime_control_grp FM Port Runtime Control Unit
-
- @Description   FM Port Runtime control unit API functions, definitions and enums.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   enum for defining FM Port counters
-*//***************************************************************************/
-typedef enum e_FmPortCounters {
-    e_FM_PORT_COUNTERS_CYCLE,                       /**< BMI performance counter */
-    e_FM_PORT_COUNTERS_TASK_UTIL,                   /**< BMI performance counter */
-    e_FM_PORT_COUNTERS_QUEUE_UTIL,                  /**< BMI performance counter */
-    e_FM_PORT_COUNTERS_DMA_UTIL,                    /**< BMI performance counter */
-    e_FM_PORT_COUNTERS_FIFO_UTIL,                   /**< BMI performance counter */
-    e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION,         /**< BMI Rx only performance counter */
-    e_FM_PORT_COUNTERS_FRAME,                       /**< BMI statistics counter */
-    e_FM_PORT_COUNTERS_DISCARD_FRAME,               /**< BMI statistics counter */
-    e_FM_PORT_COUNTERS_DEALLOC_BUF,                 /**< BMI deallocate buffer statistics counter */
-    e_FM_PORT_COUNTERS_RX_BAD_FRAME,                /**< BMI Rx only statistics counter */
-    e_FM_PORT_COUNTERS_RX_LARGE_FRAME,              /**< BMI Rx only statistics counter */
-    e_FM_PORT_COUNTERS_RX_FILTER_FRAME,             /**< BMI Rx & OP only statistics counter */
-    e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,             /**< BMI Rx, OP & HC only statistics counter */
-    e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx, OP & HC statistics counter */
-    e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER,  /**< BMI Rx, OP & HC only statistics counter */
-    e_FM_PORT_COUNTERS_WRED_DISCARD,                /**< BMI OP & HC only statistics counter */
-    e_FM_PORT_COUNTERS_LENGTH_ERR,                  /**< BMI non-Rx statistics counter */
-    e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,           /**< BMI non-Rx statistics counter */
-    e_FM_PORT_COUNTERS_DEQ_TOTAL,                   /**< QMI total QM dequeues counter */
-    e_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI total QM enqueues counter */
-    e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,            /**< QMI counter */
-    e_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
-} e_FmPortCounters;
-
-
-/**************************************************************************//**
- @Description   Structure for Port id parameters.
-                Fields commented 'IN' are passed by the port module to be used
-                by the FM module.
-                Fields commented 'OUT' will be filled by FM before returning to port.
-*//***************************************************************************/
-typedef struct t_FmPortCongestionGrps {
-    uint16_t    numOfCongestionGrpsToConsider;          /**< The number of required CGs
-                                                             to define the size of the following array */
-    uint8_t     congestionGrpsToConsider[FM_PORT_NUM_OF_CONGESTION_GRPS];
-                                                        /**< An array of CG indexes;
-                                                             Note that the size of the array should be
-                                                             'numOfCongestionGrpsToConsider'. */
-#if (DPAA_VERSION >= 11)
-    bool        pfcPrioritiesEn[FM_PORT_NUM_OF_CONGESTION_GRPS][FM_MAX_NUM_OF_PFC_PRIORITIES];
-                                                        /**< a matrix that represents the map between the CG ids
-                                                             defined in 'congestionGrpsToConsider' to the priorties
-                                                             mapping array. */
-#endif /* (DPAA_VERSION >= 11) */
-} t_FmPortCongestionGrps;
-
-/**************************************************************************//**
- @Description   Structure for Deep Sleep Auto Response ARP Entry
-*//***************************************************************************/
-typedef struct t_FmPortDsarArpEntry
-{
-    uint32_t  ipAddress;
-    uint8_t   mac[6];
-    bool      isVlan;
-    uint16_t  vid;
-} t_FmPortDsarArpEntry;
-
-/**************************************************************************//**
- @Description   Structure for Deep Sleep Auto Response ARP info
-*//***************************************************************************/
-typedef struct t_FmPortDsarArpInfo
-{
-    uint8_t           tableSize;
-    t_FmPortDsarArpEntry *p_AutoResTable;
-    bool              enableConflictDetection; /* when TRUE Conflict Detection will be checked and wake the host if needed */
-} t_FmPortDsarArpInfo;
-
-/**************************************************************************//**
- @Description   Structure for Deep Sleep Auto Response NDP Entry
-*//***************************************************************************/
-typedef struct t_FmPortDsarNdpEntry
-{
-    uint32_t  ipAddress[4];
-    uint8_t   mac[6];
-    bool      isVlan;
-    uint16_t  vid;
-} t_FmPortDsarNdpEntry;
-
-/**************************************************************************//**
- @Description   Structure for Deep Sleep Auto Response NDP info
-*//***************************************************************************/
-typedef struct t_FmPortDsarNdpInfo
-{
-    uint32_t              multicastGroup;
-
-    uint8_t               tableSizeAssigned;
-    t_FmPortDsarNdpEntry  *p_AutoResTableAssigned; /* This list refer to solicitation IP addresses.
-                                                                 Note that all IP adresses must be from the same multicast group.
-                                                                 This will be checked and if not operation will fail. */
-    uint8_t               tableSizeTmp;
-    t_FmPortDsarNdpEntry  *p_AutoResTableTmp;      /* This list refer to temp IP addresses.
-                                                             Note that all temp IP adresses must be from the same multicast group.
-                                                             This will be checked and if not operation will fail. */
-
-    bool                  enableConflictDetection; /* when TRUE Conflict Detection will be checked and wake the host if needed */
-
-} t_FmPortDsarNdpInfo;
-
-/**************************************************************************//**
- @Description   Structure for Deep Sleep Auto Response ICMPV4 info
-*//***************************************************************************/
-typedef struct t_FmPortDsarEchoIpv4Info
-{
-    uint8_t            tableSize;
-    t_FmPortDsarArpEntry  *p_AutoResTable;
-} t_FmPortDsarEchoIpv4Info;
-
-/**************************************************************************//**
- @Description   Structure for Deep Sleep Auto Response ICMPV6 info
-*//***************************************************************************/
-typedef struct t_FmPortDsarEchoIpv6Info
-{
-    uint8_t            tableSize;
-    t_FmPortDsarNdpEntry  *p_AutoResTable;
-} t_FmPortDsarEchoIpv6Info;
-
-/**************************************************************************//**
-@Description    Deep Sleep Auto Response SNMP OIDs table entry
-
-*//***************************************************************************/
-typedef struct {
-    uint16_t oidSize;     /**< Size in octets of the OID. */
-    uint16_t resSize;     /**< Size in octets of the value that is attached to the OID. */
-    uint8_t *p_Oid;       /**< Pointer to the OID. OID is encoded in BER but type and length are excluded. */
-    uint64_t resValOrPtr; /**< Value (for up to 4 octets) or pointer to the Value. Encoded in BER. */
-} t_FmPortDsarOidsEntry;
-
-/**************************************************************************//**
- @Description   Deep Sleep Auto Response SNMP IPv4 Addresses Table Entry
-                Refer to the FMan Controller spec for more details.
-*//***************************************************************************/
-typedef struct
-{
-    uint32_t ipv4Addr; /*!< 32 bit IPv4 Address. */
-    bool      isVlan;
-    uint16_t vid;   /*!< 12 bits VLAN ID. The 4 left-most bits should be cleared                      */
-                       /*!< This field should be 0x0000 for an entry with no VLAN tag or a null VLAN ID. */
-} t_FmPortDsarSnmpIpv4AddrTblEntry;
-
-/**************************************************************************//**
- @Description   Deep Sleep Auto Response SNMP IPv6 Addresses Table Entry
-                Refer to the FMan Controller spec for more details.
-*//***************************************************************************/
-typedef struct
-{
-    uint32_t ipv6Addr[4];  /*!< 4 * 32 bit IPv6 Address.                                                     */
-    bool      isVlan;
-    uint16_t vid;       /*!< 12 bits VLAN ID. The 4 left-most bits should be cleared                      */
-                           /*!< This field should be 0x0000 for an entry with no VLAN tag or a null VLAN ID. */
-} t_FmPortDsarSnmpIpv6AddrTblEntry;
-
-/**************************************************************************//**
- @Description   Deep Sleep Auto Response SNMP Descriptor
-
-*//***************************************************************************/
-typedef struct
-{
-    uint16_t control;                          /**< Control bits [0-15]. */
-    uint16_t maxSnmpMsgLength;                 /**< Maximal allowed SNMP message length. */
-    uint16_t numOfIpv4Addresses;               /**< Number of entries in IPv4 addresses table. */
-    uint16_t numOfIpv6Addresses;               /**< Number of entries in IPv6 addresses table. */
-    t_FmPortDsarSnmpIpv4AddrTblEntry *p_Ipv4AddrTbl; /**< Pointer to IPv4 addresses table. */
-    t_FmPortDsarSnmpIpv6AddrTblEntry *p_Ipv6AddrTbl; /**< Pointer to IPv6 addresses table. */
-    uint8_t *p_RdOnlyCommunityStr;             /**< Pointer to the Read Only Community String. */
-    uint8_t *p_RdWrCommunityStr;               /**< Pointer to the Read Write Community String. */
-    t_FmPortDsarOidsEntry *p_OidsTbl;                 /**< Pointer to OIDs table. */
-    uint32_t oidsTblSize;                      /**< Number of entries in OIDs table. */
-} t_FmPortDsarSnmpInfo;
-
-/**************************************************************************//**
- @Description   Structure for Deep Sleep Auto Response filtering Entry
-*//***************************************************************************/
-typedef struct t_FmPortDsarFilteringEntry
-{
-    uint16_t    srcPort;
-    uint16_t    dstPort;
-    uint16_t    srcPortMask;
-    uint16_t    dstPortMask;
-} t_FmPortDsarFilteringEntry;
-
-/**************************************************************************//**
- @Description   Structure for Deep Sleep Auto Response filtering info
-*//***************************************************************************/
-typedef struct t_FmPortDsarFilteringInfo
-{
-    /* IP protocol filtering parameters */
-    uint8_t     ipProtTableSize;
-    uint8_t     *p_IpProtTablePtr;
-    bool        ipProtDropOnHit;  /* when TRUE, hit in the table will cause the packet to be droped,
-                                         miss will pass the packet to UDP/TCP filters if needed and if not
-                                         to the classification tree. If the classification tree will pass
-                                         the packet to a queue it will cause a wake interupt.
-                                         When FALSE it the other way around. */
-    /* UDP port filtering parameters */
-    uint8_t     udpPortsTableSize;
-    t_FmPortDsarFilteringEntry *p_UdpPortsTablePtr;
-    bool        udpPortDropOnHit; /* when TRUE, hit in the table will cause the packet to be droped,
-                                         miss will pass the packet to classification tree.
-                                         If the classification tree will pass the packet to a queue it
-                                         will cause a wake interupt.
-                                         When FALSE it the other way around. */
-    /* TCP port filtering parameters */
-    uint16_t    tcpFlagsMask;
-    uint8_t     tcpPortsTableSize;
-    t_FmPortDsarFilteringEntry *p_TcpPortsTablePtr;
-    bool        tcpPortDropOnHit; /* when TRUE, hit in the table will cause the packet to be droped,
-                                         miss will pass the packet to classification tree.
-                                         If the classification tree will pass the packet to a queue it
-                                         will cause a wake interupt.
-                                         When FALSE it the other way around. */
-} t_FmPortDsarFilteringInfo;
-
-/**************************************************************************//**
- @Description   Structure for Deep Sleep Auto Response parameters
-*//***************************************************************************/
-typedef struct t_FmPortDsarParams
-{
-    t_Handle                  h_FmPortTx;
-    t_FmPortDsarArpInfo       *p_AutoResArpInfo;
-    t_FmPortDsarEchoIpv4Info  *p_AutoResEchoIpv4Info;
-    t_FmPortDsarNdpInfo       *p_AutoResNdpInfo;
-    t_FmPortDsarEchoIpv6Info  *p_AutoResEchoIpv6Info;
-    t_FmPortDsarSnmpInfo      *p_AutoResSnmpInfo;
-    t_FmPortDsarFilteringInfo *p_AutoResFilteringInfo;
-} t_FmPortDsarParams;
-
-/**************************************************************************//**
- @Function      FM_PORT_EnterDsar
-
- @Description   Enter Deep Sleep Auto Response mode.
-                This function write the apropriate values to in the relevant
-                tables in the MURAM. It then set the Tx port in independent
-                mode as needed and redirect the receive flow to go through the
-                Dsar Fman-ctrl code
-
-                Calling this routine invalidates the descriptor.
-
- @Param[in]     h_FmPortRx - FM PORT module descriptor
- @Param[in]     params - Auto Response parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params);
-
-/**************************************************************************//**
- @Function      FM_PORT_ExitDsar
-
- @Description   Exit Deep Sleep Auto Response mode.
-                This function reverse the AR mode and put the ports back into
-                their original wake mode
-
- @Param[in]     h_FmPortRx - FM PORT Rx module descriptor
- @Param[in]     h_FmPortTx - FM PORT Tx module descriptor
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_EnterDsar().
-*//***************************************************************************/
-void FM_PORT_ExitDsar(t_Handle h_FmPortRx, t_Handle h_FmPortTx);
-
-/**************************************************************************//**
- @Function      FM_PORT_IsInDsar
-
- @Description   This function returns TRUE if the port was set as Auto Response
-                and FALSE if not. Once Exit AR mode it will return FALSE as well
-                until re-enabled once more.
-
- @Param[in]     h_FmPort - FM PORT module descriptor
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-bool FM_PORT_IsInDsar(t_Handle h_FmPort);
-
-typedef struct t_FmPortDsarStats
-{
-    uint32_t arpArCnt;
-    uint32_t echoIcmpv4ArCnt;
-    uint32_t ndpArCnt;
-    uint32_t echoIcmpv6ArCnt;
-    uint32_t snmpGetCnt;
-    uint32_t snmpGetNextCnt;
-} t_FmPortDsarStats;
-
-/**************************************************************************//**
- @Function      FM_PORT_GetDsarStats
-
- @Description   Return statistics for Deep Sleep Auto Response
-
- @Param[in]     h_FmPortRx - FM PORT module descriptor
- @Param[out]    stats - structure containing the statistics counters
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-t_Error FM_PORT_GetDsarStats(t_Handle h_FmPortRx, t_FmPortDsarStats *stats);
-
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-/**************************************************************************//**
- @Function      FM_PORT_DumpRegs
-
- @Description   Dump all regs.
-
-                Calling this routine invalidates the descriptor.
-
- @Param[in]     h_FmPort - FM PORT module descriptor
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_DumpRegs(t_Handle h_FmPort);
-#endif /* (defined(DEBUG_ERRORS) && ... */
-
-/**************************************************************************//**
- @Function      FM_PORT_GetBufferDataOffset
-
- @Description   Relevant for Rx ports.
-                Returns the data offset from the beginning of the data buffer
-
- @Param[in]     h_FmPort - FM PORT module descriptor
-
- @Return        data offset.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-uint32_t FM_PORT_GetBufferDataOffset(t_Handle h_FmPort);
-
-/**************************************************************************//**
- @Function      FM_PORT_GetBufferICInfo
-
- @Description   Returns the Internal Context offset from the beginning of the data buffer
-
- @Param[in]     h_FmPort - FM PORT module descriptor
- @Param[in]     p_Data   - A pointer to the data buffer.
-
- @Return        Internal context info pointer on success, NULL if 'allOtherInfo' was not
-                configured for this port.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data);
-
-/**************************************************************************//**
- @Function      FM_PORT_GetBufferPrsResult
-
- @Description   Returns the pointer to the parse result in the data buffer.
-                In Rx ports this is relevant after reception, if parse
-                result is configured to be part of the data passed to the
-                application. For non Rx ports it may be used to get the pointer
-                of the area in the buffer where parse result should be
-                initialized - if so configured.
-                See FM_PORT_ConfigBufferPrefixContent for data buffer prefix
-                configuration.
-
- @Param[in]     h_FmPort    - FM PORT module descriptor
- @Param[in]     p_Data      - A pointer to the data buffer.
-
- @Return        Parse result pointer on success, NULL if parse result was not
-                configured for this port.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data);
-
-/**************************************************************************//**
- @Function      FM_PORT_GetBufferTimeStamp
-
- @Description   Returns the time stamp in the data buffer.
-                Relevant for Rx ports for getting the buffer time stamp.
-                See FM_PORT_ConfigBufferPrefixContent for data buffer prefix
-                configuration.
-
- @Param[in]     h_FmPort    - FM PORT module descriptor
- @Param[in]     p_Data      - A pointer to the data buffer.
-
- @Return        A pointer to the hash result on success, NULL otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-uint64_t * FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data);
-
-/**************************************************************************//**
- @Function      FM_PORT_GetBufferHashResult
-
- @Description   Given a data buffer, on the condition that hash result was defined
-                as a part of the buffer content (see FM_PORT_ConfigBufferPrefixContent)
-                this routine will return the pointer to the hash result location in the
-                buffer prefix.
-
- @Param[in]     h_FmPort    - FM PORT module descriptor
- @Param[in]     p_Data      - A pointer to the data buffer.
-
- @Return        A pointer to the hash result on success, NULL otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-uint8_t * FM_PORT_GetBufferHashResult(t_Handle h_FmPort, char *p_Data);
-
-/**************************************************************************//**
- @Function      FM_PORT_Disable
-
- @Description   Gracefully disable an FM port. The port will not start new tasks after all
-                tasks associated with the port are terminated.
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-                This is a blocking routine, it returns after port is
-                gracefully stopped, i.e. the port will not except new frames,
-                but it will finish all frames or tasks which were already began
-*//***************************************************************************/
-t_Error FM_PORT_Disable(t_Handle h_FmPort);
-
-/**************************************************************************//**
- @Function      FM_PORT_Enable
-
- @Description   A runtime routine provided to allow disable/enable of port.
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_Enable(t_Handle h_FmPort);
-
-/**************************************************************************//**
- @Function      FM_PORT_SetRateLimit
-
- @Description   Calling this routine enables rate limit algorithm.
-                By default, this functionality is disabled.
-                Note that rate-limit mechanism uses the FM time stamp.
-                The selected rate limit specified here would be
-                rounded DOWN to the nearest 16M.
-
-                May be used for Tx and OP ports only
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     p_RateLimit     A structure of rate limit parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-                If rate limit is set on a port that need to send PFC frames,
-                it might violate the stop transmit timing.
-*//***************************************************************************/
-t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit);
-
-/**************************************************************************//**
- @Function      FM_PORT_DeleteRateLimit
-
- @Description   Calling this routine disables and clears rate limit
-                initialization.
-
-                May be used for Tx and OP ports only
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort);
-
-/**************************************************************************//**
- @Function      FM_PORT_SetPfcPrioritiesMappingToQmanWQ
-
- @Description   Calling this routine maps each PFC received priority to the transmit WQ.
-                This WQ will be blocked upon receiving a PFC frame with this priority.
-
-                May be used for Tx ports only.
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     prio            PFC priority (0-7).
- @Param[in]     wq              Work Queue (0-7).
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_SetPfcPrioritiesMappingToQmanWQ(t_Handle h_FmPort, uint8_t prio, uint8_t wq);
-
-/**************************************************************************//**
- @Function      FM_PORT_SetStatisticsCounters
-
- @Description   Calling this routine enables/disables port's statistics counters.
-                By default, counters are enabled.
-
-                May be used for all port types
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     enable      TRUE to enable, FALSE to disable.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable);
-
-/**************************************************************************//**
- @Function      FM_PORT_SetFrameQueueCounters
-
- @Description   Calling this routine enables/disables port's enqueue/dequeue counters.
-                By default, counters are enabled.
-
-                May be used for all ports
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     enable      TRUE to enable, FALSE to disable.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable);
-
-/**************************************************************************//**
- @Function      FM_PORT_AnalyzePerformanceParams
-
- @Description   User may call this routine to so the driver will analyze if the
-                basic performance parameters are correct and also the driver may
-                suggest of improvements; The basic parameters are FIFO sizes, number
-                of DMAs and number of TNUMs for the port.
-
-                May be used for all port types
-
- @Param[in]     h_FmPort                A handle to a FM Port module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort);
-
-
-/**************************************************************************//**
- @Function      FM_PORT_SetAllocBufCounter
-
- @Description   Calling this routine enables/disables BM pool allocate
-                buffer counters.
-                By default, counters are enabled.
-
-                May be used for Rx ports only
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     poolId      BM pool id.
- @Param[in]     enable      TRUE to enable, FALSE to disable.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable);
-
-/**************************************************************************//**
- @Function      FM_PORT_GetCounter
-
- @Description   Reads one of the FM PORT counters.
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     fmPortCounter       The requested counter.
-
- @Return        Counter's current value.
-
- @Cautions      Allowed only following FM_PORT_Init().
-                Note that it is user's responsibility to call this routine only
-                for enabled counters, and there will be no indication if a
-                disabled counter is accessed.
-*//***************************************************************************/
-uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters fmPortCounter);
-
-/**************************************************************************//**
- @Function      FM_PORT_ModifyCounter
-
- @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     fmPortCounter       The requested counter.
- @Param[in]     value               The requested value to be written into the counter.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters fmPortCounter, uint32_t value);
-
-/**************************************************************************//**
- @Function      FM_PORT_GetAllocBufCounter
-
- @Description   Reads one of the FM PORT buffer counters.
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     poolId              The requested pool.
-
- @Return        Counter's current value.
-
- @Cautions      Allowed only following FM_PORT_Init().
-                Note that it is user's responsibility to call this routine only
-                for enabled counters, and there will be no indication if a
-                disabled counter is accessed.
-*//***************************************************************************/
-uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId);
-
-/**************************************************************************//**
- @Function      FM_PORT_ModifyAllocBufCounter
-
- @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     poolId              The requested pool.
- @Param[in]     value               The requested value to be written into the counter.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort,  uint8_t poolId, uint32_t value);
-
-/**************************************************************************//**
- @Function      FM_PORT_AddCongestionGrps
-
- @Description   This routine effects the corresponding Tx port.
-                It should be called in order to enable pause
-                frame transmission in case of congestion in one or more
-                of the congestion groups relevant to this port.
-                Each call to this routine may add one or more congestion
-                groups to be considered relevant to this port.
-
-                May be used for Rx, or RX+OP ports only (depending on chip)
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     p_CongestionGrps    A pointer to an array of congestion groups
-                                    id's to consider.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps);
-
-/**************************************************************************//**
- @Function      FM_PORT_RemoveCongestionGrps
-
- @Description   This routine effects the corresponding Tx port. It should be
-                called when congestion groups were
-                defined for this port and are no longer relevant, or pause
-                frames transmitting is not required on their behalf.
-                Each call to this routine may remove one or more congestion
-                groups to be considered relevant to this port.
-
-                May be used for Rx, or RX+OP ports only (depending on chip)
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     p_CongestionGrps    A pointer to an array of congestion groups
-                                    id's to consider.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps);
-
-/**************************************************************************//**
- @Function      FM_PORT_IsStalled
-
- @Description   A routine for checking whether the specified port is stalled.
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
-
- @Return        TRUE if port is stalled, FALSE otherwize
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-bool FM_PORT_IsStalled(t_Handle h_FmPort);
-
-/**************************************************************************//**
- @Function      FM_PORT_ReleaseStalled
-
- @Description   This routine may be called in case the port was stalled and may
-                now be released.
-                Note that this routine is available only on older FMan revisions
-                (FMan v2, DPAA v1.0 only).
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ReleaseStalled(t_Handle h_FmPort);
-
-/**************************************************************************//**
- @Function      FM_PORT_SetRxL4ChecksumVerify
-
- @Description   This routine is relevant for Rx ports (1G and 10G). The routine
-                set/clear the L3/L4 checksum verification (on RX side).
-                Note that this takes affect only if hw-parser is enabled!
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     l4Checksum      boolean indicates whether to do L3/L4 checksum
-                                on frames or not.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_SetRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum);
-
-/**************************************************************************//**
- @Function      FM_PORT_SetErrorsRoute
-
- @Description   Errors selected for this routine will cause a frame with that error
-                to be enqueued to error queue.
-                Errors not selected for this routine will cause a frame with that error
-                to be enqueued to the one of the other port queues.
-                By default all errors are defined to be enqueued to error queue.
-                Errors that were configured to be discarded (at initialization)
-                may not be selected here.
-
-                May be used for Rx and OP ports only
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     errs        A list of errors to enqueue to error queue
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
-
-/**************************************************************************//**
- @Function      FM_PORT_SetIMExceptions
-
- @Description   Calling this routine enables/disables FM PORT interrupts.
-
- @Param[in]     h_FmPort        FM PORT module descriptor.
- @Param[in]     exception       The exception to be selected.
- @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
-*//***************************************************************************/
-t_Error FM_PORT_SetIMExceptions(t_Handle h_FmPort, e_FmPortExceptions exception, bool enable);
-
-/**************************************************************************//*
- @Function      FM_PORT_SetPerformanceCounters
-
- @Description   Calling this routine enables/disables port's performance counters.
-                By default, counters are enabled.
-
-                May be used for all port types
-
- @Param[in]     h_FmPort                A handle to a FM Port module.
- @Param[in]     enable                  TRUE to enable, FALSE to disable.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable);
-
-/**************************************************************************//*
- @Function      FM_PORT_SetPerformanceCountersParams
-
- @Description   Calling this routine defines port's performance
-                counters parameters.
-
-                May be used for all port types
-
- @Param[in]     h_FmPort                A handle to a FM Port module.
- @Param[in]     p_FmPortPerformanceCnt  A pointer to a structure of performance
-                                        counters parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt);
-
-/**************************************************************************//**
- @Group         FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
-
- @Description   FM Port PCD Runtime control unit API functions, definitions and enums.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   A structure defining the KG scheme after the parser.
-                This is relevant only to change scheme selection mode - from
-                direct to indirect and vice versa, or when the scheme is selected directly,
-                to select the scheme id.
-
-*//***************************************************************************/
-typedef struct t_FmPcdKgSchemeSelect {
-    bool        direct;                 /**< TRUE to use 'h_Scheme' directly, FALSE to use LCV. */
-    t_Handle    h_DirectScheme;         /**< Scheme handle, selects the scheme after parser;
-                                             Relevant only when 'direct' is TRUE. */
-} t_FmPcdKgSchemeSelect;
-
-/**************************************************************************//**
- @Description   A structure of scheme parameters
-*//***************************************************************************/
-typedef struct t_FmPcdPortSchemesParams {
-    uint8_t     numOfSchemes;                           /**< Number of schemes for port to be bound to. */
-    t_Handle    h_Schemes[FM_PCD_KG_NUM_OF_SCHEMES];    /**< Array of 'numOfSchemes' schemes for the
-                                                             port to be bound to */
-} t_FmPcdPortSchemesParams;
-
-/**************************************************************************//**
- @Description   Union for defining port protocol parameters for parser
-*//***************************************************************************/
-typedef union u_FmPcdHdrPrsOpts {
-    /* MPLS */
-    struct {
-        bool            labelInterpretationEnable;  /**< When this bit is set, the last MPLS label will be
-                                                         interpreted as described in HW spec table. When the bit
-                                                         is cleared, the parser will advance to MPLS next parse */
-        e_NetHeaderType nextParse;                  /**< must be equal or higher than IPv4 */
-    } mplsPrsOptions;
-    /* VLAN */
-    struct {
-        uint16_t        tagProtocolId1;             /**< User defined Tag Protocol Identifier, to be recognized
-                                                         on VLAN TAG on top of 0x8100 and 0x88A8 */
-        uint16_t        tagProtocolId2;             /**< User defined Tag Protocol Identifier, to be recognized
-                                                         on VLAN TAG on top of 0x8100 and 0x88A8 */
-    } vlanPrsOptions;
-    /* PPP */
-    struct{
-        bool            enableMTUCheck;             /**< Check validity of MTU according to RFC2516 */
-    } pppoePrsOptions;
-
-    /* IPV6 */
-    struct{
-        bool            routingHdrEnable;          /**< TRUE to enable routing header, otherwise ignore */
-    } ipv6PrsOptions;
-
-    /* UDP */
-    struct{
-        bool            padIgnoreChecksum;          /**< TRUE to ignore pad in checksum */
-    } udpPrsOptions;
-
-    /* TCP */
-    struct {
-        bool            padIgnoreChecksum;          /**< TRUE to ignore pad in checksum */
-    } tcpPrsOptions;
-} u_FmPcdHdrPrsOpts;
-
-/**************************************************************************//**
- @Description   A structure for defining each header for the parser
-*//***************************************************************************/
-typedef struct t_FmPcdPrsAdditionalHdrParams {
-    e_NetHeaderType         hdr;            /**< Selected header */
-    bool                    errDisable;     /**< TRUE to disable error indication */
-    bool                    swPrsEnable;    /**< Enable jump to SW parser when this
-                                                 header is recognized by the HW parser. */
-    uint8_t                 indexPerHdr;    /**< Normally 0, if more than one sw parser
-                                                 attachments exists for the same header,
-                                                 (in the main sw parser code) use this
-                                                 index to distinguish between them. */
-    bool                    usePrsOpts;     /**< TRUE to use parser options. */
-    u_FmPcdHdrPrsOpts       prsOpts;        /**< A union according to header type,
-                                                 defining the parser options selected.*/
-} t_FmPcdPrsAdditionalHdrParams;
-
-/**************************************************************************//**
- @Description   struct for defining port PCD parameters
-*//***************************************************************************/
-typedef struct t_FmPortPcdPrsParams {
-    uint8_t                         prsResultPrivateInfo;           /**< The private info provides a method of inserting
-                                                                         port information into the parser result. This information
-                                                                         may be extracted by Keygen and be used for frames
-                                                                         distribution when a per-port distinction is required,
-                                                                         it may also be used as a port logical id for analyzing
-                                                                         incoming frames. */
-    uint8_t                         parsingOffset;                  /**< Number of bytes from beginning of packet to start parsing */
-    e_NetHeaderType                 firstPrsHdr;                    /**< The type of the first header expected at 'parsingOffset' */
-    bool                            includeInPrsStatistics;         /**< TRUE to include this port in the parser statistics;
-                                                                         NOTE: this field is not valid when the FM is in "guest" mode
-                                                                               and IPC is not available. */
-    uint8_t                         numOfHdrsWithAdditionalParams;  /**< Normally 0, some headers may get
-                                                                         special parameters */
-    t_FmPcdPrsAdditionalHdrParams   additionalParams[FM_PCD_PRS_NUM_OF_HDRS];
-                                                                    /**< 'numOfHdrsWithAdditionalParams'  structures
-                                                                         of additional parameters
-                                                                         for each header that requires them */
-    bool                            setVlanTpid1;                   /**< TRUE to configure user selection of Ethertype to
-                                                                         indicate a VLAN tag (in addition to the TPID values
-                                                                         0x8100 and 0x88A8). */
-    uint16_t                        vlanTpid1;                      /**< extra tag to use if setVlanTpid1=TRUE. */
-    bool                            setVlanTpid2;                   /**< TRUE to configure user selection of Ethertype to
-                                                                         indicate a VLAN tag (in addition to the TPID values
-                                                                         0x8100 and 0x88A8). */
-    uint16_t                        vlanTpid2;                      /**< extra tag to use if setVlanTpid1=TRUE. */
-} t_FmPortPcdPrsParams;
-
-/**************************************************************************//**
- @Description   struct for defining coarse alassification parameters
-*//***************************************************************************/
-typedef struct t_FmPortPcdCcParams {
-    t_Handle            h_CcTree;                       /**< A handle to a CC tree */
-} t_FmPortPcdCcParams;
-
-/**************************************************************************//**
- @Description   struct for defining keygen parameters
-*//***************************************************************************/
-typedef struct t_FmPortPcdKgParams {
-    uint8_t             numOfSchemes;                   /**< Number of schemes for port to be bound to. */
-    t_Handle            h_Schemes[FM_PCD_KG_NUM_OF_SCHEMES];
-                                                        /**< Array of 'numOfSchemes' schemes handles for the
-                                                             port to be bound to */
-    bool                directScheme;                   /**< TRUE for going from parser to a specific scheme,
-                                                             regardless of parser result */
-    t_Handle            h_DirectScheme;                 /**< relevant only if direct == TRUE, Scheme handle,
-                                                             as returned by FM_PCD_KgSetScheme */
-} t_FmPortPcdKgParams;
-
-/**************************************************************************//**
- @Description   struct for defining policer parameters
-*//***************************************************************************/
-typedef struct t_FmPortPcdPlcrParams {
-    t_Handle                h_Profile;          /**< Selected profile handle */
-} t_FmPortPcdPlcrParams;
-
-/**************************************************************************//**
- @Description   struct for defining port PCD parameters
-*//***************************************************************************/
-typedef struct t_FmPortPcdParams {
-    e_FmPortPcdSupport      pcdSupport;         /**< Relevant for Rx and offline ports only.
-                                                     Describes the active PCD engines for this port. */
-    t_Handle                h_NetEnv;           /**< HL Unused in PLCR only mode */
-    t_FmPortPcdPrsParams    *p_PrsParams;       /**< Parser parameters for this port */
-    t_FmPortPcdCcParams     *p_CcParams;        /**< Coarse classification parameters for this port */
-    t_FmPortPcdKgParams     *p_KgParams;        /**< Keygen parameters for this port */
-    t_FmPortPcdPlcrParams   *p_PlcrParams;      /**< Policer parameters for this port; Relevant for one of
-                                                     following cases:
-                                                     e_FM_PORT_PCD_SUPPORT_PLCR_ONLY or
-                                                     e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR were selected,
-                                                     or if any flow uses a KG scheme were policer
-                                                     profile is not generated
-                                                     ('bypassPlcrProfileGeneration selected'). */
-    t_Handle                h_IpReassemblyManip;    /**< IP Reassembly manipulation */
-#if (DPAA_VERSION >= 11)
-    t_Handle                h_CapwapReassemblyManip;/**< CAPWAP Reassembly manipulation */
-#endif /* (DPAA_VERSION >= 11) */
-} t_FmPortPcdParams;
-
-/**************************************************************************//**
- @Description   A structure for defining the Parser starting point
-*//***************************************************************************/
-typedef struct t_FmPcdPrsStart {
-    uint8_t             parsingOffset;  /**< Number of bytes from beginning of packet to
-                                             start parsing */
-    e_NetHeaderType     firstPrsHdr;    /**< The type of the first header axpected at
-                                             'parsingOffset' */
-} t_FmPcdPrsStart;
-
-#if (DPAA_VERSION >= 11)
-/**************************************************************************//**
- @Description   struct for defining external buffer margins
-*//***************************************************************************/
-typedef struct t_FmPortVSPAllocParams {
-    uint8_t     numOfProfiles;          /**< Number of Virtual Storage Profiles; must be a power of 2 */
-    uint8_t     dfltRelativeId;         /**< The default Virtual-Storage-Profile-id dedicated to Rx/OP port
-                                             The same default Virtual-Storage-Profile-id will be for coupled Tx port
-                                             if relevant function called for Rx port */
-    t_Handle    h_FmTxPort;             /**< Handle to coupled Tx Port; not relevant for OP port. */
-} t_FmPortVSPAllocParams;
-#endif /* (DPAA_VERSION >= 11) */
-
-
-/**************************************************************************//**
- @Function      FM_PORT_SetPCD
-
- @Description   Calling this routine defines the port's PCD configuration.
-                It changes it from its default configuration which is PCD
-                disabled (BMI to BMI) and configures it according to the passed
-                parameters.
-
-                May be used for Rx and OP ports only
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     p_FmPortPcd     A Structure of parameters defining the port's PCD
-                                configuration.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_FmPortPcd);
-
-/**************************************************************************//**
- @Function      FM_PORT_DeletePCD
-
- @Description   Calling this routine releases the port's PCD configuration.
-                The port returns to its default configuration which is PCD
-                disabled (BMI to BMI) and all PCD configuration is removed.
-
-                May be used for Rx and OP ports which are
-                in PCD mode  only
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_DeletePCD(t_Handle h_FmPort);
-
-/**************************************************************************//**
- @Function      FM_PORT_AttachPCD
-
- @Description   This routine may be called after FM_PORT_DetachPCD was called,
-                to return to the originally configured PCD support flow.
-                The couple of routines are used to allow PCD configuration changes
-                that demand that PCD will not be used while changes take place.
-
-                May be used for Rx and OP ports which are
-                in PCD mode only
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_AttachPCD(t_Handle h_FmPort);
-
-/**************************************************************************//**
- @Function      FM_PORT_DetachPCD
-
- @Description   Calling this routine detaches the port from its PCD functionality.
-                The port returns to its default flow which is BMI to BMI.
-
-                May be used for Rx and OP ports which are
-                in PCD mode only
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_AttachPCD().
-*//***************************************************************************/
-t_Error FM_PORT_DetachPCD(t_Handle h_FmPort);
-
-/**************************************************************************//**
- @Function      FM_PORT_PcdPlcrAllocProfiles
-
- @Description   This routine may be called only for ports that use the Policer in
-                order to allocate private policer profiles.
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     numOfProfiles       The number of required policer profiles
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(),
-                and before FM_PORT_SetPCD().
-*//***************************************************************************/
-t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles);
-
-/**************************************************************************//**
- @Function      FM_PORT_PcdPlcrFreeProfiles
-
- @Description   This routine should be called for freeing private policer profiles.
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(),
-                and before FM_PORT_SetPCD().
-*//***************************************************************************/
-t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort);
-
-#if (DPAA_VERSION >= 11)
-/**************************************************************************//**
- @Function      FM_PORT_VSPAlloc
-
- @Description   This routine allocated VSPs per port and forces the port to work
-                in VSP mode. Note that the port is initialized by default with the
-                physical-storage-profile only.
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     p_Params    A structure of parameters for allocation VSP's per port
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init(), and before FM_PORT_SetPCD()
-                and also before FM_PORT_Enable(); i.e. the port should be disabled.
-*//***************************************************************************/
-t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_Params);
-#endif /* (DPAA_VERSION >= 11) */
-
-/**************************************************************************//**
- @Function      FM_PORT_PcdKgModifyInitialScheme
-
- @Description   This routine may be called only for ports that use the keygen in
-                order to change the initial scheme frame should be routed to.
-                The change may be of a scheme id (in case of direct mode),
-                from direct to indirect, or from indirect to direct - specifying the scheme id.
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     p_FmPcdKgScheme     A structure of parameters for defining whether
-                                    a scheme is direct/indirect, and if direct - scheme id.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
-*//***************************************************************************/
-t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSelect *p_FmPcdKgScheme);
-
-/**************************************************************************//**
- @Function      FM_PORT_PcdPlcrModifyInitialProfile
-
- @Description   This routine may be called for ports with flows
-                e_FM_PORT_PCD_SUPPORT_PLCR_ONLY or e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR
-                only, to change the initial Policer profile frame should be
-                routed to. The change may be of a profile and/or absolute/direct
-                mode selection.
-
- @Param[in]     h_FmPort                A handle to a FM Port module.
- @Param[in]     h_Profile               Policer profile handle
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
-*//***************************************************************************/
-t_Error FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_Profile);
-
-/**************************************************************************//**
- @Function      FM_PORT_PcdCcModifyTree
-
- @Description   This routine may be called for ports that use coarse classification tree
-                if the user wishes to replace the tree. The routine may not be called while port
-                receives packets using the PCD functionalities, therefor port must be first detached
-                from the PCD, only than the routine may be called, and than port be attached to PCD again.
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     h_CcTree            A CC tree that was already built. The tree id as returned from
-                                    the BuildTree routine.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init(), FM_PORT_SetPCD() and FM_PORT_DetachPCD()
-*//***************************************************************************/
-t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree);
-
-/**************************************************************************//**
- @Function      FM_PORT_PcdKgBindSchemes
-
- @Description   These routines may be called for adding more schemes for the
-                port to be bound to. The selected schemes are not added,
-                just this specific port starts using them.
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     p_PortScheme    A structure defining the list of schemes to be added.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
-*//***************************************************************************/
-t_Error FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
-
-/**************************************************************************//**
- @Function      FM_PORT_PcdKgUnbindSchemes
-
- @Description   These routines may be called for adding more schemes for the
-                port to be bound to. The selected schemes are not removed or invalidated,
-                just this specific port stops using them.
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     p_PortScheme    A structure defining the list of schemes to be added.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
-*//***************************************************************************/
-t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
-
-/**************************************************************************//**
- @Function      FM_PORT_PcdPrsModifyStartOffset
-
- @Description   Runtime change of the parser start offset within the header.
-                The routine may not be called while port
-                receives packets using the PCD functionalities, therefore port must be first detached
-                from the PCD, only than the routine may be called, and than port be attached to PCD again.
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     p_FmPcdPrsStart A structure of parameters for defining the
-                                start point for the parser.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init(), FM_PORT_SetPCD() and FM_PORT_DetatchPCD().
-*//***************************************************************************/
-t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart);
-
-/**************************************************************************//**
- @Function      FM_PORT_GetIPv4OptionsCount
-
- @Description   TODO
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[out]    p_Ipv4OptionsCount  will hold the counter value
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init()
-*//***************************************************************************/
-t_Error FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort, uint32_t *p_Ipv4OptionsCount);
-
-/** @} */ /* end of FM_PORT_pcd_runtime_control_grp group */
-/** @} */ /* end of FM_PORT_runtime_control_grp group */
-
-
-/**************************************************************************//**
- @Group         FM_PORT_runtime_data_grp FM Port Runtime Data-path Unit
-
- @Description   FM Port Runtime data unit API functions, definitions and enums.
-                This API is valid only if working in Independent-Mode.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Function      FM_PORT_ImTx
-
- @Description   Tx function, called to transmit a data buffer on the port.
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     p_Data      A pointer to an LCP data buffer.
- @Param[in]     length      Size of data for transmission.
- @Param[in]     lastBuffer  Buffer position - TRUE for the last buffer
-                            of a frame, including a single buffer frame
- @Param[in]     h_BufContext  A handle of the user acossiated with this buffer
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-                NOTE - This routine can be used only when working in
-                Independent-Mode mode.
-*//***************************************************************************/
-t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
-                       uint8_t                *p_Data,
-                       uint16_t               length,
-                       bool                   lastBuffer,
-                       t_Handle               h_BufContext);
-
-/**************************************************************************//**
- @Function      FM_PORT_ImTxConf
-
- @Description   Tx port confirmation routine, optional, may be called to verify
-                transmission of all frames. The procedure performed by this
-                routine will be performed automatically on next buffer transmission,
-                but if desired, calling this routine will invoke this action on
-                demand.
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
-
- @Cautions      Allowed only following FM_PORT_Init().
-                NOTE - This routine can be used only when working in
-                Independent-Mode mode.
-*//***************************************************************************/
-void FM_PORT_ImTxConf(t_Handle h_FmPort);
-
-/**************************************************************************//**
- @Function      FM_PORT_ImRx
-
- @Description   Rx function, may be called to poll for received buffers.
-                Normally, Rx process is invoked by the driver on Rx interrupt.
-                Alternatively, this routine may be called on demand.
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-                NOTE - This routine can be used only when working in
-                Independent-Mode mode.
-*//***************************************************************************/
-t_Error  FM_PORT_ImRx(t_Handle h_FmPort);
-
-/** @} */ /* end of FM_PORT_runtime_data_grp group */
-/** @} */ /* end of FM_PORT_grp group */
-/** @} */ /* end of FM_grp group */
-
-
-
-#ifdef NCSW_BACKWARD_COMPATIBLE_API
-#define FM_PORT_ConfigTxFifoDeqPipelineDepth FM_PORT_ConfigFifoDeqPipelineDepth
-#endif /* NCSW_BACKWARD_COMPATIBLE_API */
-
-
-#endif /* __FM_PORT_EXT */
--- fmlib-fslsdk-v1.7/src/include/fmd/enet_ext.h.orig	2022-05-26 11:28:30.982977418 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/enet_ext.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,202 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          enet_ext.h
-
- @Description   Ethernet generic definitions and enums.
-*//***************************************************************************/
-
-#ifndef __ENET_EXT_H
-#define __ENET_EXT_H
-
-#include "fsl_enet.h"
-
-#define ENET_NUM_OCTETS_PER_ADDRESS 6     /**< Number of octets (8-bit bytes) in an ethernet address */
-#define ENET_GROUP_ADDR             0x01  /**< Group address mask for ethernet addresses */
-
-
-/**************************************************************************//**
- @Description   Ethernet Address
-*//***************************************************************************/
-typedef uint8_t t_EnetAddr[ENET_NUM_OCTETS_PER_ADDRESS];
-
-/**************************************************************************//**
- @Description   Ethernet Address Type.
-*//***************************************************************************/
-typedef enum e_EnetAddrType
-{
-    e_ENET_ADDR_TYPE_INDIVIDUAL,    /**< Individual (unicast) address */
-    e_ENET_ADDR_TYPE_GROUP,         /**< Group (multicast) address */
-    e_ENET_ADDR_TYPE_BROADCAST      /**< Broadcast address */
-} e_EnetAddrType;
-
-/**************************************************************************//**
- @Description   Ethernet MAC-PHY Interface
-*//***************************************************************************/
-typedef enum e_EnetInterface
-{
-    e_ENET_IF_MII   = E_ENET_IF_MII,     /**< MII interface */
-    e_ENET_IF_RMII  = E_ENET_IF_RMII,    /**< RMII interface */
-    e_ENET_IF_SMII  = E_ENET_IF_SMII,    /**< SMII interface */
-    e_ENET_IF_GMII  = E_ENET_IF_GMII,    /**< GMII interface */
-    e_ENET_IF_RGMII = E_ENET_IF_RGMII,   /**< RGMII interface */
-    e_ENET_IF_TBI   = E_ENET_IF_TBI,     /**< TBI interface */
-    e_ENET_IF_RTBI  = E_ENET_IF_RTBI,    /**< RTBI interface */
-    e_ENET_IF_SGMII = E_ENET_IF_SGMII,   /**< SGMII interface */
-    e_ENET_IF_XGMII = E_ENET_IF_XGMII,   /**< XGMII interface */
-    e_ENET_IF_QSGMII= E_ENET_IF_QSGMII,  /**< QSGMII interface */
-    e_ENET_IF_XFI   = E_ENET_IF_XFI      /**< XFI interface */
-} e_EnetInterface;
-
-#define ENET_IF_SGMII_BASEX       0x80000000   /**< SGMII/QSGII interface with 1000BaseX
-                                                    auto-negotiation between MAC and phy
-                                                    or backplane;
-                                                    Note: 1000BaseX auto-negotiation relates
-                                                    only to interface between MAC and phy/backplane,
-                                                    SGMII phy can still synchronize with far-end phy
-                                                    at 10Mbps, 100Mbps or 1000Mbps */
-
-/**************************************************************************//**
- @Description   Ethernet Duplex Mode
-*//***************************************************************************/
-typedef enum e_EnetDuplexMode
-{
-    e_ENET_HALF_DUPLEX,             /**< Half-Duplex mode */
-    e_ENET_FULL_DUPLEX              /**< Full-Duplex mode */
-} e_EnetDuplexMode;
-
-/**************************************************************************//**
- @Description   Ethernet Speed (nominal data rate)
-*//***************************************************************************/
-typedef enum e_EnetSpeed
-{
-    e_ENET_SPEED_10     = E_ENET_SPEED_10,       /**< 10 Mbps */
-    e_ENET_SPEED_100    = E_ENET_SPEED_100,      /**< 100 Mbps */
-    e_ENET_SPEED_1000   = E_ENET_SPEED_1000,     /**< 1000 Mbps = 1 Gbps */
-    e_ENET_SPEED_10000  = E_ENET_SPEED_10000     /**< 10000 Mbps = 10 Gbps */
-} e_EnetSpeed;
-
-/**************************************************************************//**
- @Description   Ethernet mode (combination of MAC-PHY interface and speed)
-*//***************************************************************************/
-typedef enum e_EnetMode
-{
-    e_ENET_MODE_INVALID           = 0,                                        /**< Invalid Ethernet mode */
-    e_ENET_MODE_MII_10            = (e_ENET_IF_MII   | e_ENET_SPEED_10),      /**<    10 Mbps MII   */
-    e_ENET_MODE_MII_100           = (e_ENET_IF_MII   | e_ENET_SPEED_100),     /**<   100 Mbps MII   */
-    e_ENET_MODE_RMII_10           = (e_ENET_IF_RMII  | e_ENET_SPEED_10),      /**<    10 Mbps RMII  */
-    e_ENET_MODE_RMII_100          = (e_ENET_IF_RMII  | e_ENET_SPEED_100),     /**<   100 Mbps RMII  */
-    e_ENET_MODE_SMII_10           = (e_ENET_IF_SMII  | e_ENET_SPEED_10),      /**<    10 Mbps SMII  */
-    e_ENET_MODE_SMII_100          = (e_ENET_IF_SMII  | e_ENET_SPEED_100),     /**<   100 Mbps SMII  */
-    e_ENET_MODE_GMII_1000         = (e_ENET_IF_GMII  | e_ENET_SPEED_1000),    /**<  1000 Mbps GMII  */
-    e_ENET_MODE_RGMII_10          = (e_ENET_IF_RGMII | e_ENET_SPEED_10),      /**<    10 Mbps RGMII */
-    e_ENET_MODE_RGMII_100         = (e_ENET_IF_RGMII | e_ENET_SPEED_100),     /**<   100 Mbps RGMII */
-    e_ENET_MODE_RGMII_1000        = (e_ENET_IF_RGMII | e_ENET_SPEED_1000),    /**<  1000 Mbps RGMII */
-    e_ENET_MODE_TBI_1000          = (e_ENET_IF_TBI   | e_ENET_SPEED_1000),    /**<  1000 Mbps TBI   */
-    e_ENET_MODE_RTBI_1000         = (e_ENET_IF_RTBI  | e_ENET_SPEED_1000),    /**<  1000 Mbps RTBI  */
-    e_ENET_MODE_SGMII_10          = (e_ENET_IF_SGMII | e_ENET_SPEED_10),
-                                        /**< 10 Mbps SGMII with auto-negotiation between MAC and
-                                             SGMII phy according to Cisco SGMII specification */
-    e_ENET_MODE_SGMII_100         = (e_ENET_IF_SGMII | e_ENET_SPEED_100),
-                                        /**< 100 Mbps SGMII with auto-negotiation between MAC and
-                                             SGMII phy according to Cisco SGMII specification */
-    e_ENET_MODE_SGMII_1000        = (e_ENET_IF_SGMII | e_ENET_SPEED_1000),
-                                        /**< 1000 Mbps SGMII with auto-negotiation between MAC and
-                                             SGMII phy according to Cisco SGMII specification */
-    e_ENET_MODE_SGMII_BASEX_10    = (ENET_IF_SGMII_BASEX | e_ENET_IF_SGMII | e_ENET_SPEED_10),
-                                        /**< 10 Mbps SGMII with 1000BaseX auto-negotiation between
-                                             MAC and SGMII phy or backplane */
-    e_ENET_MODE_SGMII_BASEX_100   = (ENET_IF_SGMII_BASEX | e_ENET_IF_SGMII | e_ENET_SPEED_100),
-                                        /**< 100 Mbps SGMII with 1000BaseX auto-negotiation between
-                                             MAC and SGMII phy or backplane */
-    e_ENET_MODE_SGMII_BASEX_1000  = (ENET_IF_SGMII_BASEX | e_ENET_IF_SGMII | e_ENET_SPEED_1000),
-                                        /**< 1000 Mbps SGMII with 1000BaseX auto-negotiation between
-                                             MAC and SGMII phy or backplane */
-    e_ENET_MODE_QSGMII_1000       = (e_ENET_IF_QSGMII| e_ENET_SPEED_1000),
-                                        /**< 1000 Mbps QSGMII with auto-negotiation between MAC and
-                                             QSGMII phy according to Cisco QSGMII specification */
-    e_ENET_MODE_QSGMII_BASEX_1000 = (ENET_IF_SGMII_BASEX | e_ENET_IF_QSGMII| e_ENET_SPEED_1000),
-                                        /**< 1000 Mbps QSGMII with 1000BaseX auto-negotiation between
-                                             MAC and QSGMII phy or backplane */
-    e_ENET_MODE_XGMII_10000       = (e_ENET_IF_XGMII | e_ENET_SPEED_10000),   /**< 10000 Mbps XGMII */
-    e_ENET_MODE_XFI_10000         = (e_ENET_IF_XFI   | e_ENET_SPEED_10000)    /**< 10000 Mbps XFI */
-} e_EnetMode;
-
-
-#define IS_ENET_MODE_VALID(mode) \
-        (((mode) == e_ENET_MODE_MII_10     ) || \
-         ((mode) == e_ENET_MODE_MII_100    ) || \
-         ((mode) == e_ENET_MODE_RMII_10    ) || \
-         ((mode) == e_ENET_MODE_RMII_100   ) || \
-         ((mode) == e_ENET_MODE_SMII_10    ) || \
-         ((mode) == e_ENET_MODE_SMII_100   ) || \
-         ((mode) == e_ENET_MODE_GMII_1000  ) || \
-         ((mode) == e_ENET_MODE_RGMII_10   ) || \
-         ((mode) == e_ENET_MODE_RGMII_100  ) || \
-         ((mode) == e_ENET_MODE_RGMII_1000 ) || \
-         ((mode) == e_ENET_MODE_TBI_1000   ) || \
-         ((mode) == e_ENET_MODE_RTBI_1000  ) || \
-         ((mode) == e_ENET_MODE_SGMII_10   ) || \
-         ((mode) == e_ENET_MODE_SGMII_100  ) || \
-         ((mode) == e_ENET_MODE_SGMII_1000 ) || \
-         ((mode) == e_ENET_MODE_SGMII_BASEX_10   ) || \
-         ((mode) == e_ENET_MODE_SGMII_BASEX_100  ) || \
-         ((mode) == e_ENET_MODE_SGMII_BASEX_1000 ) || \
-         ((mode) == e_ENET_MODE_XGMII_10000) || \
-         ((mode) == e_ENET_MODE_QSGMII_1000) || \
-         ((mode) == e_ENET_MODE_QSGMII_BASEX_1000) || \
-         ((mode) == e_ENET_MODE_XFI_10000))
-
-
-#define MAKE_ENET_MODE(_interface, _speed)     (e_EnetMode)((_interface) | (_speed))
-
-#define ENET_INTERFACE_FROM_MODE(mode)          (e_EnetInterface)((mode) & 0x0FFF0000)
-#define ENET_SPEED_FROM_MODE(mode)              (e_EnetSpeed)((mode) & 0x0000FFFF)
-
-#define ENET_ADDR_TO_UINT64(_enetAddr)                  \
-        (uint64_t)(((uint64_t)(_enetAddr)[0] << 40) |   \
-                   ((uint64_t)(_enetAddr)[1] << 32) |   \
-                   ((uint64_t)(_enetAddr)[2] << 24) |   \
-                   ((uint64_t)(_enetAddr)[3] << 16) |   \
-                   ((uint64_t)(_enetAddr)[4] << 8) |    \
-                   ((uint64_t)(_enetAddr)[5]))
-
-#define MAKE_ENET_ADDR_FROM_UINT64(_addr64, _enetAddr)              \
-        do {                                                        \
-            int i;                                                  \
-            for (i=0; i < ENET_NUM_OCTETS_PER_ADDRESS; i++)         \
-                (_enetAddr)[i] = (uint8_t)((_addr64) >> ((5-i)*8)); \
-        } while (0)
-
-
-#endif /* __ENET_EXT_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/integrations/part_integration_P1023.h.orig	2022-05-26 11:28:30.986977256 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/integrations/part_integration_P1023.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,590 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          part_integration_P1023.h
-
- @Description   P1023 external definitions and structures.
-*//***************************************************************************/
-#ifndef __PART_INTEGRATION_P1023_H
-#define __PART_INTEGRATION_P1023_H
-
-#include "std_ext.h"
-#include "dpaa_integration_ext.h"
-
-#ifdef P1023
-
-/**************************************************************************//**
- @Group         1023_chip_id P1023 Application Programming Interface
-
- @Description   P1023 Chip functions,definitions and enums.
-
- @{
-*//***************************************************************************/
-
-#define CORE_E500MC
-
-#define INTG_MAX_NUM_OF_CORES   1
-#define CORE_GetId()            0
-#define CORE_IS_BIG_ENDIAN
-#define SYS_ANY_CORE    ((uint32_t)-1)  /**< Assignment to any valid core */
-#define SYS_IS_MASTER_CORE()    TRUE
-
-
-/**************************************************************************//**
- @Description   Module types.
-*//***************************************************************************/
-typedef enum e_ModuleId
-{
-    e_MODULE_ID_LAW,            /**< Local Access module                     */
-    e_MODULE_ID_ECM,            /**< e500 Coherency Module                   */
-    e_MODULE_ID_DDR,            /**< DDR memory controller                   */
-    e_MODULE_ID_I2C_1,          /**< I2C 1                                   */
-    e_MODULE_ID_I2C_2,          /**< I2C 1                                   */
-    e_MODULE_ID_DUART_1,        /**< DUART module 1                          */
-    e_MODULE_ID_DUART_2,        /**< DUART module 2                          */
-    e_MODULE_ID_LBC,            /**< Local bus memory controller module      */
-    e_MODULE_ID_PCIE_1,         /**< PCI Express 1 controller module         */
-    e_MODULE_ID_PCIE_ATMU_1,    /**< PCI 1 ATMU Window                       */
-    e_MODULE_ID_PCIE_2,         /**< PCI Express 2 controller module         */
-    e_MODULE_ID_PCIE_ATMU_2,    /**< PCI 2 ATMU Window                       */
-    e_MODULE_ID_PCIE_3,         /**< PCI Express 3 controller module         */
-    e_MODULE_ID_PCIE_ATMU_3,    /**< PCI 3 ATMU Window                       */
-    e_MODULE_ID_MSI,            /**< MSI registers                           */
-    e_MODULE_ID_L2_SRAM,        /**< L2/SRAM Memory-Mapped controller module */
-    e_MODULE_ID_DMA_1,          /**< DMA controller 1                        */
-    e_MODULE_ID_DMA_2,          /**< DMA controller 2                        */
-    e_MODULE_ID_EPIC,           /**< Programmable interrupt controller       */
-    e_MODULE_ID_ESPI,           /**< ESPI module                             */
-    e_MODULE_ID_GPIO,           /**< General Purpose I/O                     */
-    e_MODULE_ID_SEC_GEN,        /**< SEC 4.0 General registers               */
-    e_MODULE_ID_SEC_QI,         /**< SEC 4.0 QI registers                    */
-    e_MODULE_ID_SEC_JQ0,        /**< SEC 4.0 JQ-0 registers                  */
-    e_MODULE_ID_SEC_JQ1,        /**< SEC 4.0 JQ-1 registers                  */
-    e_MODULE_ID_SEC_JQ2,        /**< SEC 4.0 JQ-2 registers                  */
-    e_MODULE_ID_SEC_JQ3,        /**< SEC 4.0 JQ-3 registers                  */
-    e_MODULE_ID_SEC_RTIC,       /**< SEC 4.0 RTIC registers                  */
-    e_MODULE_ID_SEC_DECO0_CCB0, /**< SEC 4.0 DECO-0/CCB-0 registers          */
-    e_MODULE_ID_SEC_DECO1_CCB1, /**< SEC 4.0 DECO-1/CCB-1 registers          */
-    e_MODULE_ID_SEC_DECO2_CCB2, /**< SEC 4.0 DECO-2/CCB-2 registers          */
-    e_MODULE_ID_SEC_DECO3_CCB3, /**< SEC 4.0 DECO-3/CCB-3 registers          */
-    e_MODULE_ID_SEC_DECO4_CCB4, /**< SEC 4.0 DECO-4/CCB-4 registers          */
-    e_MODULE_ID_USB_DR_1,       /**< USB 2.0 module 1                        */
-    e_MODULE_ID_USB_DR_2,       /**< USB 2.0 module 2                        */
-    e_MODULE_ID_ETSEC_MII_MNG,  /**< MII MNG registers                       */
-    e_MODULE_ID_ETSEC_1,        /**< ETSEC module 1                             */
-    e_MODULE_ID_ETSEC_2,        /**< ETSEC module 2                             */
-    e_MODULE_ID_GUTS,           /**< Serial DMA                              */
-    e_MODULE_ID_PM,             /**< Performance Monitor module              */
-    e_MODULE_ID_QM,                 /**< Queue manager module */
-    e_MODULE_ID_BM,                 /**< Buffer manager module */
-    e_MODULE_ID_QM_CE_PORTAL,
-    e_MODULE_ID_QM_CI_PORTAL,
-    e_MODULE_ID_BM_CE_PORTAL,
-    e_MODULE_ID_BM_CI_PORTAL,
-    e_MODULE_ID_FM,                /**< Frame manager #1 module */
-    e_MODULE_ID_FM_RTC,            /**< FM Real-Time-Clock */
-    e_MODULE_ID_FM_MURAM,          /**< FM Multi-User-RAM */
-    e_MODULE_ID_FM_BMI,            /**< FM BMI block */
-    e_MODULE_ID_FM_QMI,            /**< FM QMI block */
-    e_MODULE_ID_FM_PRS,            /**< FM parser block */
-    e_MODULE_ID_FM_PORT_HO0,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM_PORT_HO1,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM_PORT_HO2,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM_PORT_HO3,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM_PORT_HO4,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM_PORT_1GRx0,     /**< FM Rx 1G MAC port block */
-    e_MODULE_ID_FM_PORT_1GRx1,     /**< FM Rx 1G MAC port block */
-    e_MODULE_ID_FM_PORT_1GTx0,     /**< FM Tx 1G MAC port block */
-    e_MODULE_ID_FM_PORT_1GTx1,     /**< FM Tx 1G MAC port block */
-    e_MODULE_ID_FM_PLCR,           /**< FM Policer */
-    e_MODULE_ID_FM_KG,             /**< FM Keygen */
-    e_MODULE_ID_FM_DMA,            /**< FM DMA */
-    e_MODULE_ID_FM_FPM,            /**< FM FPM */
-    e_MODULE_ID_FM_IRAM,           /**< FM Instruction-RAM */
-    e_MODULE_ID_FM_1GMDIO0,        /**< FM 1G MDIO MAC 0*/
-    e_MODULE_ID_FM_1GMDIO1,        /**< FM 1G MDIO MAC 1*/
-    e_MODULE_ID_FM_PRS_IRAM,       /**< FM SW-parser Instruction-RAM */
-    e_MODULE_ID_FM_RISC0,          /**< FM risc #0 */
-    e_MODULE_ID_FM_RISC1,          /**< FM risc #1 */
-    e_MODULE_ID_FM_1GMAC0,         /**< FM 1G MAC #0 */
-    e_MODULE_ID_FM_1GMAC1,         /**< FM 1G MAC #1 */
-    e_MODULE_ID_FM_MACSEC,         /**< FM MACSEC */
-
-    e_MODULE_ID_DUMMY_LAST
-} e_ModuleId;
-
-#define NUM_OF_MODULES  e_MODULE_ID_DUMMY_LAST
-
-#define P1023_OFFSET_LAW                    0x00000C08
-#define P1023_OFFSET_ECM                    0x00001000
-#define P1023_OFFSET_DDR                    0x00002000
-#define P1023_OFFSET_I2C1                   0x00003000
-#define P1023_OFFSET_I2C2                   0x00003100
-#define P1023_OFFSET_DUART1                 0x00004500
-#define P1023_OFFSET_DUART2                 0x00004600
-#define P1023_OFFSET_LBC                    0x00005000
-#define P1023_OFFSET_ESPI                   0x00007000
-#define P1023_OFFSET_PCIE2                  0x00009000
-#define P1023_OFFSET_PCIE2_ATMU             0x00009C00
-#define P1023_OFFSET_PCIE1                  0x0000A000
-#define P1023_OFFSET_PCIE1_ATMU             0x0000AC00
-#define P1023_OFFSET_PCIE3                  0x0000B000
-#define P1023_OFFSET_PCIE3_ATMU             0x0000BC00
-#define P1023_OFFSET_DMA2                   0x0000C100
-#define P1023_OFFSET_GPIO                   0x0000F000
-#define P1023_OFFSET_L2_SRAM                0x00020000
-#define P1023_OFFSET_DMA1                   0x00021100
-#define P1023_OFFSET_USB1                   0x00022000
-#define P1023_OFFSET_SEC_GEN                0x00030000
-#define P1023_OFFSET_SEC_JQ0                0x00031000
-#define P1023_OFFSET_SEC_JQ1                0x00032000
-#define P1023_OFFSET_SEC_JQ2                0x00033000
-#define P1023_OFFSET_SEC_JQ3                0x00034000
-#define P1023_OFFSET_SEC_RTIC               0x00036000
-#define P1023_OFFSET_SEC_QI                 0x00037000
-#define P1023_OFFSET_SEC_DECO0_CCB0         0x00038000
-#define P1023_OFFSET_SEC_DECO1_CCB1         0x00039000
-#define P1023_OFFSET_SEC_DECO2_CCB2         0x0003a000
-#define P1023_OFFSET_SEC_DECO3_CCB3         0x0003b000
-#define P1023_OFFSET_SEC_DECO4_CCB4         0x0003c000
-#define P1023_OFFSET_PIC                    0x00040000
-#define P1023_OFFSET_MSI                    0x00041600
-#define P1023_OFFSET_AXI                    0x00081000
-#define P1023_OFFSET_QM                     0x00088000
-#define P1023_OFFSET_BM                     0x0008A000
-#define P1022_OFFSET_PM                     0x000E1000
-
-#define P1023_OFFSET_GUTIL                  0x000E0000
-#define P1023_OFFSET_PM                     0x000E1000
-#define P1023_OFFSET_DEBUG                  0x000E2000
-#define P1023_OFFSET_SERDES                 0x000E3000
-#define P1023_OFFSET_ROM                    0x000F0000
-#define P1023_OFFSET_FM                     0x00100000
-
-#define P1023_OFFSET_FM_MURAM               (P1023_OFFSET_FM + 0x00000000)
-#define P1023_OFFSET_FM_BMI                 (P1023_OFFSET_FM + 0x00080000)
-#define P1023_OFFSET_FM_QMI                 (P1023_OFFSET_FM + 0x00080400)
-#define P1023_OFFSET_FM_PRS                 (P1023_OFFSET_FM + 0x00080800)
-#define P1023_OFFSET_FM_PORT_HO0            (P1023_OFFSET_FM + 0x00081000)
-#define P1023_OFFSET_FM_PORT_HO1            (P1023_OFFSET_FM + 0x00082000)
-#define P1023_OFFSET_FM_PORT_HO2            (P1023_OFFSET_FM + 0x00083000)
-#define P1023_OFFSET_FM_PORT_HO3            (P1023_OFFSET_FM + 0x00084000)
-#define P1023_OFFSET_FM_PORT_HO4            (P1023_OFFSET_FM + 0x00085000)
-#define P1023_OFFSET_FM_PORT_1GRX0          (P1023_OFFSET_FM + 0x00088000)
-#define P1023_OFFSET_FM_PORT_1GRX1          (P1023_OFFSET_FM + 0x00089000)
-#define P1023_OFFSET_FM_PORT_1GTX0          (P1023_OFFSET_FM + 0x000A8000)
-#define P1023_OFFSET_FM_PORT_1GTX1          (P1023_OFFSET_FM + 0x000A9000)
-#define P1023_OFFSET_FM_PLCR                (P1023_OFFSET_FM + 0x000C0000)
-#define P1023_OFFSET_FM_KG                  (P1023_OFFSET_FM + 0x000C1000)
-#define P1023_OFFSET_FM_DMA                 (P1023_OFFSET_FM + 0x000C2000)
-#define P1023_OFFSET_FM_FPM                 (P1023_OFFSET_FM + 0x000C3000)
-#define P1023_OFFSET_FM_IRAM                (P1023_OFFSET_FM + 0x000C4000)
-#define P1023_OFFSET_FM_PRS_IRAM            (P1023_OFFSET_FM + 0x000C7000)
-#define P1023_OFFSET_FM_RISC0               (P1023_OFFSET_FM + 0x000D0000)
-#define P1023_OFFSET_FM_RISC1               (P1023_OFFSET_FM + 0x000D0400)
-#define P1023_OFFSET_FM_MACSEC              (P1023_OFFSET_FM + 0x000D8000)
-#define P1023_OFFSET_FM_1GMAC0              (P1023_OFFSET_FM + 0x000E0000)
-#define P1023_OFFSET_FM_1GMDIO0             (P1023_OFFSET_FM + 0x000E1120)
-#define P1023_OFFSET_FM_1GMAC1              (P1023_OFFSET_FM + 0x000E2000)
-#define P1023_OFFSET_FM_1GMDIO1             (P1023_OFFSET_FM + 0x000E3000)
-#define P1023_OFFSET_FM_RTC                 (P1023_OFFSET_FM + 0x000FE000)
-
-/* Offsets relative to QM or BM portals base */
-#define P1023_OFFSET_PORTALS_CE_AREA        0x00000000        /* cache enabled area */
-#define P1023_OFFSET_PORTALS_CI_AREA        0x00100000        /* cache inhibited area */
-
-#define P1023_OFFSET_PORTALS_CE(portal)     (P1023_OFFSET_PORTALS_CE_AREA + 0x4000 * (portal))
-#define P1023_OFFSET_PORTALS_CI(portal)     (P1023_OFFSET_PORTALS_CI_AREA + 0x1000 * (portal))
-
-/**************************************************************************//**
- @Description   Transaction source ID (for memory controllers error reporting).
-*//***************************************************************************/
-typedef enum e_TransSrc
-{
-    e_TRANS_SRC_PCIE_2          = 0x01, /**< PCIe port 2                    */
-    e_TRANS_SRC_PCIE_1          = 0x02, /**< PCIe port 1                    */
-    e_TRANS_SRC_PCIE_3          = 0x03, /**< PCIe port 3                    */
-    e_TRANS_SRC_LBC             = 0x04, /**< Enhanced local bus             */
-    e_TRANS_SRC_DPAA_SW_PORTALS = 0x0E, /**< DPAA software portals or SRAM  */
-    e_TRANS_SRC_DDR             = 0x0F, /**< DDR controller                 */
-    e_TRANS_SRC_CORE_INS_FETCH  = 0x10, /**< Processor (instruction)        */
-    e_TRANS_SRC_CORE_DATA       = 0x11, /**< Processor (data)               */
-    e_TRANS_SRC_DMA             = 0x15  /**< DMA                            */
-} e_TransSrc;
-
-/**************************************************************************//**
- @Description   Local Access Window Target interface ID
-*//***************************************************************************/
-typedef enum e_P1023LawTargetId
-{
-    e_P1023_LAW_TARGET_PCIE_2       = 0x01, /**< PCI Express 2 target interface */
-    e_P1023_LAW_TARGET_PCIE_1       = 0x02, /**< PCI Express 1 target interface */
-    e_P1023_LAW_TARGET_PCIE_3       = 0x03, /**< PCI Express 3 target interface */
-    e_P1023_LAW_TARGET_LBC          = 0x04, /**< Local bus target interface */
-    e_P1023_LAW_TARGET_QM_PORTALS   = 0x0E, /**< Queue Manager Portals */
-    e_P1023_LAW_TARGET_BM_PORTALS   = 0x0E, /**< Buffer Manager Portals */
-    e_P1023_LAW_TARGET_SRAM         = 0x0E, /**< SRAM scratchpad */
-    e_P1023_LAW_TARGET_DDR          = 0x0F, /**< DDR target interface */
-    e_P1023_LAW_TARGET_NONE         = 0xFF  /**< Invalid target interface */
-} e_P1023LawTargetId;
-
-
-/**************************************************************************//**
- @Group         1023_init_grp P1023 Initialization Unit
-
- @Description   P1023 initialization unit API functions, definitions and enums
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   Part ID and revision number
-*//***************************************************************************/
-typedef enum e_P1023DeviceName
-{
-    e_P1023_REV_INVALID     = 0x00000000,       /**< Invalid revision */
-    e_SC1023_REV_1_0        = (int)0x80FC0010,  /**< SC1023 rev 1.0 */
-    e_SC1023_REV_1_1        = (int)0x80FC0011,  /**< SC1023 rev 1.1 */
-    e_P1023_REV_1_0         = (int)0x80FE0010,  /**< P1023 rev 1.0 with security */
-    e_P1023_REV_1_1         = (int)0x80FE0011,  /**< P1023 rev 1.1 with security */
-    e_P1017_REV_1_1         = (int)0x80FF0011,  /**< P1017 rev 1.1 with security */
-    e_P1023_REV_1_0_NO_SEC  = (int)0x80F60010,  /**< P1023 rev 1.0 without security */
-    e_P1023_REV_1_1_NO_SEC  = (int)0x80F60011,  /**< P1023 rev 1.1 without security */
-    e_P1017_REV_1_1_NO_SEC  = (int)0x80F70011   /**< P1017 rev 1.1 without security */
-} e_P1023DeviceName;
-
-/**************************************************************************//**
- @Description   structure representing P1023 initialization parameters
-*//***************************************************************************/
-typedef struct t_P1023Params
-{
-    uintptr_t   ccsrBaseAddress;        /**< CCSR base address (virtual) */
-    uintptr_t   bmPortalsBaseAddress;   /**< Portals base address (virtual) */
-    uintptr_t   qmPortalsBaseAddress;   /**< Portals base address (virtual) */
-} t_P1023Params;
-
-/**************************************************************************//**
- @Function      P1023_ConfigAndInit
-
- @Description   General initiation of the chip registers.
-
- @Param[in]     p_P1023Params  - A pointer to data structure of parameters
-
- @Return        A handle to the P1023 data structure.
-*//***************************************************************************/
-t_Handle P1023_ConfigAndInit(t_P1023Params *p_P1023Params);
-
-/**************************************************************************//**
- @Function      P1023_Free
-
- @Description   Free all resources.
-
- @Param         h_P1023 - (In) The handle of the initialized P1023 object.
-
- @Return        E_OK on success; Other value otherwise.
-*//***************************************************************************/
-t_Error P1023_Free(t_Handle h_P1023);
-
-/**************************************************************************//**
- @Function      P1023_GetRevInfo
-
- @Description   This routine enables access to chip and revision information.
-
- @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
-
- @Return        Part ID and revision.
-*//***************************************************************************/
-e_P1023DeviceName P1023_GetRevInfo(uintptr_t gutilBase);
-
-/**************************************************************************//**
- @Function      P1023_GetE500Factor
-
- @Description   Returns E500 core clock multiplication factor.
-
- @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
- @Param[in]     coreId          - Id of the requested core.
- @Param[out]    p_E500MulFactor - Returns E500 to CCB multification factor.
- @Param[out]    p_E500DivFactor - Returns E500 to CCB division factor.
-
- @Return        E_OK on success; Other value otherwise.
-*
-*//***************************************************************************/
-t_Error P1023_GetE500Factor(uintptr_t    gutilBase,
-                            uint32_t    coreId,
-                            uint32_t    *p_E500MulFactor,
-                            uint32_t    *p_E500DivFactor);
-
-/**************************************************************************//**
- @Function      P1023_GetFmFactor
-
- @Description   returns FM multiplication factors. (This value is returned using
-                two parameters to avoid using float parameter).
-
- @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
- @Param[out]    p_FmMulFactor   - returns E500 to CCB multification factor.
- @Param[out]    p_FmDivFactor   - returns E500 to CCB division factor.
-
- @Return        E_OK on success; Other value otherwise.
-*//***************************************************************************/
-t_Error  P1023_GetFmFactor(uintptr_t gutilBase, uint32_t *p_FmMulFactor, uint32_t *p_FmDivFactor);
-
-/**************************************************************************//**
- @Function      P1023_GetCcbFactor
-
- @Description   returns system multiplication factor.
-
- @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
-
- @Return        System multiplication factor.
-*//***************************************************************************/
-uint32_t P1023_GetCcbFactor(uintptr_t gutilBase);
-
-/**************************************************************************//**
- @Function      P1023_GetDdrFactor
-
- @Description   returns the multiplication factor of the clock in for the DDR clock .
-                Note: assumes the ddr_in_clk is identical to the sys_in_clk
-
- @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
- @Param         p_DdrMulFactor  - returns DDR in clk multification factor.
- @Param         p_DdrDivFactor  - returns DDR division factor.
-
- @Return        E_OK on success; Other value otherwise..
-*//***************************************************************************/
-t_Error P1023_GetDdrFactor( uintptr_t   gutilBase,
-                            uint32_t    *p_DdrMulFactor,
-                            uint32_t    *p_DdrDivFactor);
-
-
-
-/** @} */ /* end of 1023_init_grp group */
-/** @} */ /* end of 1023_grp group */
-
-#define CORE_E500V2
-
-
-/*****************************************************************************
- LBC INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-/**************************************************************************//**
- @Group         lbc_exception_grp LBC Exception Unit
-
- @Description   LBC Exception unit API functions, definitions and enums
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Anchor        lbc_exbm
-
- @Collection    LBC Errors Bit Mask
-
-                These errors are reported through the exceptions callback..
-                The values can be or'ed in any combination in the errors mask
-                parameter of the errors report structure.
-
-                These errors can also be passed as a bit-mask to
-                LBC_EnableErrorChecking() or LBC_DisableErrorChecking(),
-                for enabling or disabling error checking.
- @{
-*//***************************************************************************/
-#define LBC_ERR_BUS_MONITOR     0x80000000  /**< Bus monitor error */
-#define LBC_ERR_PARITY_ECC      0x20000000  /**< Parity error for GPCM/UPM */
-#define LBC_ERR_WRITE_PROTECT   0x04000000  /**< Write protection error */
-#define LBC_ERR_CHIP_SELECT     0x00080000  /**< Unrecognized chip select */
-
-#define LBC_ERR_ALL             (LBC_ERR_BUS_MONITOR | LBC_ERR_PARITY_ECC | \
-                                 LBC_ERR_WRITE_PROTECT | LBC_ERR_CHIP_SELECT)
-                                            /**< All possible errors */
-/* @} */
-/** @} */ /* end of lbc_exception_grp group */
-
-#define LBC_NUM_OF_BANKS            2
-#define LBC_MAX_CS_SIZE             0x0000000100000000LL
-#define LBC_ATOMIC_OPERATION_SUPPORT
-#define LBC_PARITY_SUPPORT
-#define LBC_ADDRESS_SHIFT_SUPPORT
-#define LBC_ADDRESS_HOLD_TIME_CTRL
-#define LBC_HIGH_CLK_DIVIDERS
-#define LBC_FCM_AVAILABLE
-
-
-/*****************************************************************************
- LAW INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define LAW_ARCH_CCB
-#define LAW_NUM_OF_WINDOWS      12
-#define LAW_MIN_WINDOW_SIZE     0x0000000000001000LL    /**< 4KB */
-#define LAW_MAX_WINDOW_SIZE     0x0000001000000000LL    /**< 32GB */
-
-
-/*****************************************************************************
- SPI INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define SPI_NUM_OF_CONTROLLERS      1
-
-/*****************************************************************************
- PCI/PCIe INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-
-#define PCI_MAX_INBOUND_WINDOWS_NUM     4
-#define PCI_MAX_OUTBOUND_WINDOWS_NUM    5
-
-/**************************************************************************//**
- @Description   Target interface of an inbound window
-*//***************************************************************************/
-typedef enum e_PciTargetInterface
-{
-    e_PCI_TARGET_PCIE_2         = 0x1,  /**<  PCI Express target interface 2 */
-    e_PCI_TARGET_PCIE_1         = 0x2,  /**<  PCI Express target interface 1 */
-    e_PCI_TARGET_PCIE_3         = 0x3,  /**<  PCI Express target interface 3 */
-    e_PCI_TARGET_LOCAL_MEMORY   = 0xF   /**<  Local Memory (DDR SDRAM, Local Bus, SRAM) target interface */
-
-} e_PciTargetInterface;
-
-/*****************************************************************************
- DDR INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define DDR_NUM_OF_VALID_CS         2
-
-/*****************************************************************************
- SEC INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define SEC_ERRATA_STAT_REGS_UNUSABLE
-
-/*****************************************************************************
- DMA INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define DMA_NUM_OF_CONTROLLERS      2
-
-
-
-
-/*****************************************************************************
- 1588 INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define PTP_V2
-
-/**************************************************************************//**
- @Function      P1023_GetMuxControlReg
-
- @Description   Returns the value of PMUXCR (Alternate Function Signal Multiplex
-                Control Register)
-
- @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
-
- @Return        Value of PMUXCR
-*//***************************************************************************/
-uint32_t P1023_GetMuxControlReg(uintptr_t gutilBase);
-
-/**************************************************************************//**
- @Function      P1023_SetMuxControlReg
-
- @Description   Sets the value of PMUXCR (Alternate Function Signal Multiplex
-                Control Register)
-
- @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
- @Param[in]     val         - the new value for PMUXCR.
-
- @Return        None
-*//***************************************************************************/
-void P1023_SetMuxControlReg(uintptr_t gutilBase, uint32_t val);
-
-/**************************************************************************//**
- @Function      P1023_GetDeviceDisableStatusRegister
-
- @Description   Returns the value of DEVDISR (Device Disable Register)
-
- @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
-
- @Return        Value of DEVDISR
-*//***************************************************************************/
-uint32_t P1023_GetDeviceDisableStatusRegister(uintptr_t gutilBase);
-
-/**************************************************************************//**
- @Function      P1023_GetPorDeviceStatusRegister
-
- @Description   Returns the value of POR Device Status Register
-
- @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
-
- @Return        POR Device Status Register
-*//***************************************************************************/
-uint32_t P1023_GetPorDeviceStatusRegister(uintptr_t gutilBase);
-
-/**************************************************************************//**
- @Function      P1023_GetPorBootModeStatusRegister
-
- @Description   Returns the value of POR Boot Mode Status Register
-
- @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
-
- @Return        POR Boot Mode Status Register value
-*//***************************************************************************/
-uint32_t P1023_GetPorBootModeStatusRegister(uintptr_t gutilBase);
-
-
-#define PORDEVSR_SGMII1_DIS     0x10000000
-#define PORDEVSR_SGMII2_DIS     0x08000000
-#define PORDEVSR_ECP1           0x02000000
-#define PORDEVSR_IO_SEL         0x00780000
-#define PORDEVSR_IO_SEL_SHIFT   19
-#define PORBMSR_HA              0x00070000
-#define PORBMSR_HA_SHIFT        16
-
-#define DEVDISR_QM_BM           0x80000000
-#define DEVDISR_FM              0x40000000
-#define DEVDISR_PCIE1           0x20000000
-#define DEVDISR_MAC_SEC         0x10000000
-#define DEVDISR_ELBC            0x08000000
-#define DEVDISR_PCIE2           0x04000000
-#define DEVDISR_PCIE3           0x02000000
-#define DEVDISR_CAAM            0x01000000
-#define DEVDISR_USB0            0x00800000
-#define DEVDISR_1588            0x00020000
-#define DEVDISR_CORE0           0x00008000
-#define DEVDISR_TB0             0x00004000
-#define DEVDISR_CORE1           0x00002000
-#define DEVDISR_TB1             0x00001000
-#define DEVDISR_DMA1            0x00000400
-#define DEVDISR_DMA2            0x00000200
-#define DEVDISR_DDR             0x00000010
-#define DEVDISR_TSEC1           0x00000080
-#define DEVDISR_TSEC2           0x00000040
-#define DEVDISR_SPI             0x00000008
-#define DEVDISR_I2C             0x00000004
-#define DEVDISR_DUART           0x00000002
-
-#endif /* P1023 */
-
-#endif /* __PART_INTEGRATION_P1023_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/integrations/part_ext.h.orig	2022-05-26 11:28:30.982977418 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/integrations/part_ext.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,71 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          part_ext.h
-
- @Description   Definitions for the part (integration) module.
-*//***************************************************************************/
-
-#ifndef __PART_EXT_H
-#define __PART_EXT_H
-
-#include "std_ext.h"
-#include "part_integration_ext.h"
-
-
-#if !(defined(P1023) || defined(P2041) || defined(P3041) || defined(P4080) || defined(P5020) || defined(P5040) || defined(B4860) || defined(T4240))
-#error "unable to proceed without chip-definition"
-#endif
-
-
-/**************************************************************************//*
- @Description   Part data structure - must be contained in any integration
-                data structure.
-*//***************************************************************************/
-typedef struct t_Part
-{
-    uintptr_t   (* f_GetModuleBase)(t_Handle h_Part, e_ModuleId moduleId);
-                /**< Returns the address of the module's memory map base. */
-    e_ModuleId  (* f_GetModuleIdByBase)(t_Handle h_Part, uintptr_t baseAddress);
-                /**< Returns the module's ID according to its memory map base. */
-} t_Part;
-
-#ifdef P1023
-#include "part_P1023.h"
-#elif defined B4860 || defined T4240
-#include "part_B4_T4.h"
-#else
-#include "part_P3_P4_P5.h"
-#endif
-
-#endif /* __PART_EXT_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/integrations/part_integration_ext.h.orig	2022-05-26 11:28:30.986977256 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/integrations/part_integration_ext.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,62 +0,0 @@
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          part_integration_ext.h
-
- @Description   P4080/P5020/P3041/P1023 external definitions and structures.
-*//***************************************************************************/
-#ifndef __PART_INTEGRATION_EXT_H
-#define __PART_INTEGRATION_EXT_H
-
-#ifdef P1023
-#include "part_integration_P1023.h"
-#elif defined B4860 || defined T4240
-#include "part_integration_B4_T4.h"
-#else
-#include "part_integration_P3_P4_P5.h"
-#endif
-
-/*****************************************************************************
- *  UNIFIED MODULE CODES
- *****************************************************************************/
-  #define MODULE_UNKNOWN          0x00000000
-  #define MODULE_FM               0x00010000
-  #define MODULE_FM_MURAM         0x00020000
-  #define MODULE_FM_PCD           0x00030000
-  #define MODULE_FM_RTC           0x00040000
-  #define MODULE_FM_MAC           0x00050000
-  #define MODULE_FM_PORT          0x00060000
-  #define MODULE_MM               0x00070000
-  #define MODULE_FM_SP            0x00080000
-
-#endif /* __PART_INTEGRATION_EXT_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/integrations/dpaa_integration_B4_T4.h.orig	2022-05-26 11:28:30.982977418 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/integrations/dpaa_integration_B4_T4.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,276 +0,0 @@
-/* Copyright (c) 2009-2012 Freescale Semiconductor, Inc
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**************************************************************************//**
- @File          dpaa_integration_B4_T4.h
-
- @Description   B4860/T4240 FM external definitions and structures.
-*//***************************************************************************/
-#ifndef __DPAA_INTEGRATION_B4_T4_H
-#define __DPAA_INTEGRATION_B4_T4_H
-
-#include "std_ext.h"
-
-#ifdef P1023
-#error "file for B4, T4"
-#endif
-
-
-#define DPAA_VERSION    11
-
-/**************************************************************************//**
- @Description   DPAA SW Portals Enumeration.
-*//***************************************************************************/
-typedef enum
-{
-    e_DPAA_SWPORTAL0 = 0,
-    e_DPAA_SWPORTAL1,
-    e_DPAA_SWPORTAL2,
-    e_DPAA_SWPORTAL3,
-    e_DPAA_SWPORTAL4,
-    e_DPAA_SWPORTAL5,
-    e_DPAA_SWPORTAL6,
-    e_DPAA_SWPORTAL7,
-    e_DPAA_SWPORTAL8,
-    e_DPAA_SWPORTAL9,
-    e_DPAA_SWPORTAL10,
-    e_DPAA_SWPORTAL11,
-    e_DPAA_SWPORTAL12,
-    e_DPAA_SWPORTAL13,
-    e_DPAA_SWPORTAL14,
-    e_DPAA_SWPORTAL15,
-    e_DPAA_SWPORTAL16,
-    e_DPAA_SWPORTAL17,
-    e_DPAA_SWPORTAL18,
-    e_DPAA_SWPORTAL19,
-    e_DPAA_SWPORTAL20,
-    e_DPAA_SWPORTAL21,
-    e_DPAA_SWPORTAL22,
-    e_DPAA_SWPORTAL23,
-    e_DPAA_SWPORTAL24,
-    e_DPAA_SWPORTAL_DUMMY_LAST
-} e_DpaaSwPortal;
-
-/**************************************************************************//**
- @Description   DPAA Direct Connect Portals Enumeration.
-*//***************************************************************************/
-typedef enum
-{
-    e_DPAA_DCPORTAL0 = 0,
-    e_DPAA_DCPORTAL1,
-    e_DPAA_DCPORTAL2,
-    e_DPAA_DCPORTAL_DUMMY_LAST
-} e_DpaaDcPortal;
-
-#define DPAA_MAX_NUM_OF_SW_PORTALS      e_DPAA_SWPORTAL_DUMMY_LAST
-#define DPAA_MAX_NUM_OF_DC_PORTALS      e_DPAA_DCPORTAL_DUMMY_LAST
-
-/*****************************************************************************
- QMan INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define QM_MAX_NUM_OF_POOL_CHANNELS     15      /**< Total number of channels, dedicated and pool */
-#define QM_MAX_NUM_OF_WQ                8       /**< Number of work queues per channel */
-#define QM_MAX_NUM_OF_CGS               256     /**< Congestion groups number */
-#define QM_MAX_NUM_OF_FQIDS             (16 * MEGABYTE)
-                                                /**< FQIDs range - 24 bits */
-
-/**************************************************************************//**
- @Description   Work Queue Channel assignments in QMan.
-*//***************************************************************************/
-typedef enum
-{
-    e_QM_FQ_CHANNEL_SWPORTAL0 = 0x0,              /**< Dedicated channels serviced by software portals 0 to 24 */
-    e_QM_FQ_CHANNEL_SWPORTAL1,
-    e_QM_FQ_CHANNEL_SWPORTAL2,
-    e_QM_FQ_CHANNEL_SWPORTAL3,
-    e_QM_FQ_CHANNEL_SWPORTAL4,
-    e_QM_FQ_CHANNEL_SWPORTAL5,
-    e_QM_FQ_CHANNEL_SWPORTAL6,
-    e_QM_FQ_CHANNEL_SWPORTAL7,
-    e_QM_FQ_CHANNEL_SWPORTAL8,
-    e_QM_FQ_CHANNEL_SWPORTAL9,
-    e_QM_FQ_CHANNEL_SWPORTAL10,
-    e_QM_FQ_CHANNEL_SWPORTAL11,
-    e_QM_FQ_CHANNEL_SWPORTAL12,
-    e_QM_FQ_CHANNEL_SWPORTAL13,
-    e_QM_FQ_CHANNEL_SWPORTAL14,
-    e_QM_FQ_CHANNEL_SWPORTAL15,
-    e_QM_FQ_CHANNEL_SWPORTAL16,
-    e_QM_FQ_CHANNEL_SWPORTAL17,
-    e_QM_FQ_CHANNEL_SWPORTAL18,
-    e_QM_FQ_CHANNEL_SWPORTAL19,
-    e_QM_FQ_CHANNEL_SWPORTAL20,
-    e_QM_FQ_CHANNEL_SWPORTAL21,
-    e_QM_FQ_CHANNEL_SWPORTAL22,
-    e_QM_FQ_CHANNEL_SWPORTAL23,
-    e_QM_FQ_CHANNEL_SWPORTAL24,
-
-    e_QM_FQ_CHANNEL_POOL1 = 0x401,               /**< Pool channels that can be serviced by any of the software portals */
-    e_QM_FQ_CHANNEL_POOL2,
-    e_QM_FQ_CHANNEL_POOL3,
-    e_QM_FQ_CHANNEL_POOL4,
-    e_QM_FQ_CHANNEL_POOL5,
-    e_QM_FQ_CHANNEL_POOL6,
-    e_QM_FQ_CHANNEL_POOL7,
-    e_QM_FQ_CHANNEL_POOL8,
-    e_QM_FQ_CHANNEL_POOL9,
-    e_QM_FQ_CHANNEL_POOL10,
-    e_QM_FQ_CHANNEL_POOL11,
-    e_QM_FQ_CHANNEL_POOL12,
-    e_QM_FQ_CHANNEL_POOL13,
-    e_QM_FQ_CHANNEL_POOL14,
-    e_QM_FQ_CHANNEL_POOL15,
-
-    e_QM_FQ_CHANNEL_FMAN0_SP0 = 0x800,           /**< Dedicated channels serviced by Direct Connect Portal 0:
-                                                      connected to FMan 0; assigned in incrementing order to
-                                                      each sub-portal (SP) in the portal */
-    e_QM_FQ_CHANNEL_FMAN0_SP1,
-    e_QM_FQ_CHANNEL_FMAN0_SP2,
-    e_QM_FQ_CHANNEL_FMAN0_SP3,
-    e_QM_FQ_CHANNEL_FMAN0_SP4,
-    e_QM_FQ_CHANNEL_FMAN0_SP5,
-    e_QM_FQ_CHANNEL_FMAN0_SP6,
-    e_QM_FQ_CHANNEL_FMAN0_SP7,
-    e_QM_FQ_CHANNEL_FMAN0_SP8,
-    e_QM_FQ_CHANNEL_FMAN0_SP9,
-    e_QM_FQ_CHANNEL_FMAN0_SP10,
-    e_QM_FQ_CHANNEL_FMAN0_SP11,
-    e_QM_FQ_CHANNEL_FMAN0_SP12,
-    e_QM_FQ_CHANNEL_FMAN0_SP13,
-    e_QM_FQ_CHANNEL_FMAN0_SP14,
-    e_QM_FQ_CHANNEL_FMAN0_SP15,
-
-    e_QM_FQ_CHANNEL_RMAN_SP0 = 0x820,            /**< Dedicated channels serviced by Direct Connect Portal 1: connected to RMan */
-    e_QM_FQ_CHANNEL_RMAN_SP1,
-
-    e_QM_FQ_CHANNEL_CAAM = 0x840                 /**< Dedicated channel serviced by Direct Connect Portal 2:
-                                                      connected to SEC */
-} e_QmFQChannel;
-
-/*****************************************************************************
- BMan INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define BM_MAX_NUM_OF_POOLS         64          /**< Number of buffers pools */
-
-
-/*****************************************************************************
- SEC INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define SEC_NUM_OF_DECOS            3
-#define SEC_ALL_DECOS_MASK          0x00000003
-
-/*****************************************************************************
- FM INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define INTG_MAX_NUM_OF_FM          2
-
-/* Ports defines */
-#define FM_MAX_NUM_OF_1G_MACS       6
-#define FM_MAX_NUM_OF_10G_MACS      2
-#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS + FM_MAX_NUM_OF_10G_MACS)
-#define FM_MAX_NUM_OF_OH_PORTS      6
-
-#define FM_MAX_NUM_OF_1G_RX_PORTS   FM_MAX_NUM_OF_1G_MACS
-#define FM_MAX_NUM_OF_10G_RX_PORTS  FM_MAX_NUM_OF_10G_MACS
-#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS + FM_MAX_NUM_OF_1G_RX_PORTS)
-
-#define FM_MAX_NUM_OF_1G_TX_PORTS   FM_MAX_NUM_OF_1G_MACS
-#define FM_MAX_NUM_OF_10G_TX_PORTS  FM_MAX_NUM_OF_10G_MACS
-#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS + FM_MAX_NUM_OF_1G_TX_PORTS)
-
-#define FM_PORT_MAX_NUM_OF_EXT_POOLS            4           /**< Number of external BM pools per Rx port */
-#define FM_PORT_NUM_OF_CONGESTION_GRPS          256         /**< Total number of congestion groups in QM */
-#define FM_MAX_NUM_OF_SUB_PORTALS               16
-#define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   0
-
-#define FM_VSP_MAX_NUM_OF_ENTRIES               64
-#define FM_MAX_NUM_OF_PFC_PRIORITIES            8
-
-/* RAMs defines */
-#define FM_MURAM_SIZE                   (384 * KILOBYTE)
-#define FM_IRAM_SIZE                    ( 64 * KILOBYTE)
-
-/* PCD defines */
-#define FM_PCD_PLCR_NUM_ENTRIES         256                 /**< Total number of policer profiles */
-#define FM_PCD_KG_NUM_OF_SCHEMES        32                  /**< Total number of KG schemes */
-#define FM_PCD_MAX_NUM_OF_CLS_PLANS     256                 /**< Number of classification plan entries. */
-
-/* RTC defines */
-#define FM_RTC_NUM_OF_ALARMS            2                   /**< RTC number of alarms */
-#define FM_RTC_NUM_OF_PERIODIC_PULSES   3                   /**< RTC number of periodic pulses */
-#define FM_RTC_NUM_OF_EXT_TRIGGERS      2                   /**< RTC number of external triggers */
-
-/* QMI defines */
-#define QMI_MAX_NUM_OF_TNUMS            64
-#define QMI_DEF_TNUMS_THRESH            48
-
-/* FPM defines */
-#define FM_NUM_OF_FMAN_CTRL_EVENT_REGS  4
-
-/* DMA defines */
-#define DMA_THRESH_MAX_COMMQ            83
-#define DMA_THRESH_MAX_BUF              127
-
-/* BMI defines */
-#define BMI_MAX_NUM_OF_TASKS            128
-#define BMI_MAX_NUM_OF_DMAS             84
-#define BMI_MAX_FIFO_SIZE               (FM_MURAM_SIZE)
-#define PORT_MAX_WEIGHT                 16
-
-#define FM_CHECK_PORT_RESTRICTIONS(__validPorts, __newPortIndx)   TRUE
-
-/* Unique T4240 */
-#define FM_OP_OPEN_DMA_MIN_LIMIT
-#define FM_NO_RESTRICT_ON_ACCESS_RSRC
-#define FM_NO_OP_OBSERVED_POOLS
-#define FM_FRAME_END_PARAMS_FOR_OP
-#define FM_DEQ_PIPELINE_PARAMS_FOR_OP
-#define FM_NO_TOTAL_DMAS
-#define FM_QMI_NO_SINGLE_ECC_EXCEPTION
-//TODO - for simulator only, due to wrong reset values. Remove when fixed,
-//and also search for the places it appears in the source files and remove
-//comments of majorRev<6
-#define FM_NO_GUARANTEED_RESET_VALUES
-
-/* FM erratas */
-//#define FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-
-#define FM_RX_PREAM_4_ERRATA_DTSEC_A001
-#define FM_MAGIC_PACKET_UNRECOGNIZED_ERRATA_DTSEC2              /* No implementation, Out of LLD scope */
-
-
-#define FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173
-
-#define FM_LEN_CHECK_ERRATA_FMAN_SW002
-
-
-#endif /* __DPAA_INTEGRATION_B4_T4_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/integrations/dpaa_integration_P3_P4_P5.h.orig	2022-05-26 11:28:30.982977418 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/integrations/dpaa_integration_P3_P4_P5.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,276 +0,0 @@
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          dpaa_integration_P3_P4_P5.h
-
- @Description   P4080/P5020/P3041 FM external definitions and structures.
-*//***************************************************************************/
-#ifndef __DPAA_INTEGRATION_P3_P4_P5_H
-#define __DPAA_INTEGRATION_P3_P4_P5_H
-
-#include "std_ext.h"
-
-#ifdef P1023
-#error "file for p3, p4, p5"
-#endif
-
-
-#define DPAA_VERSION    10
-
-/**************************************************************************//**
- @Description   DPAA SW Portals Enumeration.
-*//***************************************************************************/
-typedef enum
-{
-    e_DPAA_SWPORTAL0 = 0,
-    e_DPAA_SWPORTAL1,
-    e_DPAA_SWPORTAL2,
-    e_DPAA_SWPORTAL3,
-    e_DPAA_SWPORTAL4,
-    e_DPAA_SWPORTAL5,
-    e_DPAA_SWPORTAL6,
-    e_DPAA_SWPORTAL7,
-    e_DPAA_SWPORTAL8,
-    e_DPAA_SWPORTAL9,
-    e_DPAA_SWPORTAL_DUMMY_LAST
-} e_DpaaSwPortal;
-
-/**************************************************************************//**
- @Description   DPAA Direct Connect Portals Enumeration.
-*//***************************************************************************/
-typedef enum
-{
-    e_DPAA_DCPORTAL0 = 0,
-    e_DPAA_DCPORTAL1,
-    e_DPAA_DCPORTAL2,
-    e_DPAA_DCPORTAL3,
-    e_DPAA_DCPORTAL4,
-    e_DPAA_DCPORTAL_DUMMY_LAST
-} e_DpaaDcPortal;
-
-#define DPAA_MAX_NUM_OF_SW_PORTALS      e_DPAA_SWPORTAL_DUMMY_LAST
-#define DPAA_MAX_NUM_OF_DC_PORTALS      e_DPAA_DCPORTAL_DUMMY_LAST
-
-/*****************************************************************************
- QMan INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define QM_MAX_NUM_OF_POOL_CHANNELS 15              /**< Total number of channels, dedicated and pool */
-#define QM_MAX_NUM_OF_WQ            8               /**< Number of work queues per channel */
-#define QM_MAX_NUM_OF_SWP_AS        4
-#define QM_MAX_NUM_OF_CGS           256             /**< Number of congestion groups */
-#define QM_MAX_NUM_OF_FQIDS         (16 * MEGABYTE) /**< FQIDs range - 24 bits */
-
-/**************************************************************************//**
- @Description   Work Queue Channel assignments in QMan.
-*//***************************************************************************/
-typedef enum
-{
-    e_QM_FQ_CHANNEL_SWPORTAL0 = 0,              /**< Dedicated channels serviced by software portals 0 to 9 */
-    e_QM_FQ_CHANNEL_SWPORTAL1,
-    e_QM_FQ_CHANNEL_SWPORTAL2,
-    e_QM_FQ_CHANNEL_SWPORTAL3,
-    e_QM_FQ_CHANNEL_SWPORTAL4,
-    e_QM_FQ_CHANNEL_SWPORTAL5,
-    e_QM_FQ_CHANNEL_SWPORTAL6,
-    e_QM_FQ_CHANNEL_SWPORTAL7,
-    e_QM_FQ_CHANNEL_SWPORTAL8,
-    e_QM_FQ_CHANNEL_SWPORTAL9,
-
-    e_QM_FQ_CHANNEL_POOL1 = 0x21,               /**< Pool channels that can be serviced by any of the software portals */
-    e_QM_FQ_CHANNEL_POOL2,
-    e_QM_FQ_CHANNEL_POOL3,
-    e_QM_FQ_CHANNEL_POOL4,
-    e_QM_FQ_CHANNEL_POOL5,
-    e_QM_FQ_CHANNEL_POOL6,
-    e_QM_FQ_CHANNEL_POOL7,
-    e_QM_FQ_CHANNEL_POOL8,
-    e_QM_FQ_CHANNEL_POOL9,
-    e_QM_FQ_CHANNEL_POOL10,
-    e_QM_FQ_CHANNEL_POOL11,
-    e_QM_FQ_CHANNEL_POOL12,
-    e_QM_FQ_CHANNEL_POOL13,
-    e_QM_FQ_CHANNEL_POOL14,
-    e_QM_FQ_CHANNEL_POOL15,
-
-    e_QM_FQ_CHANNEL_FMAN0_SP0 = 0x40,           /**< Dedicated channels serviced by Direct Connect Portal 0:
-                                                     connected to FMan 0; assigned in incrementing order to
-                                                     each sub-portal (SP) in the portal */
-    e_QM_FQ_CHANNEL_FMAN0_SP1,
-    e_QM_FQ_CHANNEL_FMAN0_SP2,
-    e_QM_FQ_CHANNEL_FMAN0_SP3,
-    e_QM_FQ_CHANNEL_FMAN0_SP4,
-    e_QM_FQ_CHANNEL_FMAN0_SP5,
-    e_QM_FQ_CHANNEL_FMAN0_SP6,
-    e_QM_FQ_CHANNEL_FMAN0_SP7,
-    e_QM_FQ_CHANNEL_FMAN0_SP8,
-    e_QM_FQ_CHANNEL_FMAN0_SP9,
-    e_QM_FQ_CHANNEL_FMAN0_SP10,
-    e_QM_FQ_CHANNEL_FMAN0_SP11,
-/* difference between 5020 and 4080 :) */
-    e_QM_FQ_CHANNEL_FMAN1_SP0 = 0x60,
-    e_QM_FQ_CHANNEL_FMAN1_SP1,
-    e_QM_FQ_CHANNEL_FMAN1_SP2,
-    e_QM_FQ_CHANNEL_FMAN1_SP3,
-    e_QM_FQ_CHANNEL_FMAN1_SP4,
-    e_QM_FQ_CHANNEL_FMAN1_SP5,
-    e_QM_FQ_CHANNEL_FMAN1_SP6,
-    e_QM_FQ_CHANNEL_FMAN1_SP7,
-    e_QM_FQ_CHANNEL_FMAN1_SP8,
-    e_QM_FQ_CHANNEL_FMAN1_SP9,
-    e_QM_FQ_CHANNEL_FMAN1_SP10,
-    e_QM_FQ_CHANNEL_FMAN1_SP11,
-
-    e_QM_FQ_CHANNEL_CAAM = 0x80,                /**< Dedicated channel serviced by Direct Connect Portal 2:
-                                                     connected to SEC 4.x */
-
-    e_QM_FQ_CHANNEL_PME = 0xA0,                 /**< Dedicated channel serviced by Direct Connect Portal 3:
-                                                     connected to PME */
-    e_QM_FQ_CHANNEL_RAID = 0xC0                 /**< Dedicated channel serviced by Direct Connect Portal 4:
-                                                     connected to RAID */
-} e_QmFQChannel;
-
-/*****************************************************************************
- BMan INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define BM_MAX_NUM_OF_POOLS         64          /**< Number of buffers pools */
-
-
-/*****************************************************************************
- FM INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define INTG_MAX_NUM_OF_FM          2
-
-/* Ports defines */
-#define FM_MAX_NUM_OF_1G_RX_PORTS   5
-#define FM_MAX_NUM_OF_10G_RX_PORTS  1
-#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS+FM_MAX_NUM_OF_1G_RX_PORTS)
-#define FM_MAX_NUM_OF_1G_TX_PORTS   5
-#define FM_MAX_NUM_OF_10G_TX_PORTS  1
-#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS+FM_MAX_NUM_OF_1G_TX_PORTS)
-#define FM_MAX_NUM_OF_OH_PORTS      7
-#define FM_MAX_NUM_OF_1G_MACS       (FM_MAX_NUM_OF_1G_RX_PORTS)
-#define FM_MAX_NUM_OF_10G_MACS      (FM_MAX_NUM_OF_10G_RX_PORTS)
-#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS+FM_MAX_NUM_OF_10G_MACS)
-
-
-#define FM_PORT_MAX_NUM_OF_EXT_POOLS            8           /**< Number of external BM pools per Rx port */
-#define FM_PORT_NUM_OF_CONGESTION_GRPS          256         /**< Total number of congestion groups in QM */
-#define FM_MAX_NUM_OF_SUB_PORTALS               12
-#define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   0
-
-#define FM_IPSEC_SUPPORT
-
-/* RAMs defines */
-#define FM_MURAM_SIZE                   (160 * KILOBYTE)
-#define FM_IRAM_SIZE                    ( 64 * KILOBYTE)
-
-/* PCD defines */
-#define FM_PCD_PLCR_NUM_ENTRIES         256                 /**< Total number of policer profiles */
-#define FM_PCD_KG_NUM_OF_SCHEMES        32                  /**< Total number of KG schemes */
-#define FM_PCD_MAX_NUM_OF_CLS_PLANS     256                 /**< Number of classification plan entries. */
-
-/* RTC defines */
-#define FM_RTC_NUM_OF_ALARMS            2                   /**< RTC number of alarms */
-#define FM_RTC_NUM_OF_PERIODIC_PULSES   2                   /**< RTC number of periodic pulses */
-#define FM_RTC_NUM_OF_EXT_TRIGGERS      2                   /**< RTC number of external triggers */
-
-/* QMI defines */
-#define QMI_MAX_NUM_OF_TNUMS            64
-#define QMI_DEF_TNUMS_THRESH            48
-
-/* FPM defines */
-#define FM_NUM_OF_FMAN_CTRL_EVENT_REGS  4
-
-/* DMA defines */
-#define DMA_THRESH_MAX_COMMQ            31
-#define DMA_THRESH_MAX_BUF              127
-
-/* BMI defines */
-#define BMI_MAX_NUM_OF_TASKS            128
-#define BMI_MAX_NUM_OF_DMAS             32
-#define BMI_MAX_FIFO_SIZE               (FM_MURAM_SIZE)
-#define PORT_MAX_WEIGHT                 16
-
-
-#define FM_CHECK_PORT_RESTRICTIONS(__validPorts, __newPortIndx)   TRUE
-
-/* p4080-rev1 unique features */
-#define QM_CGS_NO_FRAME_MODE
-
-/* p4080 unique features */
-#define FM_NO_DISPATCH_RAM_ECC
-#define FM_FIFO_ALLOCATION_OLD_ALG
-#define FM_NO_WATCHDOG
-#define FM_NO_TNUM_AGING
-#define FM_KG_NO_BYPASS_FQID_GEN
-#define FM_KG_NO_BYPASS_PLCR_PROFILE_GEN
-#define FM_NO_BACKUP_POOLS
-#define FM_NO_OP_OBSERVED_POOLS
-#define FM_NO_ADVANCED_RATE_LIMITER
-#define FM_NO_OP_OBSERVED_CGS
-#define FM_HAS_TOTAL_DMAS
-#define FM_KG_NO_IPPID_SUPPORT
-#define FM_NO_GUARANTEED_RESET_VALUES
-#define FM_MAC_RESET
-
-/* FM erratas */
-#define FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-#define FM_TX_SHORT_FRAME_BAD_TS_ERRATA_10GMAC_A006     /* No implementation, Out of LLD scope */
-#define FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007
-#define FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008
-#define FM_TX_INVALID_ECC_ERRATA_10GMAC_A009
-#define FM_BAD_VLAN_DETECT_ERRATA_10GMAC_A010
-
-#define FM_RX_PREAM_4_ERRATA_DTSEC_A001
-#define FM_GRS_ERRATA_DTSEC_A002
-#define FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003
-#define FM_GTS_ERRATA_DTSEC_A004
-#define FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012
-#define FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014
-
-#define FM_MAGIC_PACKET_UNRECOGNIZED_ERRATA_DTSEC2          /* No implementation, Out of LLD scope */
-#define FM_TX_LOCKUP_ERRATA_DTSEC6
-
-#define FM_HC_DEF_FQID_ONLY_ERRATA_FMAN_A003                /* Implemented by ucode */
-#define FM_DEBUG_TRACE_FMAN_A004                            /* No implementation, Out of LLD scope */
-
-#define FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173
-
-#define FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005
-
-#define FM_LEN_CHECK_ERRATA_FMAN_SW002
-
-#define FM_NO_CTXA_COPY_ERRATA_FMAN_SW001
-#define FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
-
-#endif /* __DPAA_INTEGRATION_P3_P4_P5_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/integrations/part_B4_T4.h.orig	2022-05-26 11:28:30.982977418 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/integrations/part_B4_T4.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,44 +0,0 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**************************************************************************//**
- @File          part_B4_T4.h
-
- @Description   Definitions for the part (integration) module.
-*//***************************************************************************/
-
-#ifndef __PART_B4_T4_H
-#define __PART_B4_T4_H
-
-/* B4/T4 chip-specific defs. should go here. */
-
-#endif /* __PART_B4_T4_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/integrations/dpaa_integration_ext.h.orig	2022-05-26 11:28:30.982977418 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/integrations/dpaa_integration_ext.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,49 +0,0 @@
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          dpaa_integration_ext.h
-
- @Description   FM external definitions and structures.
-*//***************************************************************************/
-#ifndef __DPAA_INTEGRATION_EXT_H
-#define __DPAA_INTEGRATION_EXT_H
-
-#ifdef P1023
-#include "dpaa_integration_P1023.h"
-#elif defined B4860 || defined T4240
-#include "dpaa_integration_B4_T4.h"
-#else
-#include "dpaa_integration_P3_P4_P5.h"
-#endif
-
-#endif /* __DPAA_INTEGRATION_EXT_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/integrations/part_integration_P3_P4_P5.h.orig	2022-05-26 11:28:30.986977256 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/integrations/part_integration_P3_P4_P5.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,305 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          part_integration_P3_P4_P5.h
-
- @Description   P4080/P5020/P3041 external definitions and structures.
-*//***************************************************************************/
-#ifndef __PART_INTEGRATION_P3_P4_P5_H
-#define __PART_INTEGRATION_P3_P4_P5_H
-
-#include "std_ext.h"
-#include "dpaa_integration_ext.h"
-
-#ifndef P1023
-
-/**************************************************************************//**
- @Group         P3040/P4080/P5020_chip_id P5020 Application Programming Interface
-
- @Description   P3040/P4080/P5020 Chip functions,definitions and enums.
-
- @{
-*//***************************************************************************/
-
-#define CORE_E500MC
-
-#define INTG_MAX_NUM_OF_CORES   1
-#define CORE_GetId()            0
-#define CORE_IS_BIG_ENDIAN
-#define SYS_ANY_CORE    ((uint32_t)-1)  /**< Assignment to any valid core */
-#define SYS_IS_MASTER_CORE()    TRUE
-
-
-/**************************************************************************//**
- @Description   Module types.
-*//***************************************************************************/
-typedef enum e_ModuleId
-{
-    e_MODULE_ID_DUART_1 = 0,
-    e_MODULE_ID_DUART_2,
-    e_MODULE_ID_DUART_3,
-    e_MODULE_ID_DUART_4,
-    e_MODULE_ID_LAW,
-    e_MODULE_ID_LBC,
-    e_MODULE_ID_PAMU,
-    e_MODULE_ID_QM,                 /**< Queue manager module */
-    e_MODULE_ID_BM,                 /**< Buffer manager module */
-    e_MODULE_ID_QM_CE_PORTAL_0,
-    e_MODULE_ID_QM_CI_PORTAL_0,
-    e_MODULE_ID_QM_CE_PORTAL_1,
-    e_MODULE_ID_QM_CI_PORTAL_1,
-    e_MODULE_ID_QM_CE_PORTAL_2,
-    e_MODULE_ID_QM_CI_PORTAL_2,
-    e_MODULE_ID_QM_CE_PORTAL_3,
-    e_MODULE_ID_QM_CI_PORTAL_3,
-    e_MODULE_ID_QM_CE_PORTAL_4,
-    e_MODULE_ID_QM_CI_PORTAL_4,
-    e_MODULE_ID_QM_CE_PORTAL_5,
-    e_MODULE_ID_QM_CI_PORTAL_5,
-    e_MODULE_ID_QM_CE_PORTAL_6,
-    e_MODULE_ID_QM_CI_PORTAL_6,
-    e_MODULE_ID_QM_CE_PORTAL_7,
-    e_MODULE_ID_QM_CI_PORTAL_7,
-    e_MODULE_ID_QM_CE_PORTAL_8,
-    e_MODULE_ID_QM_CI_PORTAL_8,
-    e_MODULE_ID_QM_CE_PORTAL_9,
-    e_MODULE_ID_QM_CI_PORTAL_9,
-    e_MODULE_ID_BM_CE_PORTAL_0,
-    e_MODULE_ID_BM_CI_PORTAL_0,
-    e_MODULE_ID_BM_CE_PORTAL_1,
-    e_MODULE_ID_BM_CI_PORTAL_1,
-    e_MODULE_ID_BM_CE_PORTAL_2,
-    e_MODULE_ID_BM_CI_PORTAL_2,
-    e_MODULE_ID_BM_CE_PORTAL_3,
-    e_MODULE_ID_BM_CI_PORTAL_3,
-    e_MODULE_ID_BM_CE_PORTAL_4,
-    e_MODULE_ID_BM_CI_PORTAL_4,
-    e_MODULE_ID_BM_CE_PORTAL_5,
-    e_MODULE_ID_BM_CI_PORTAL_5,
-    e_MODULE_ID_BM_CE_PORTAL_6,
-    e_MODULE_ID_BM_CI_PORTAL_6,
-    e_MODULE_ID_BM_CE_PORTAL_7,
-    e_MODULE_ID_BM_CI_PORTAL_7,
-    e_MODULE_ID_BM_CE_PORTAL_8,
-    e_MODULE_ID_BM_CI_PORTAL_8,
-    e_MODULE_ID_BM_CE_PORTAL_9,
-    e_MODULE_ID_BM_CI_PORTAL_9,
-    e_MODULE_ID_FM1,                /**< Frame manager #1 module */
-    e_MODULE_ID_FM1_RTC,            /**< FM Real-Time-Clock */
-    e_MODULE_ID_FM1_MURAM,          /**< FM Multi-User-RAM */
-    e_MODULE_ID_FM1_BMI,            /**< FM BMI block */
-    e_MODULE_ID_FM1_QMI,            /**< FM QMI block */
-    e_MODULE_ID_FM1_PRS,            /**< FM parser block */
-    e_MODULE_ID_FM1_PORT_HO0,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM1_PORT_HO1,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM1_PORT_HO2,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM1_PORT_HO3,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM1_PORT_HO4,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM1_PORT_HO5,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM1_PORT_HO6,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM1_PORT_1GRx0,     /**< FM Rx 1G MAC port block */
-    e_MODULE_ID_FM1_PORT_1GRx1,     /**< FM Rx 1G MAC port block */
-    e_MODULE_ID_FM1_PORT_1GRx2,     /**< FM Rx 1G MAC port block */
-    e_MODULE_ID_FM1_PORT_1GRx3,     /**< FM Rx 1G MAC port block */
-    e_MODULE_ID_FM1_PORT_1GRx4,     /**< FM Rx 1G MAC port block */
-    e_MODULE_ID_FM1_PORT_10GRx0,    /**< FM Rx 10G MAC port block */
-    e_MODULE_ID_FM1_PORT_1GTx0,     /**< FM Tx 1G MAC port block */
-    e_MODULE_ID_FM1_PORT_1GTx1,     /**< FM Tx 1G MAC port block */
-    e_MODULE_ID_FM1_PORT_1GTx2,     /**< FM Tx 1G MAC port block */
-    e_MODULE_ID_FM1_PORT_1GTx3,     /**< FM Tx 1G MAC port block */
-    e_MODULE_ID_FM1_PORT_1GTx4,     /**< FM Tx 1G MAC port block */
-    e_MODULE_ID_FM1_PORT_10GTx0,    /**< FM Tx 10G MAC port block */
-    e_MODULE_ID_FM1_PLCR,           /**< FM Policer */
-    e_MODULE_ID_FM1_KG,             /**< FM Keygen */
-    e_MODULE_ID_FM1_DMA,            /**< FM DMA */
-    e_MODULE_ID_FM1_FPM,            /**< FM FPM */
-    e_MODULE_ID_FM1_IRAM,           /**< FM Instruction-RAM */
-    e_MODULE_ID_FM1_1GMDIO0,        /**< FM 1G MDIO MAC 0*/
-    e_MODULE_ID_FM1_1GMDIO1,        /**< FM 1G MDIO MAC 1*/
-    e_MODULE_ID_FM1_1GMDIO2,        /**< FM 1G MDIO MAC 2*/
-    e_MODULE_ID_FM1_1GMDIO3,        /**< FM 1G MDIO MAC 3*/
-    e_MODULE_ID_FM1_10GMDIO,        /**< FM 10G MDIO */
-    e_MODULE_ID_FM1_PRS_IRAM,       /**< FM SW-parser Instruction-RAM */
-    e_MODULE_ID_FM1_1GMAC0,         /**< FM 1G MAC #0 */
-    e_MODULE_ID_FM1_1GMAC1,         /**< FM 1G MAC #1 */
-    e_MODULE_ID_FM1_1GMAC2,         /**< FM 1G MAC #2 */
-    e_MODULE_ID_FM1_1GMAC3,         /**< FM 1G MAC #3 */
-    e_MODULE_ID_FM1_10GMAC0,        /**< FM 10G MAC #0 */
-
-    e_MODULE_ID_FM2,                /**< Frame manager #2 module */
-    e_MODULE_ID_FM2_RTC,            /**< FM Real-Time-Clock */
-    e_MODULE_ID_FM2_MURAM,          /**< FM Multi-User-RAM */
-    e_MODULE_ID_FM2_BMI,            /**< FM BMI block */
-    e_MODULE_ID_FM2_QMI,            /**< FM QMI block */
-    e_MODULE_ID_FM2_PRS,            /**< FM parser block */
-    e_MODULE_ID_FM2_PORT_HO0,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM2_PORT_HO1,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM2_PORT_HO2,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM2_PORT_HO3,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM2_PORT_HO4,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM2_PORT_HO5,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM2_PORT_HO6,       /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM2_PORT_1GRx0,     /**< FM Rx 1G MAC port block */
-    e_MODULE_ID_FM2_PORT_1GRx1,     /**< FM Rx 1G MAC port block */
-    e_MODULE_ID_FM2_PORT_1GRx2,     /**< FM Rx 1G MAC port block */
-    e_MODULE_ID_FM2_PORT_1GRx3,     /**< FM Rx 1G MAC port block */
-    e_MODULE_ID_FM2_PORT_10GRx0,    /**< FM Rx 10G MAC port block */
-    e_MODULE_ID_FM2_PORT_1GTx0,     /**< FM Tx 1G MAC port block */
-    e_MODULE_ID_FM2_PORT_1GTx1,     /**< FM Tx 1G MAC port block */
-    e_MODULE_ID_FM2_PORT_1GTx2,     /**< FM Tx 1G MAC port block */
-    e_MODULE_ID_FM2_PORT_1GTx3,     /**< FM Tx 1G MAC port block */
-    e_MODULE_ID_FM2_PORT_10GTx0,    /**< FM Tx 10G MAC port block */
-    e_MODULE_ID_FM2_PLCR,           /**< FM Policer */
-    e_MODULE_ID_FM2_KG,             /**< FM Keygen */
-    e_MODULE_ID_FM2_DMA,            /**< FM DMA */
-    e_MODULE_ID_FM2_FPM,            /**< FM FPM */
-    e_MODULE_ID_FM2_IRAM,           /**< FM Instruction-RAM */
-    e_MODULE_ID_FM2_1GMDIO0,        /**< FM 1G MDIO MAC 0*/
-    e_MODULE_ID_FM2_1GMDIO1,        /**< FM 1G MDIO MAC 1*/
-    e_MODULE_ID_FM2_1GMDIO2,        /**< FM 1G MDIO MAC 2*/
-    e_MODULE_ID_FM2_1GMDIO3,        /**< FM 1G MDIO MAC 3*/
-    e_MODULE_ID_FM2_10GMDIO,        /**< FM 10G MDIO */
-    e_MODULE_ID_FM2_PRS_IRAM,       /**< FM SW-parser Instruction-RAM */
-    e_MODULE_ID_FM2_1GMAC0,         /**< FM 1G MAC #0 */
-    e_MODULE_ID_FM2_1GMAC1,         /**< FM 1G MAC #1 */
-    e_MODULE_ID_FM2_1GMAC2,         /**< FM 1G MAC #2 */
-    e_MODULE_ID_FM2_1GMAC3,         /**< FM 1G MAC #3 */
-    e_MODULE_ID_FM2_10GMAC0,        /**< FM 10G MAC #0 */
-
-    e_MODULE_ID_SEC_GEN,            /**< SEC 4.0 General registers      */
-    e_MODULE_ID_SEC_QI,             /**< SEC 4.0 QI registers           */
-    e_MODULE_ID_SEC_JQ0,            /**< SEC 4.0 JQ-0 registers         */
-    e_MODULE_ID_SEC_JQ1,            /**< SEC 4.0 JQ-1 registers         */
-    e_MODULE_ID_SEC_JQ2,            /**< SEC 4.0 JQ-2 registers         */
-    e_MODULE_ID_SEC_JQ3,            /**< SEC 4.0 JQ-3 registers         */
-    e_MODULE_ID_SEC_RTIC,           /**< SEC 4.0 RTIC registers         */
-    e_MODULE_ID_SEC_DECO0_CCB0,     /**< SEC 4.0 DECO-0/CCB-0 registers */
-    e_MODULE_ID_SEC_DECO1_CCB1,     /**< SEC 4.0 DECO-1/CCB-1 registers */
-    e_MODULE_ID_SEC_DECO2_CCB2,     /**< SEC 4.0 DECO-2/CCB-2 registers */
-    e_MODULE_ID_SEC_DECO3_CCB3,     /**< SEC 4.0 DECO-3/CCB-3 registers */
-    e_MODULE_ID_SEC_DECO4_CCB4,     /**< SEC 4.0 DECO-4/CCB-4 registers */
-
-    e_MODULE_ID_MPIC,               /**< MPIC */
-    e_MODULE_ID_GPIO,               /**< GPIO */
-    e_MODULE_ID_SERDES,             /**< SERDES */
-    e_MODULE_ID_CPC_1,              /**< CoreNet-Platform-Cache 1 */
-    e_MODULE_ID_CPC_2,              /**< CoreNet-Platform-Cache 2 */
-
-    e_MODULE_ID_SRIO_PORTS,     	/**< RapidIO controller */
-    e_MODULE_ID_SRIO_MU,        	/**< RapidIO messaging unit module */
-
-    e_MODULE_ID_DUMMY_LAST
-} e_ModuleId;
-
-#define NUM_OF_MODULES  e_MODULE_ID_DUMMY_LAST
-
-
-/*****************************************************************************
- PAMU INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define PAMU_NUM_OF_PARTITIONS  5
-
-#define PAMU_PICS_AVICS_ERRATA_PAMU3
-
-/*****************************************************************************
- LAW INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define LAW_NUM_OF_WINDOWS      32
-#define LAW_MIN_WINDOW_SIZE     0x0000000000001000LL    /**< 4KB */
-#define LAW_MAX_WINDOW_SIZE     0x0000002000000000LL    /**< 64GB */
-
-
-/*****************************************************************************
- LBC INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-/**************************************************************************//**
- @Group         lbc_exception_grp LBC Exception Unit
-
- @Description   LBC Exception unit API functions, definitions and enums
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Anchor        lbc_exbm
-
- @Collection    LBC Errors Bit Mask
-
-                These errors are reported through the exceptions callback..
-                The values can be or'ed in any combination in the errors mask
-                parameter of the errors report structure.
-
-                These errors can also be passed as a bit-mask to
-                LBC_EnableErrorChecking() or LBC_DisableErrorChecking(),
-                for enabling or disabling error checking.
- @{
-*//***************************************************************************/
-#define LBC_ERR_BUS_MONITOR     0x80000000  /**< Bus monitor error */
-#define LBC_ERR_PARITY_ECC      0x20000000  /**< Parity error for GPCM/UPM */
-#define LBC_ERR_WRITE_PROTECT   0x04000000  /**< Write protection error */
-#define LBC_ERR_ATOMIC_WRITE    0x00800000  /**< Atomic write error */
-#define LBC_ERR_ATOMIC_READ     0x00400000  /**< Atomic read error */
-#define LBC_ERR_CHIP_SELECT     0x00080000  /**< Unrecognized chip select */
-
-#define LBC_ERR_ALL             (LBC_ERR_BUS_MONITOR | LBC_ERR_PARITY_ECC | \
-                                 LBC_ERR_WRITE_PROTECT | LBC_ERR_ATOMIC_WRITE | \
-                                 LBC_ERR_ATOMIC_READ | LBC_ERR_CHIP_SELECT)
-                                            /**< All possible errors */
-/* @} */
-/** @} */ /* end of lbc_exception_grp group */
-
-#define LBC_INCORRECT_ERROR_REPORT_ERRATA
-
-#define LBC_NUM_OF_BANKS            8
-#define LBC_MAX_CS_SIZE             0x0000000100000000LL
-#define LBC_ATOMIC_OPERATION_SUPPORT
-#define LBC_PARITY_SUPPORT
-#define LBC_ADDRESS_HOLD_TIME_CTRL
-#define LBC_HIGH_CLK_DIVIDERS
-#define LBC_FCM_AVAILABLE
-
-/*****************************************************************************
- GPIO INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define GPIO_NUM_OF_PORTS   1   /**< Number of ports in GPIO module;
-                                     Each port contains up to 32 i/O pins. */
-
-#define GPIO_VALID_PIN_MASKS  \
-    { /* Port A */ 0xFFFFFFFF }
-
-#define GPIO_VALID_INTR_MASKS \
-    { /* Port A */ 0xFFFFFFFF }
-
-#endif /* P1023 */
-
-#endif /* __PART_INTEGRATION_P3_P4_P5_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/integrations/dpaa_integration_P1023.h.orig	2022-05-26 11:28:30.982977418 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/integrations/dpaa_integration_P1023.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,329 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          dpaa_integration_P1023.h
-
- @Description   P1023 FM external definitions and structures.
-*//***************************************************************************/
-#ifndef __DPAA_INTEGRATION_P1023_H
-#define __DPAA_INTEGRATION_P1023_H
-
-#include "std_ext.h"
-
-#ifdef P1023
-
-#define CONFIG_FMAN_P1023
-#define DPAA_VERSION 10
-
-typedef enum e_DpaaSwPortal {
-    e_DPAA_SWPORTAL0 = 0,
-    e_DPAA_SWPORTAL1,
-    e_DPAA_SWPORTAL2,
-    e_DPAA_SWPORTAL_DUMMY_LAST
-} e_DpaaSwPortal;
-
-typedef enum {
-    e_DPAA_DCPORTAL0 = 0,
-    e_DPAA_DCPORTAL2,
-    e_DPAA_DCPORTAL_DUMMY_LAST
-} e_DpaaDcPortal;
-
-#define DPAA_MAX_NUM_OF_SW_PORTALS      e_DPAA_SWPORTAL_DUMMY_LAST
-#define DPAA_MAX_NUM_OF_DC_PORTALS      e_DPAA_DCPORTAL_DUMMY_LAST
-
-/*****************************************************************************
- QMAN INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define QM_MAX_NUM_OF_POOL_CHANNELS 3
-#define QM_MAX_NUM_OF_WQ            8
-#define QM_MAX_NUM_OF_SWP_AS        2
-#define QM_MAX_NUM_OF_CGS           64
-#define QM_MAX_NUM_OF_FQIDS         (16*MEGABYTE)
-
-typedef enum {
-    e_QM_FQ_CHANNEL_SWPORTAL0 = 0,
-    e_QM_FQ_CHANNEL_SWPORTAL1,
-    e_QM_FQ_CHANNEL_SWPORTAL2,
-
-    e_QM_FQ_CHANNEL_POOL1 = 0x21,
-    e_QM_FQ_CHANNEL_POOL2,
-    e_QM_FQ_CHANNEL_POOL3,
-
-    e_QM_FQ_CHANNEL_FMAN0_SP0 = 0x40,
-    e_QM_FQ_CHANNEL_FMAN0_SP1,
-    e_QM_FQ_CHANNEL_FMAN0_SP2,
-    e_QM_FQ_CHANNEL_FMAN0_SP3,
-    e_QM_FQ_CHANNEL_FMAN0_SP4,
-    e_QM_FQ_CHANNEL_FMAN0_SP5,
-    e_QM_FQ_CHANNEL_FMAN0_SP6,
-
-
-    e_QM_FQ_CHANNEL_CAAM = 0x80
-} e_QmFQChannel;
-
-/*****************************************************************************
- BMAN INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define BM_MAX_NUM_OF_POOLS         8
-
-/*****************************************************************************
- SEC INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define SEC_NUM_OF_DECOS    2
-#define SEC_ALL_DECOS_MASK  0x00000003
-
-/*****************************************************************************
- FM INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define INTG_MAX_NUM_OF_FM          1
-
-/* Ports defines */
-#define FM_MAX_NUM_OF_1G_RX_PORTS   2
-#define FM_MAX_NUM_OF_10G_RX_PORTS  0
-#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS+FM_MAX_NUM_OF_1G_RX_PORTS)
-#define FM_MAX_NUM_OF_1G_TX_PORTS   2
-#define FM_MAX_NUM_OF_10G_TX_PORTS  0
-#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS+FM_MAX_NUM_OF_1G_TX_PORTS)
-#define FM_MAX_NUM_OF_OH_PORTS      5
-#define FM_MAX_NUM_OF_1G_MACS       (FM_MAX_NUM_OF_1G_RX_PORTS)
-#define FM_MAX_NUM_OF_10G_MACS      (FM_MAX_NUM_OF_10G_RX_PORTS)
-#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS+FM_MAX_NUM_OF_10G_MACS)
-#define FM_MAX_NUM_OF_MACSECS       1
-
-#define FM_MACSEC_SUPPORT
-#define FM_DISABLE_SEC_ERRORS
-
-#define FM_LOW_END_RESTRICTION      /* prevents the use of TX port 1 with OP port 0 */
-
-#define FM_PORT_MAX_NUM_OF_EXT_POOLS            4           /**< Number of external BM pools per Rx port */
-#define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   2           /**< Number of Offline parsing port external BM pools per Rx port */
-#define FM_PORT_NUM_OF_CONGESTION_GRPS          32          /**< Total number of congestion groups in QM */
-#define FM_MAX_NUM_OF_SUB_PORTALS               7
-
-/* Rams defines */
-#define FM_MURAM_SIZE               (64*KILOBYTE)
-#define FM_IRAM_SIZE                (32*KILOBYTE)
-
-/* PCD defines */
-#define FM_PCD_PLCR_NUM_ENTRIES         32                  /**< Total number of policer profiles */
-#define FM_PCD_KG_NUM_OF_SCHEMES        16                  /**< Total number of KG schemes */
-#define FM_PCD_MAX_NUM_OF_CLS_PLANS     128                 /**< Number of classification plan entries. */
-
-/* RTC defines */
-#define FM_RTC_NUM_OF_ALARMS            2
-#define FM_RTC_NUM_OF_PERIODIC_PULSES   2
-#define FM_RTC_NUM_OF_EXT_TRIGGERS      2
-
-/* QMI defines */
-#define QMI_MAX_NUM_OF_TNUMS            15
-
-/* FPM defines */
-#define FM_NUM_OF_FMAN_CTRL_EVENT_REGS  4
-
-/* DMA defines */
-#define DMA_THRESH_MAX_COMMQ            15
-#define DMA_THRESH_MAX_BUF              7
-
-/* BMI defines */
-#define BMI_MAX_NUM_OF_TASKS            64
-#define BMI_MAX_NUM_OF_DMAS             16
-#define BMI_MAX_FIFO_SIZE              (FM_MURAM_SIZE)
-#define PORT_MAX_WEIGHT                 4
-
-/**************************************************************************//**
- @Description   Enum for inter-module interrupts registration
-*//***************************************************************************/
-typedef enum e_FmEventModules{
-    e_FM_MOD_PRS,                   /**< Parser event */
-    e_FM_MOD_KG,                    /**< Keygen event */
-    e_FM_MOD_PLCR,                  /**< Policer event */
-    e_FM_MOD_10G_MAC,               /**< 10G MAC  error event */
-    e_FM_MOD_1G_MAC,                /**< 1G MAC  error event */
-    e_FM_MOD_TMR,                   /**< Timer event */
-    e_FM_MOD_1G_MAC_TMR,            /**< 1G MAC  Timer event */
-    e_FM_MOD_FMAN_CTRL,             /**< FMAN Controller  Timer event */
-    e_FM_MOD_MACSEC,
-    e_FM_MOD_DUMMY_LAST
-} e_FmEventModules;
-
-/**************************************************************************//**
- @Description   Enum for interrupts types
-*//***************************************************************************/
-typedef enum e_FmIntrType {
-    e_FM_INTR_TYPE_ERR,
-    e_FM_INTR_TYPE_NORMAL
-} e_FmIntrType;
-
-/**************************************************************************//**
- @Description   Enum for inter-module interrupts registration
-*//***************************************************************************/
-typedef enum e_FmInterModuleEvent {
-    e_FM_EV_PRS,                    /**< Parser event */
-    e_FM_EV_ERR_PRS,                /**< Parser error event */
-    e_FM_EV_KG,                     /**< Keygen event */
-    e_FM_EV_ERR_KG,                 /**< Keygen error event */
-    e_FM_EV_PLCR,                   /**< Policer event */
-    e_FM_EV_ERR_PLCR,               /**< Policer error event */
-    e_FM_EV_ERR_10G_MAC0,           /**< 10G MAC 0 error event */
-    e_FM_EV_ERR_1G_MAC0,            /**< 1G MAC 0 error event */
-    e_FM_EV_ERR_1G_MAC1,            /**< 1G MAC 1 error event */
-    e_FM_EV_ERR_1G_MAC2,            /**< 1G MAC 2 error event */
-    e_FM_EV_ERR_1G_MAC3,            /**< 1G MAC 3 error event */
-    e_FM_EV_ERR_MACSEC_MAC0,        /**< MACSEC MAC 0 error event */
-    e_FM_EV_TMR,                    /**< Timer event */
-    e_FM_EV_1G_MAC0_TMR,            /**< 1G MAC 0 Timer event */
-    e_FM_EV_1G_MAC1_TMR,            /**< 1G MAC 1 Timer event */
-    e_FM_EV_1G_MAC2_TMR,            /**< 1G MAC 2 Timer event */
-    e_FM_EV_1G_MAC3_TMR,            /**< 1G MAC 3 Timer event */
-    e_FM_EV_MACSEC_MAC0,            /**< MACSEC MAC 0 event */
-    e_FM_EV_FMAN_CTRL_0,            /**< Fman controller event 0 */
-    e_FM_EV_FMAN_CTRL_1,            /**< Fman controller event 1 */
-    e_FM_EV_FMAN_CTRL_2,            /**< Fman controller event 2 */
-    e_FM_EV_FMAN_CTRL_3,            /**< Fman controller event 3 */
-    e_FM_EV_DUMMY_LAST
-} e_FmInterModuleEvent;
-
-#define GET_FM_MODULE_EVENT(mod, id, intrType, event)                                                  \
-    switch(mod){                                                                                    \
-        case e_FM_MOD_PRS:                                                                          \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PRS:e_FM_EV_PRS;            \
-            break;                                                                                  \
-        case e_FM_MOD_KG:                                                                           \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_KG:e_FM_EV_DUMMY_LAST;      \
-            break;                                                                                  \
-        case e_FM_MOD_PLCR:                                                                         \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PLCR:e_FM_EV_PLCR;          \
-            break;                                                                                  \
-        case e_FM_MOD_1G_MAC:                                                                       \
-            switch(id){                                                                             \
-                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC0:e_FM_EV_DUMMY_LAST; break; \
-                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC1:e_FM_EV_DUMMY_LAST; break;    \
-                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC2:e_FM_EV_DUMMY_LAST; break;    \
-                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC3:e_FM_EV_DUMMY_LAST; break;    \
-                 }                                                                                  \
-            break;                                                                                  \
-        case e_FM_MOD_TMR:                                                                          \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_TMR;         \
-            break;                                                                                  \
-        case e_FM_MOD_1G_MAC_TMR:                                                                   \
-            switch(id){                                                                             \
-                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC0_TMR; break; \
-                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC1_TMR; break; \
-                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC2_TMR; break; \
-                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC3_TMR; break; \
-                 }                                                                                  \
-            break;                                                                                  \
-        case e_FM_MOD_MACSEC:                                                                   \
-            switch(id){                                                                             \
-                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_MACSEC_MAC0:e_FM_EV_MACSEC_MAC0; break; \
-                 }                                                                                  \
-            break;                                                                                  \
-        case e_FM_MOD_FMAN_CTRL:                                                                    \
-            if (intrType == e_FM_INTR_TYPE_ERR) event = e_FM_EV_DUMMY_LAST;                         \
-            else switch(id){                                                                        \
-                 case(0): event = e_FM_EV_FMAN_CTRL_0; break;                                       \
-                 case(1): event = e_FM_EV_FMAN_CTRL_1; break;                                       \
-                 case(2): event = e_FM_EV_FMAN_CTRL_2; break;                                       \
-                 case(3): event = e_FM_EV_FMAN_CTRL_3; break;                                       \
-                 }                                                                                  \
-            break;                                                                                  \
-        default:event = e_FM_EV_DUMMY_LAST;                                                         \
-        break;}
-
-/*****************************************************************************
- FM MACSEC INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define NUM_OF_RX_SC                16
-#define NUM_OF_TX_SC                16
-
-#define NUM_OF_SA_PER_RX_SC         2
-#define NUM_OF_SA_PER_TX_SC         2
-
-/**************************************************************************//**
- @Description   Enum for inter-module interrupts registration
-*//***************************************************************************/
-
-typedef enum e_FmMacsecEventModules{
-    e_FM_MACSEC_MOD_SC_TX,
-    e_FM_MACSEC_MOD_DUMMY_LAST
-} e_FmMacsecEventModules;
-
-typedef enum e_FmMacsecInterModuleEvent {
-    e_FM_MACSEC_EV_SC_TX,
-    e_FM_MACSEC_EV_ERR_SC_TX,
-    e_FM_MACSEC_EV_DUMMY_LAST
-} e_FmMacsecInterModuleEvent;
-
-#define NUM_OF_INTER_MODULE_EVENTS (NUM_OF_TX_SC * 2)
-
-#define GET_MACSEC_MODULE_EVENT(mod, id, intrType, event) \
-    switch(mod){                                          \
-        case e_FM_MACSEC_MOD_SC_TX:                       \
-             event = (intrType == e_FM_INTR_TYPE_ERR) ?   \
-                        e_FM_MACSEC_EV_ERR_SC_TX:         \
-                        e_FM_MACSEC_EV_SC_TX;             \
-             event += (uint8_t)(2 * id);break;            \
-            break;                                        \
-        default:event = e_FM_MACSEC_EV_DUMMY_LAST;        \
-        break;}
-
-
-/* 1023 unique features */
-#define FM_QMI_NO_ECC_EXCEPTIONS
-#define FM_CSI_CFED_LIMIT
-#define FM_PEDANTIC_DMA
-#define FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-#define FM_FIFO_ALLOCATION_ALG
-#define FM_DEQ_PIPELINE_PARAMS_FOR_OP
-#define FM_HAS_TOTAL_DMAS
-#define FM_KG_NO_IPPID_SUPPORT
-#define FM_NO_GUARANTEED_RESET_VALUES
-#define FM_MAC_RESET
-
-/* FM erratas */
-#define FM_RX_PREAM_4_ERRATA_DTSEC_A001
-#define FM_MAGIC_PACKET_UNRECOGNIZED_ERRATA_DTSEC2      /* No implementation */
-
-#define FM_DEBUG_TRACE_FMAN_A004                        /* No implementation */
-#define FM_INT_BUF_LEAK_FMAN_A005                       /* No implementation. App must avoid S/G */
-
-
-#define FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
-
-#endif /* P1023 */
-
-#endif /* __FM_INTEGRATION_P1023_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/integrations/part_P3_P4_P5.h.orig	2022-05-26 11:28:30.982977418 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/integrations/part_P3_P4_P5.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,44 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          part_P3_P4_P5.h
-
- @Description   Definitions for the part (integration) module.
-*//***************************************************************************/
-
-#ifndef __PART_P3_P4_P5_H
-#define __PART_P3_P4_P5_H
-
-/* P3/4/5 chip-specific defs. should go here. */
-
-#endif /* __PART_P3_P4_P5_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/integrations/part_integration_B4_T4.h.orig	2022-05-26 11:28:30.982977418 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/integrations/part_integration_B4_T4.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,304 +0,0 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**************************************************************************//**
- @File          part_integration_B4_T4.h
-
- @Description   B4860/T4240 external definitions and structures.
-*//***************************************************************************/
-#ifndef __PART_INTEGRATION_B4_T4_H
-#define __PART_INTEGRATION_B4_T4_H
-
-#include "std_ext.h"
-#include "dpaa_integration_ext.h"
-
-
-/**************************************************************************//**
- @Group         T4240_chip_id T4240 Application Programming Interface
-
- @Description   T4240 Chip functions,definitions and enums.
-
- @{
-*//***************************************************************************/
-
-#define CORE_E6500
-
-#define INTG_MAX_NUM_OF_CORES   1
-#define CORE_GetId()            0
-#define CORE_IS_BIG_ENDIAN
-#define SYS_ANY_CORE    ((uint32_t)-1)  /**< Assignment to any valid core */
-#define SYS_IS_MASTER_CORE()    TRUE
-
-
-/**************************************************************************//**
- @Description   Module types.
-*//***************************************************************************/
-typedef enum e_ModuleId
-{
-    e_MODULE_ID_DUART_1 = 0,
-    e_MODULE_ID_DUART_2,
-    e_MODULE_ID_DUART_3,
-    e_MODULE_ID_DUART_4,
-    e_MODULE_ID_LAW,
-    e_MODULE_ID_IFC,
-    e_MODULE_ID_PAMU,
-    e_MODULE_ID_QM,                 /**< Queue manager module */
-    e_MODULE_ID_BM,                 /**< Buffer manager module */
-    e_MODULE_ID_QM_CE_PORTAL_0,
-    e_MODULE_ID_QM_CI_PORTAL_0,
-    e_MODULE_ID_QM_CE_PORTAL_1,
-    e_MODULE_ID_QM_CI_PORTAL_1,
-    e_MODULE_ID_QM_CE_PORTAL_2,
-    e_MODULE_ID_QM_CI_PORTAL_2,
-    e_MODULE_ID_QM_CE_PORTAL_3,
-    e_MODULE_ID_QM_CI_PORTAL_3,
-    e_MODULE_ID_QM_CE_PORTAL_4,
-    e_MODULE_ID_QM_CI_PORTAL_4,
-    e_MODULE_ID_QM_CE_PORTAL_5,
-    e_MODULE_ID_QM_CI_PORTAL_5,
-    e_MODULE_ID_QM_CE_PORTAL_6,
-    e_MODULE_ID_QM_CI_PORTAL_6,
-    e_MODULE_ID_QM_CE_PORTAL_7,
-    e_MODULE_ID_QM_CI_PORTAL_7,
-    e_MODULE_ID_QM_CE_PORTAL_8,
-    e_MODULE_ID_QM_CI_PORTAL_8,
-    e_MODULE_ID_QM_CE_PORTAL_9,
-    e_MODULE_ID_QM_CI_PORTAL_9,
-    e_MODULE_ID_BM_CE_PORTAL_0,
-    e_MODULE_ID_BM_CI_PORTAL_0,
-    e_MODULE_ID_BM_CE_PORTAL_1,
-    e_MODULE_ID_BM_CI_PORTAL_1,
-    e_MODULE_ID_BM_CE_PORTAL_2,
-    e_MODULE_ID_BM_CI_PORTAL_2,
-    e_MODULE_ID_BM_CE_PORTAL_3,
-    e_MODULE_ID_BM_CI_PORTAL_3,
-    e_MODULE_ID_BM_CE_PORTAL_4,
-    e_MODULE_ID_BM_CI_PORTAL_4,
-    e_MODULE_ID_BM_CE_PORTAL_5,
-    e_MODULE_ID_BM_CI_PORTAL_5,
-    e_MODULE_ID_BM_CE_PORTAL_6,
-    e_MODULE_ID_BM_CI_PORTAL_6,
-    e_MODULE_ID_BM_CE_PORTAL_7,
-    e_MODULE_ID_BM_CI_PORTAL_7,
-    e_MODULE_ID_BM_CE_PORTAL_8,
-    e_MODULE_ID_BM_CI_PORTAL_8,
-    e_MODULE_ID_BM_CE_PORTAL_9,
-    e_MODULE_ID_BM_CI_PORTAL_9,
-    e_MODULE_ID_FM,                 /**< Frame manager module */
-    e_MODULE_ID_FM_RTC,             /**< FM Real-Time-Clock */
-    e_MODULE_ID_FM_MURAM,           /**< FM Multi-User-RAM */
-    e_MODULE_ID_FM_BMI,             /**< FM BMI block */
-    e_MODULE_ID_FM_QMI,             /**< FM QMI block */
-    e_MODULE_ID_FM_PARSER,          /**< FM parser block */
-    e_MODULE_ID_FM_PORT_HO1,        /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM_PORT_HO2,        /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM_PORT_HO3,        /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM_PORT_HO4,        /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM_PORT_HO5,        /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM_PORT_HO6,        /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM_PORT_HO7,        /**< FM Host-command/offline-parsing port block */
-    e_MODULE_ID_FM_PORT_1GRx1,      /**< FM Rx 1G MAC port block */
-    e_MODULE_ID_FM_PORT_1GRx2,      /**< FM Rx 1G MAC port block */
-    e_MODULE_ID_FM_PORT_1GRx3,      /**< FM Rx 1G MAC port block */
-    e_MODULE_ID_FM_PORT_1GRx4,      /**< FM Rx 1G MAC port block */
-    e_MODULE_ID_FM_PORT_1GRx5,      /**< FM Rx 1G MAC port block */
-    e_MODULE_ID_FM_PORT_1GRx6,      /**< FM Rx 1G MAC port block */
-    e_MODULE_ID_FM_PORT_10GRx1,     /**< FM Rx 10G MAC port block */
-    e_MODULE_ID_FM_PORT_10GRx2,     /**< FM Rx 10G MAC port block */
-    e_MODULE_ID_FM_PORT_1GTx1,      /**< FM Tx 1G MAC port block */
-    e_MODULE_ID_FM_PORT_1GTx2,      /**< FM Tx 1G MAC port block */
-    e_MODULE_ID_FM_PORT_1GTx3,      /**< FM Tx 1G MAC port block */
-    e_MODULE_ID_FM_PORT_1GTx4,      /**< FM Tx 1G MAC port block */
-    e_MODULE_ID_FM_PORT_1GTx5,      /**< FM Tx 1G MAC port block */
-    e_MODULE_ID_FM_PORT_1GTx6,      /**< FM Tx 1G MAC port block */
-    e_MODULE_ID_FM_PORT_10GTx1,     /**< FM Tx 10G MAC port block */
-    e_MODULE_ID_FM_PORT_10GTx2,     /**< FM Tx 10G MAC port block */
-    e_MODULE_ID_FM_PLCR,            /**< FM Policer */
-    e_MODULE_ID_FM_KG,              /**< FM Keygen */
-    e_MODULE_ID_FM_DMA,             /**< FM DMA */
-    e_MODULE_ID_FM_FPM,             /**< FM FPM */
-    e_MODULE_ID_FM_IRAM,            /**< FM Instruction-RAM */
-    e_MODULE_ID_FM_1GMDIO,          /**< FM 1G MDIO MAC */
-    e_MODULE_ID_FM_10GMDIO,         /**< FM 10G MDIO */
-    e_MODULE_ID_FM_PRS_IRAM,        /**< FM SW-parser Instruction-RAM */
-    e_MODULE_ID_FM_1GMAC1,          /**< FM 1G MAC #1 */
-    e_MODULE_ID_FM_1GMAC2,          /**< FM 1G MAC #2 */
-    e_MODULE_ID_FM_1GMAC3,          /**< FM 1G MAC #3 */
-    e_MODULE_ID_FM_1GMAC4,          /**< FM 1G MAC #4 */
-    e_MODULE_ID_FM_1GMAC5,          /**< FM 1G MAC #5 */
-    e_MODULE_ID_FM_1GMAC6,          /**< FM 1G MAC #6 */
-    e_MODULE_ID_FM_10GMAC1,         /**< FM 10G MAC */
-    e_MODULE_ID_FM_10GMAC2,         /**< FM 10G MAC */
-
-    e_MODULE_ID_SEC_GEN,            /**< SEC 4.0 General registers      */
-    e_MODULE_ID_SEC_QI,             /**< SEC 4.0 QI registers           */
-    e_MODULE_ID_SEC_JQ0,            /**< SEC 4.0 JQ-0 registers         */
-    e_MODULE_ID_SEC_JQ1,            /**< SEC 4.0 JQ-1 registers         */
-    e_MODULE_ID_SEC_JQ2,            /**< SEC 4.0 JQ-2 registers         */
-    e_MODULE_ID_SEC_JQ3,            /**< SEC 4.0 JQ-3 registers         */
-    e_MODULE_ID_SEC_RTIC,           /**< SEC 4.0 RTIC registers         */
-    e_MODULE_ID_SEC_DECO0_CCB0,     /**< SEC 4.0 DECO-0/CCB-0 registers */
-    e_MODULE_ID_SEC_DECO1_CCB1,     /**< SEC 4.0 DECO-1/CCB-1 registers */
-    e_MODULE_ID_SEC_DECO2_CCB2,     /**< SEC 4.0 DECO-2/CCB-2 registers */
-    e_MODULE_ID_SEC_DECO3_CCB3,     /**< SEC 4.0 DECO-3/CCB-3 registers */
-    e_MODULE_ID_SEC_DECO4_CCB4,     /**< SEC 4.0 DECO-4/CCB-4 registers */
-
-    e_MODULE_ID_PIC,                /**< PIC */
-    e_MODULE_ID_GPIO,               /**< GPIO */
-    e_MODULE_ID_SERDES,             /**< SERDES */
-    e_MODULE_ID_CPC_1,              /**< CoreNet-Platform-Cache 1 */
-    e_MODULE_ID_CPC_2,              /**< CoreNet-Platform-Cache 2 */
-
-    e_MODULE_ID_SRIO_PORTS,         /**< RapidIO controller */
-
-    e_MODULE_ID_DUMMY_LAST
-} e_ModuleId;
-
-#define NUM_OF_MODULES  e_MODULE_ID_DUMMY_LAST
-
-#if 0 /* using unified values */
-/*****************************************************************************
- INTEGRATION-SPECIFIC MODULE CODES
-******************************************************************************/
-#define MODULE_UNKNOWN          0x00000000
-#define MODULE_MEM              0x00010000
-#define MODULE_MM               0x00020000
-#define MODULE_CORE             0x00030000
-#define MODULE_T4240            0x00040000
-#define MODULE_T4240_PLATFORM   0x00050000
-#define MODULE_PM               0x00060000
-#define MODULE_MMU              0x00070000
-#define MODULE_PIC              0x00080000
-#define MODULE_CPC              0x00090000
-#define MODULE_DUART            0x000a0000
-#define MODULE_SERDES           0x000b0000
-#define MODULE_PIO              0x000c0000
-#define MODULE_QM               0x000d0000
-#define MODULE_BM               0x000e0000
-#define MODULE_SEC              0x000f0000
-#define MODULE_LAW              0x00100000
-#define MODULE_LBC              0x00110000
-#define MODULE_PAMU             0x00120000
-#define MODULE_FM               0x00130000
-#define MODULE_FM_MURAM         0x00140000
-#define MODULE_FM_PCD           0x00150000
-#define MODULE_FM_RTC           0x00160000
-#define MODULE_FM_MAC           0x00170000
-#define MODULE_FM_PORT          0x00180000
-#define MODULE_FM_SP            0x00190000
-#define MODULE_DPA_PORT         0x001a0000
-#define MODULE_MII              0x001b0000
-#define MODULE_I2C              0x001c0000
-#define MODULE_DMA              0x001d0000
-#define MODULE_DDR              0x001e0000
-#define MODULE_ESPI             0x001f0000
-#define MODULE_DPAA_IPSEC       0x00200000
-#endif /* using unified values */
-
-/*****************************************************************************
- PAMU INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define PAMU_NUM_OF_PARTITIONS  4
-
-/*****************************************************************************
- LAW INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define LAW_NUM_OF_WINDOWS      32
-#define LAW_MIN_WINDOW_SIZE     0x0000000000001000LL    /**< 4 Kbytes */
-#define LAW_MAX_WINDOW_SIZE     0x0000010000000000LL    /**< 1 Tbytes for 40-bit address space */
-
-/*****************************************************************************
- LBC INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-/**************************************************************************//**
- @Group         lbc_exception_grp LBC Exception Unit
-
- @Description   LBC Exception unit API functions, definitions and enums
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Anchor        lbc_exbm
-
- @Collection    LBC Errors Bit Mask
-
-                These errors are reported through the exceptions callback..
-                The values can be or'ed in any combination in the errors mask
-                parameter of the errors report structure.
-
-                These errors can also be passed as a bit-mask to
-                LBC_EnableErrorChecking() or LBC_DisableErrorChecking(),
-                for enabling or disabling error checking.
- @{
-*//***************************************************************************/
-#define LBC_ERR_BUS_MONITOR     0x80000000  /**< Bus monitor error */
-#define LBC_ERR_PARITY_ECC      0x20000000  /**< Parity error for GPCM/UPM */
-#define LBC_ERR_WRITE_PROTECT   0x04000000  /**< Write protection error */
-#define LBC_ERR_CHIP_SELECT     0x00080000  /**< Unrecognized chip select */
-
-#define LBC_ERR_ALL             (LBC_ERR_BUS_MONITOR | LBC_ERR_PARITY_ECC | \
-                                 LBC_ERR_WRITE_PROTECT | LBC_ERR_CHIP_SELECT)
-                                            /**< All possible errors */
-/* @} */
-/** @} */ /* end of lbc_exception_grp group */
-
-#define LBC_INCORRECT_ERROR_REPORT_ERRATA
-
-#define LBC_NUM_OF_BANKS            8
-#define LBC_MAX_CS_SIZE             0x0000000100000000LL  /* Up to 4G memory block size */
-#define LBC_PARITY_SUPPORT
-#define LBC_ADDRESS_HOLD_TIME_CTRL
-#define LBC_HIGH_CLK_DIVIDERS
-#define LBC_FCM_AVAILABLE
-
-/*****************************************************************************
- GPIO INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define GPIO_PORT_OFFSET_0x1000
-
-#define GPIO_NUM_OF_PORTS   3   /**< Number of ports in GPIO module;
-                                     Each port contains up to 32 I/O pins. */
-
-#define GPIO_VALID_PIN_MASKS   \
-    { /* Port A */ 0xFFFFFFFF, \
-	  /* Port B */ 0xFFFFFFFF, \
-      /* Port C */ 0xFFFFFFFF }
-
-#define GPIO_VALID_INTR_MASKS  \
-    { /* Port A */ 0xFFFFFFFF, \
-      /* Port B */ 0xFFFFFFFF, \
-      /* Port C */ 0xFFFFFFFF }
-
-
-
-#endif /* __PART_INTEGRATION_B4_T4_H */
--- fmlib-fslsdk-v1.7/src/include/fmd/integrations/part_P1023.h.orig	2022-05-26 11:28:30.982977418 -0700
+++ fmlib-fslsdk-v1.7/src/include/fmd/integrations/part_P1023.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,48 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          part_P1023.h
-
- @Description   Definitions for the part (integration) module.
-*//***************************************************************************/
-
-#ifndef __PART_P1023_H
-#define __PART_P1023_H
-
-#ifndef	P1023
-#error	"This file should not be #included for any platform other than P1023!"
-#endif
-
-/* P1023 chip-specific defs. should go here. */
-
-#endif /* __PART_P1023_H */
--- fmlib-fslsdk-v1.7/src/INSTALL.orig	2022-05-26 11:28:30.946978891 -0700
+++ fmlib-fslsdk-v1.7/src/INSTALL	1969-12-31 16:00:00.000000000 -0800
@@ -1,53 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-Manual installation for FM library:
-   - set PATH and CROSS_COMPILE to point to the cross-toolchain on the host
-   - set KERNEL_SRC to point to the root dir. for the kernel/headers (i.e.
-   the Linux kernel that's contained in the SDK, not other kernel!)
-   - make all: will create the binaries for all platforms
-   - make archive: will create the tarball containing all fmlib binaries
-   - make install-xxx will:
-	* copy binary (libfm-xxx.a) to the ${PREFIX}/lib folder on the target
-	root filesystem pointed to by the ${DESTDIR} variable
-	* copy headers (include/fmd/ dir.) to the ${PREFIX}/include/fmd/ dir.
-	on target rfs
-	* copy doc. files to the ${PREFIX}/share/doc/fm-lib-<version> dir
-	of the same rfs
-
-'make targets' will display a short usage summary, along with the available
-"xxx" variants.
-
-An application that uses this package will have to link with the static
-library and include the necessary headers.
-
-
--- fmlib-fslsdk-v1.7/src/src/fm_lib.c.orig	2022-05-26 11:28:30.986977256 -0700
+++ fmlib-fslsdk-v1.7/src/src/fm_lib.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,2328 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-/**************************************************************************//**
- @File          fm_lib.c
-
- @Description   Frame Manager Linux User-Space library implementation.
-*//***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <unistd.h>
-#include <termios.h>
-#include <sys/ioctl.h>
-#include <stdbool.h>
-
-#include "fm_ext.h"
-#include "fm_pcd_ext.h"
-#include "fm_port_ext.h"
-#include "fm_mac_ext.h"
-#if (DPAA_VERSION >= 11)
-#include "fm_vsp_ext.h"
-#endif
-
-#include "fm_ioctls.h"
-#include "fm_pcd_ioctls.h"
-#include "fm_port_ioctls.h"
-
-#define __ERR_MODULE__      MODULE_FM
-
-#define DEV_TO_ID(p) \
-    do { \
-        t_Device *p_Dev = (t_Device *)p; \
-        p = UINT_TO_PTR(p_Dev->id); \
-    } while(0)
-
-/* #define FM_LIB_DBG */
-
-#if defined(FM_LIB_DBG)
-    #define _fml_dbg(format, arg...) \
-        printf("fmlib [%s:%u] - " format, \
-            __func__, __LINE__, ##arg)
-#else
-    #define _fml_dbg(arg...)
-#endif
-
-/* Major and minor are in sync with FMD, respin is for fmlib identification */
-#define FM_LIB_VERSION_MAJOR    21
-#define FM_LIB_VERSION_MINOR     1 
-#define FM_LIB_VERSION_RESPIN    0
-
-#if (FMD_API_VERSION_MAJOR != FM_LIB_VERSION_MAJOR) || \
-    (FMD_API_VERSION_MINOR != FM_LIB_VERSION_MINOR)
-#warning FMD and FMLIB version mismatch
-#endif
-
-t_Error FM_GetApiVersion(t_Handle h_Fm, ioc_fm_api_version_t *p_version);
-
-/*******************************************************************************
-*  FM FUNCTIONS                                                                *
-*******************************************************************************/
-
-t_Handle FM_Open(uint8_t id)
-{
-    t_Device    *p_Dev;
-    int         fd;
-    char        devName[20];
-    static bool called = FALSE;
-    ioc_fm_api_version_t ver;
-
-    _fml_dbg("Calling...\n");
-
-    p_Dev = (t_Device*) malloc(sizeof(t_Device));
-    if (!p_Dev)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM device!!"));
-        return NULL;
-    }
-
-    memset(devName, 0, 20);
-    sprintf(devName, "%s%s%d", "/dev/", DEV_FM_NAME, id);
-    fd = open(devName, O_RDWR);
-    if (fd < 0)
-    {
-       free(p_Dev);
-       REPORT_ERROR(MAJOR, E_NO_DEVICE, ("Could not open FM. Ret code=%d, errno=%d. Aborting!!!",
-               fd,
-               errno));
-       return NULL;
-    }
-
-    p_Dev->id = id;
-    p_Dev->fd = fd;
-    if (!called)
-    {
-        called = TRUE;
-
-        FM_GetApiVersion((t_Handle)p_Dev, &ver);
-
-        if (FMD_API_VERSION_MAJOR != ver.version.major ||
-            FMD_API_VERSION_MINOR != ver.version.minor ||
-            FMD_API_VERSION_RESPIN != ver.version.respin)
-        {
-            printf("Warning:\nCompiled against FMD API version %u.%u.%u\n",
-                FMD_API_VERSION_MAJOR, FMD_API_VERSION_MINOR, FMD_API_VERSION_RESPIN);
-            printf("Running with FMD API version %u.%u.%u\n",
-                ver.version.major, ver.version.minor, ver.version.respin);
-            printf("Current fmlib version %u.%u.%u\n",
-                FM_LIB_VERSION_MAJOR, FM_LIB_VERSION_MINOR, FM_LIB_VERSION_RESPIN);
-        }
-    }
-    _fml_dbg("Called.\n");
-
-    return (t_Handle)p_Dev;
-}
-
-void FM_Close(t_Handle h_Fm)
-{
-    t_Device    *p_Dev = (t_Device*) h_Fm;
-
-    SANITY_CHECK_RETURN(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    close(p_Dev->fd);
-    free(p_Dev);
-
-    _fml_dbg("Called.\n");
-}
-
-t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBandwidth)
-{
-    t_Device    *p_Dev = (t_Device*) h_Fm;
-
-    ASSERT_COND(sizeof(t_FmPortsBandwidthParams) == sizeof(ioc_fm_port_bandwidth_params));
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_IOC_SET_PORTS_BANDWIDTH, p_PortsBandwidth))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error  FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
-{
-    t_Device    *p_Dev = (t_Device*) h_Fm;
-
-    ASSERT_COND(sizeof(t_FmRevisionInfo) == sizeof(ioc_fm_revision_info_t));
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_IOC_GET_REVISION, p_FmRevisionInfo))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
-{
-    t_Device                    *p_Dev = (t_Device*) h_Fm;
-    ioc_fm_counters_params_t    params;
-
-    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, 0);
-
-    _fml_dbg("Calling...\n");
-
-    params.cnt = (ioc_fm_counters) counter;
-
-    if (ioctl(p_Dev->fd, FM_IOC_GET_COUNTER, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return params.val;
-}
-
-t_Error  FM_SetCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
-{
-    t_Device                    *p_Dev = (t_Device*) h_Fm;
-    ioc_fm_counters_params_t    params;
-
-    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, 0);
-
-    _fml_dbg("Calling...\n");
-
-    params.cnt = (ioc_fm_counters) counter;
-    params.val = val;
-
-    if (ioctl(p_Dev->fd, FM_IOC_SET_COUNTER, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_ForceIntr(t_Handle h_Fm, e_FmExceptions exception)
-{
-    t_Device    *p_Dev = (t_Device*) h_Fm;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_IOC_FORCE_INTR, (ioc_fm_exceptions) exception))
-        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error  FM_GetApiVersion(t_Handle h_Fm, ioc_fm_api_version_t *p_version)
-{
-    t_Device                    *p_Dev = (t_Device*) h_Fm;
-
-    _fml_dbg("Calling...\n");
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    if (ioctl(p_Dev->fd, FM_IOC_GET_API_VERSION, p_version))
-        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-/********************************************************************************************/
-/*  FM_PCD FUNCTIONS                                                                        */
-/********************************************************************************************/
-
-t_Handle FM_PCD_Open(t_FmPcdParams *p_FmPcdParams)
-{
-    t_Device    *p_Dev;
-    int         fd;
-    char        devName[20];
-
-    _fml_dbg("Calling...\n");
-
-    p_Dev = (t_Device*) malloc(sizeof(t_Device));
-    if (!p_Dev)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD device!!"));
-        return NULL;
-    }
-
-    memset(devName, 0, 20);
-    sprintf(devName, "%s%s%u-pcd", "/dev/", DEV_FM_NAME, (uint32_t)((t_Device*) p_FmPcdParams->h_Fm)->id);
-    fd = open(devName, O_RDWR);
-    if (fd < 0)
-    {
-       free(p_Dev);
-       REPORT_ERROR(MAJOR, E_NO_DEVICE, ("Could not open FM. Ret code=%d, errno=%d. Aborting!!!",
-               fd,
-               errno));
-       return NULL;
-    }
-
-    p_Dev->id = ((t_Device*) p_FmPcdParams->h_Fm)->id;
-    p_Dev->fd = fd;
-    p_Dev->owners = 0;
-
-    _fml_dbg("Called.\n");
-
-    return (t_Handle) p_Dev;
-}
-
-void FM_PCD_Close(t_Handle h_FmPcd)
-{
-    t_Device    *p_Dev = (t_Device*) h_FmPcd;
-
-    SANITY_CHECK_RETURN(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    close(p_Dev->fd);
-
-    if (p_Dev->owners) {
-        XX_Print("Trying to delete a pcd handler that has modules bound to (owners:%u)!!!",
-            p_Dev->owners);
-        return;
-    }
-
-    free(p_Dev);
-
-    _fml_dbg("Called.\n");
-}
-
-t_Error FM_PCD_Enable(t_Handle h_FmPcd)
-{
-    t_Device    *p_Dev = (t_Device*) h_FmPcd;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PCD_IOC_ENABLE))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PCD_Disable(t_Handle h_FmPcd)
-{
-    t_Device    *p_Dev = (t_Device*) h_FmPcd;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PCD_IOC_DISABLE))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
-{
-    t_Device    *p_Dev = (t_Device*) h_FmPcd;
-
-    ASSERT_COND(sizeof(t_FmPcdPrsSwParams) == sizeof(ioc_fm_pcd_prs_sw_params_t));
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PCD_IOC_PRS_LOAD_SW, p_SwPrs))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
-{
-    t_Device    *p_Dev = (t_Device*) h_FmPcd;
-    ioc_fm_pcd_kg_dflt_value_params_t params;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    params.value = value;
-    params.valueId = valueId;
-
-    if (ioctl(p_Dev->fd, FM_PCD_IOC_KG_SET_DFLT_VALUE, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset)
-{
-    t_Device    *p_Dev = (t_Device*) h_FmPcd;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING, &payloadOffset))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable)
-{
-    t_Device                        *p_Dev = (t_Device*) h_FmPcd;
-    ioc_fm_pcd_exception_params_t   params;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    params.exception = exception;
-    params.enable = enable;
-
-    if (ioctl(p_Dev->fd, FM_PCD_IOC_SET_EXCEPTION, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
-{
-    t_Device                        *p_Dev = (t_Device*) h_FmPcd;
-    ioc_fm_pcd_counters_params_t    params;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    params.cnt = (ioc_fm_pcd_counters) counter;
-
-    if (ioctl(p_Dev->fd, FM_PCD_IOC_GET_COUNTER, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return params.val;
-}
-
-#if 0
-t_Error FM_PCD_SetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value)
-{
-    t_Device                        *p_Dev = (t_Device*) h_FmPcd;
-    ioc_fm_pcd_counters_params_t    params;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    params.cnt = (ioc_fm_pcd_counters) counter;
-    params.val = value;
-
-    if (ioctl(p_Dev->fd, FM_PCD_IOC_SET_COUNTER, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    return E_OK;
-}
-#endif
-
-t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
-{
-    t_Device    *p_Dev = (t_Device*) h_FmPcd;
-    int         intCast = (int) exception;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PCD_IOC_FORCE_INTR, &intCast))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams *p_NetEnvParams)
-{
-    t_Device *p_PcdDev = (t_Device*) h_FmPcd;
-    t_Device *p_Dev = NULL;
-    ioc_fm_pcd_net_env_params_t params;
-
-    SANITY_CHECK_RETURN_VALUE(p_PcdDev, E_INVALID_HANDLE, NULL);
-
-    _fml_dbg("Calling...\n");
-
-    memcpy(&params, p_NetEnvParams, sizeof(t_FmPcdNetEnvParams));
-    params.id = NULL;
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET, &params))
-    {
-        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-        return NULL;
-    }
-
-    p_Dev = (t_Device *)malloc(sizeof(t_Device));
-    if (!p_Dev)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD NetEnv Chrs device!!"));
-        return NULL;
-    }
-    memset(p_Dev, 0, sizeof(t_Device));
-    p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
-    p_PcdDev->owners++;
-    p_Dev->id = PTR_TO_UINT(params.id);
-
-    _fml_dbg("Called.\n");
-
-    return (t_Handle) p_Dev;;
-}
-
-t_Error FM_PCD_NetEnvCharacteristicsDelete(t_Handle h_NetEnv)
-{
-    t_Device *p_Dev = (t_Device*) h_NetEnv;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_obj_t id;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
-    id.obj = UINT_TO_PTR(p_Dev->id);
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE, &id)){
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-    }
-
-    p_PcdDev->owners--;
-    free(p_Dev);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Handle FM_PCD_KgSchemeSet (t_Handle h_FmPcd, t_FmPcdKgSchemeParams *p_Scheme)
-{
-    t_Device *p_PcdDev = (t_Device*) h_FmPcd;
-    t_Device *p_Dev = NULL;
-    ioc_fm_pcd_kg_scheme_params_t params;
-
-    SANITY_CHECK_RETURN_VALUE(p_PcdDev, E_INVALID_HANDLE, NULL);
-
-    _fml_dbg("Calling...\n");
-
-    memcpy(&params, p_Scheme, sizeof(t_FmPcdKgSchemeParams));
-    params.id = NULL;
-
-    if (params.modify)
-    {
-        if (params.scm_id.scheme_id)
-            DEV_TO_ID(params.scm_id.scheme_id);
-        else
-        {
-            REPORT_ERROR(MINOR, E_INVALID_HANDLE, NO_MSG);
-            return NULL;
-        }
-    }
-
-    /* correct h_NetEnv param from scheme */
-    if (params.net_env_params.net_env_id)
-        DEV_TO_ID(params.net_env_params.net_env_id);
-
-    /* correct next engine params handlers: cc*/
-    if (params.next_engine == e_IOC_FM_PCD_CC &&
-        params.kg_next_engine_params.cc.tree_id)
-            DEV_TO_ID(params.kg_next_engine_params.cc.tree_id);
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_KG_SCHEME_SET, &params))
-    {
-        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-        return NULL;
-    }
-
-    p_Dev = (t_Device *)malloc(sizeof(t_Device));
-    if (!p_Dev)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD KG Scheme device!!"));
-        return NULL;
-    }
-
-    memset(p_Dev, 0, sizeof(t_Device));
-    p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
-    p_PcdDev->owners++;
-    p_Dev->id = PTR_TO_UINT(params.id);
-
-    _fml_dbg("Called.\n");
-
-    return (t_Handle) p_Dev;
-}
-
-t_Error FM_PCD_KgSchemeDelete(t_Handle h_Scheme)
-{
-    t_Device *p_Dev = (t_Device*) h_Scheme;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_obj_t id;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev =  (t_Device *)p_Dev->h_UserPriv;
-    id.obj = UINT_TO_PTR(p_Dev->id);
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_KG_SCHEME_DELETE, &id)){
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-    }
-
-    p_PcdDev->owners--;
-    free(p_Dev);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdTreeParam)
-{
-    t_Device *p_PcdDev = (t_Device*) h_FmPcd;
-    t_Device *p_Dev = NULL;
-    ioc_fm_pcd_cc_tree_params_t params;
-    uint32_t i, j;
-
-    SANITY_CHECK_RETURN_VALUE(p_PcdDev, E_INVALID_HANDLE, NULL);
-
-    _fml_dbg("Calling...\n");
-
-    memcpy(&params, p_PcdTreeParam, sizeof(t_FmPcdCcTreeParams));
-    params.id = NULL;
-
-    /* correct net_env_id */
-    if (params.net_env_id)
-        DEV_TO_ID(params.net_env_id);
-
-    /* correct next engine kg and cc handlers: cc_node_id, p_direct_scheme */
-    for (i = 0; i < IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS; i++)
-        for (j = 0; j < IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP; j++){
-            if (params.fm_pcd_cc_group_params[i].next_engine_per_entries_in_grp[j].next_engine == e_IOC_FM_PCD_CC &&
-                params.fm_pcd_cc_group_params[i].next_engine_per_entries_in_grp[j].params.cc_params.cc_node_id)
-                    DEV_TO_ID(params.fm_pcd_cc_group_params[i].next_engine_per_entries_in_grp[j].params.cc_params.cc_node_id);
-
-            if (params.fm_pcd_cc_group_params[i].next_engine_per_entries_in_grp[j].next_engine == e_IOC_FM_PCD_KG &&
-                params.fm_pcd_cc_group_params[i].next_engine_per_entries_in_grp[j].params.kg_params.p_direct_scheme)
-                    DEV_TO_ID(params.fm_pcd_cc_group_params[i].next_engine_per_entries_in_grp[j].params.kg_params.p_direct_scheme);
-
-            /*TODO params.fm_pcd_cc_group_params[i].next_engine_per_entries_in_grp[j].manip_id*/
-        }
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_CC_ROOT_BUILD, &params))
-    {
-        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-        return NULL;
-    }
-
-    p_Dev = (t_Device *)malloc(sizeof(t_Device));
-    if (!p_Dev)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD CC Root device!!"));
-        return NULL;
-    }
-
-    memset(p_Dev, 0, sizeof(t_Device));
-    p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
-    p_PcdDev->owners++;
-    p_Dev->id = PTR_TO_UINT(params.id);
-
-    _fml_dbg("Called.\n");
-
-    return (t_Handle) p_Dev;
-}
-
-t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree)
-{
-    t_Device *p_Dev = (t_Device*) h_CcTree;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_obj_t id;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
-    id.obj = UINT_TO_PTR(p_Dev->id);
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_CC_ROOT_DELETE, &id)){
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-    }
-
-    p_PcdDev->owners--;
-    free(p_Dev);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
-{
-    t_Device *p_PcdDev = (t_Device*) h_FmPcd;
-    t_Device *p_Dev = NULL;
-    ioc_fm_pcd_cc_node_params_t params;
-    uint32_t i;
-
-    SANITY_CHECK_RETURN_VALUE(p_PcdDev, E_INVALID_HANDLE, NULL);
-
-    _fml_dbg("Calling...\n");
-
-    memcpy(&params, p_CcNodeParam, sizeof(t_FmPcdCcNodeParams));
-    params.id = NULL;
-
-    /*correct*/
-    for(i = 0; i < params.keys_params.num_of_keys;i++){
-        if (params.keys_params.key_params[i].cc_next_engine_params.next_engine == e_IOC_FM_PCD_CC &&
-            params.keys_params.key_params[i].cc_next_engine_params.params.cc_params.cc_node_id)
-                DEV_TO_ID(params.keys_params.key_params[i].cc_next_engine_params.params.cc_params.cc_node_id);
-
-        if (params.keys_params.key_params[i].cc_next_engine_params.next_engine == e_IOC_FM_PCD_KG &&
-            params.keys_params.key_params[i].cc_next_engine_params.params.kg_params.p_direct_scheme)
-                DEV_TO_ID(params.keys_params.key_params[i].cc_next_engine_params.params.kg_params.p_direct_scheme);
-
-        if (params.keys_params.key_params[i].cc_next_engine_params.manip_id)
-            DEV_TO_ID(params.keys_params.key_params[i].cc_next_engine_params.manip_id);
-
-#if (DPAA_VERSION >= 11)
-        if (params.keys_params.key_params[i].cc_next_engine_params.next_engine == e_IOC_FM_PCD_FR &&
-            params.keys_params.key_params[i].cc_next_engine_params.params.fr_params.frm_replic_id)
-            DEV_TO_ID(params.keys_params.key_params[i].cc_next_engine_params.params.fr_params.frm_replic_id);
-#endif /* DPAA_VERSION >= 11 */
-    }
-
-    if (params.keys_params.cc_next_engine_params_for_miss.next_engine == e_IOC_FM_PCD_CC &&
-        params.keys_params.cc_next_engine_params_for_miss.params.cc_params.cc_node_id)
-            DEV_TO_ID(params.keys_params.cc_next_engine_params_for_miss.params.cc_params.cc_node_id);
-
-    if (params.keys_params.cc_next_engine_params_for_miss.next_engine == e_IOC_FM_PCD_KG &&
-        params.keys_params.cc_next_engine_params_for_miss.params.kg_params.p_direct_scheme)
-            DEV_TO_ID(params.keys_params.cc_next_engine_params_for_miss.params.kg_params.p_direct_scheme);
-
-    if (params.keys_params.cc_next_engine_params_for_miss.manip_id)
-        DEV_TO_ID(params.keys_params.cc_next_engine_params_for_miss.manip_id);
-
-#if (DPAA_VERSION >= 11)
-    if (params.keys_params.cc_next_engine_params_for_miss.next_engine == e_IOC_FM_PCD_FR &&
-        params.keys_params.cc_next_engine_params_for_miss.params.fr_params.frm_replic_id)
-            DEV_TO_ID(params.keys_params.cc_next_engine_params_for_miss.params.fr_params.frm_replic_id);
-
-#endif /* DPAA_VERSION >= 11 */
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MATCH_TABLE_SET, &params))
-    {
-        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-        return NULL;
-    }
-
-    p_Dev = (t_Device *)malloc(sizeof(t_Device));
-    if (!p_Dev)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Match Table device!!"));
-        return NULL;
-    }
-    memset(p_Dev, 0, sizeof(t_Device));
-    p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
-    p_PcdDev->owners++;
-    p_Dev->id = PTR_TO_UINT(params.id);
-
-    _fml_dbg("Called.\n");
-
-    return (t_Handle) p_Dev;
-}
-
-t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode)
-{
-    t_Device *p_Dev = (t_Device *)h_CcNode;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_obj_t id;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
-    id.obj = UINT_TO_PTR(p_Dev->id);
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MATCH_TABLE_DELETE, &id)){
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-    }
-
-    p_PcdDev->owners--;
-    free(p_Dev);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
-                                      uint8_t                   grpId,
-                                      uint8_t                   index,
-                                      t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
-{
-    t_Device *p_Dev = (t_Device*) h_CcTree;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_pcd_cc_tree_modify_next_engine_params_t  params;
-
-    ASSERT_COND(sizeof(t_FmPcdCcNextEngineParams) == sizeof(ioc_fm_pcd_cc_next_engine_params_t));
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
-
-    params.id = UINT_TO_PTR(p_Dev->id);
-    params.grp_indx = grpId;
-    params.indx = index;
-    memcpy(&params.cc_next_engine_params, p_FmPcdCcNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
-    if (p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) {
-        t_Device *p_NextDev = (t_Device*) p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode;
-
-        params.cc_next_engine_params.params.cc_params.cc_node_id = UINT_TO_PTR(p_NextDev->id);
-    }
-
-	if (p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_KG) {
-        t_Device *p_NextDev = (t_Device*) p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme;
-
-        params.cc_next_engine_params.params.kg_params.p_direct_scheme = UINT_TO_PTR(p_NextDev->id);
-    }
-
-	if (p_FmPcdCcNextEngineParams->h_Manip) {
-		t_Device *p_NextDev = (t_Device*) p_FmPcdCcNextEngineParams->h_Manip;
-		params.cc_next_engine_params.manip_id = UINT_TO_PTR(p_NextDev->id);
-	}
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle                  h_CcNode,
-                                          uint16_t                  keyIndex,
-                                          t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
-{
-    t_Device *p_Dev = (t_Device*) h_CcNode;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_pcd_cc_node_modify_next_engine_params_t  params;
-
-    ASSERT_COND(sizeof(t_FmPcdCcNextEngineParams) == sizeof(ioc_fm_pcd_cc_next_engine_params_t));
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
-    params.id = UINT_TO_PTR(p_Dev->id);
-    params.key_indx = keyIndex;
-    memcpy(&params.cc_next_engine_params, p_FmPcdCcNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
-    if (p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) {
-        t_Device *p_NextDev = (t_Device*) p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode;
-
-        params.cc_next_engine_params.params.cc_params.cc_node_id = UINT_TO_PTR(p_NextDev->id);
-    }
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle                  h_CcNode,
-                                              t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
-{
-    t_Device *p_Dev = (t_Device*) h_CcNode;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_pcd_cc_node_modify_next_engine_params_t  params;
-
-    ASSERT_COND(sizeof(t_FmPcdCcNextEngineParams) == sizeof(ioc_fm_pcd_cc_next_engine_params_t));
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
-
-    params.id = UINT_TO_PTR(p_Dev->id);
-    memcpy(&params.cc_next_engine_params, p_FmPcdCcNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
-    if (p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) {
-        t_Device *p_NextDev = (t_Device*) p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode;
-
-        params.cc_next_engine_params.params.cc_params.cc_node_id = UINT_TO_PTR(p_NextDev->id);
-    }
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
-                                uint16_t            keyIndex,
-                                uint8_t             keySize,
-                                t_FmPcdCcKeyParams  *p_KeyParams)
-{
-    t_Device *p_Dev = (t_Device*) h_CcNode;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t params;
-
-    ASSERT_COND(sizeof(t_FmPcdCcKeyParams) == sizeof(ioc_fm_pcd_cc_key_params_t));
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
-
-    params.id = UINT_TO_PTR(p_Dev->id);
-    params.key_indx = keyIndex;
-    params.key_size = keySize;
-    memcpy(&params.key_params, p_KeyParams, sizeof(t_FmPcdCcKeyParams));
-    if (p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_CC) {
-        t_Device *p_NextDev = (t_Device*) p_KeyParams->ccNextEngineParams.params.ccParams.h_CcNode;
-
-        params.key_params.cc_next_engine_params.params.cc_params.cc_node_id = UINT_TO_PTR(p_NextDev->id);
-    }
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MATCH_TABLE_ADD_KEY, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex)
-{
-    t_Device *p_Dev = (t_Device*) h_CcNode;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_pcd_cc_node_remove_key_params_t  params;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
-
-    params.id = UINT_TO_PTR(p_Dev->id);
-    params.key_indx = keyIndex;
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle            h_CcNode,
-                                                uint16_t            keyIndex,
-                                                uint8_t             keySize,
-                                                t_FmPcdCcKeyParams  *p_KeyParams)
-{
-    t_Device *p_Dev = (t_Device*) h_CcNode;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  params;
-
-    ASSERT_COND(sizeof(t_FmPcdCcKeyParams) == sizeof(ioc_fm_pcd_cc_key_params_t));
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
-
-    params.id = UINT_TO_PTR(p_Dev->id);
-    params.key_indx = keyIndex;
-    params.key_size = keySize;
-    memcpy(&params.key_params, p_KeyParams, sizeof(t_FmPcdCcKeyParams));
-    if (p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_CC) {
-        t_Device *p_NextDev = (t_Device*) p_KeyParams->ccNextEngineParams.params.ccParams.h_CcNode;
-
-        params.key_params.cc_next_engine_params.params.cc_params.cc_node_id = UINT_TO_PTR(p_NextDev->id);
-    }
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
-{
-    t_Device *p_PcdDev = (t_Device*) h_FmPcd;
-    t_Device *p_Dev = (t_Device*) h_FmPcd;
-    ioc_fm_pcd_hash_table_params_t params;
-
-    SANITY_CHECK_RETURN_VALUE(p_PcdDev, E_INVALID_HANDLE, NULL);
-
-    _fml_dbg("Calling...\n");
-
-    memcpy(&params, p_Param, sizeof(t_FmPcdHashTableParams));
-    params.id = NULL;
-
-    if (params.cc_next_engine_params_for_miss.next_engine == e_IOC_FM_PCD_CC &&
-        params.cc_next_engine_params_for_miss.params.cc_params.cc_node_id)
-            DEV_TO_ID(params.cc_next_engine_params_for_miss.params.cc_params.cc_node_id);
-
-    if (params.cc_next_engine_params_for_miss.next_engine == e_IOC_FM_PCD_KG &&
-        params.cc_next_engine_params_for_miss.params.kg_params.p_direct_scheme)
-            DEV_TO_ID(params.cc_next_engine_params_for_miss.params.kg_params.p_direct_scheme);
-
-    if (params.cc_next_engine_params_for_miss.manip_id)
-        DEV_TO_ID(params.cc_next_engine_params_for_miss.manip_id);
-
-#if (DPAA_VERSION >= 11)
-    if (params.cc_next_engine_params_for_miss.next_engine == e_IOC_FM_PCD_FR &&
-        params.cc_next_engine_params_for_miss.params.fr_params.frm_replic_id)
-            DEV_TO_ID(params.cc_next_engine_params_for_miss.params.fr_params.frm_replic_id);
-
-#endif /* DPAA_VERSION >= 11 */
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_HASH_TABLE_SET, &params))
-    {
-        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-        return NULL;
-    }
-
-    p_Dev = (t_Device *)malloc(sizeof(t_Device));
-    if (!p_Dev)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Hash Table device!!"));
-        return NULL;
-    }
-    memset(p_Dev, 0, sizeof(t_Device));
-    p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
-    p_PcdDev->owners++;
-    p_Dev->id = PTR_TO_UINT(params.id);
-
-    _fml_dbg("Called.\n");
-
-    return (t_Handle) p_Dev;
-}
-
-t_Error FM_PCD_HashTableDelete(t_Handle h_HashTbl)
-{
-    t_Device *p_Dev = (t_Device*) h_HashTbl;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_obj_t id;
-
-    SANITY_CHECK_EXIT(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
-    id.obj = UINT_TO_PTR(p_Dev->id);
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_HASH_TABLE_DELETE, &id))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    p_PcdDev->owners--;
-    free(p_Dev);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PCD_HashTableAddKey(t_Handle            h_HashTbl,
-                               uint8_t             keySize,
-                               t_FmPcdCcKeyParams  *p_KeyParams)
-{
-    t_Device *p_Dev = (t_Device*) h_HashTbl;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_pcd_hash_table_add_key_params_t params;
-
-    SANITY_CHECK_EXIT(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
-
-    params.p_hash_tbl = UINT_TO_PTR(p_Dev->id);
-    params.key_size = keySize;
-    memcpy(&params.key_params, p_KeyParams, sizeof(t_FmPcdCcKeyParams));
-    if (p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_CC) {
-        t_Device *p_NextDev = (t_Device*) p_KeyParams->ccNextEngineParams.params.ccParams.h_CcNode;
-
-        params.key_params.cc_next_engine_params.params.cc_params.cc_node_id = UINT_TO_PTR(p_NextDev->id);
-    }
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_HASH_TABLE_ADD_KEY, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PCD_HashTableRemoveKey(t_Handle h_HashTbl,
-                                  uint8_t  keySize,
-                                  uint8_t  *p_Key)
-{
-    t_Device *p_Dev = (t_Device*) h_HashTbl;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_pcd_hash_table_remove_key_params_t params;
-
-    SANITY_CHECK_EXIT(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
-
-    params.p_hash_tbl = UINT_TO_PTR(p_Dev->id);
-    params.key_size = keySize;
-    params.p_key = p_Key;
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_HASH_TABLE_REMOVE_KEY, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
-                                   uint16_t keyIndex,
-                                   uint8_t  keySize,
-                                   uint8_t  *p_Key,
-                                   uint8_t  *p_Mask)
-{
-    t_Device *p_Dev = (t_Device*) h_CcNode;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_pcd_cc_node_modify_key_params_t params;
-    uint8_t                                key[IOC_FM_PCD_MAX_SIZE_OF_KEY];
-    uint8_t                                mask[IOC_FM_PCD_MAX_SIZE_OF_KEY];
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
-
-    params.id = UINT_TO_PTR(p_Dev->id);
-    params.key_indx = keyIndex;
-    params.key_size = keySize;
-    memcpy(key, p_Key, keySize);
-    if (p_Mask)
-        memcpy(mask, p_Mask, keySize);
-    params.p_key = key;
-    params.p_mask = mask;
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-
-t_Handle FM_PCD_PlcrProfileSet(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Profile)
-{
-    t_Device *p_PcdDev = (t_Device*) h_FmPcd;
-    t_Device *p_Dev = NULL;
-    ioc_fm_pcd_plcr_profile_params_t params;
-
-    SANITY_CHECK_RETURN_VALUE(p_PcdDev, E_INVALID_HANDLE, NULL);
-
-    _fml_dbg("Calling...\n");
-
-    memcpy(&params, p_Profile, sizeof(t_FmPcdPlcrProfileParams));
-    params.id = NULL;
-
-    if (!params.modify &&
-        (params.profile_select.new_params.profile_type
-                != (ioc_fm_pcd_profile_type_selection)e_FM_PCD_PLCR_SHARED))
-    {
-        params.profile_select.new_params.p_fm_port =
-            (ioc_fm_pcd_port_params_t*) (((t_Device*) p_Profile->id.newParams.h_FmPort)->h_UserPriv);
-    }
-
-    /* correct paramsOnGreen.h_Profile, paramsOnYellow.h_Profile, paramsOnRed.h_Profile
-     * if next engine is policer... that means that FM_PCD_PlcrProfileSet was called */
-    if (params.next_engine_on_green == e_IOC_FM_PCD_PLCR && params.params_on_green.p_profile)
-        DEV_TO_ID(params.params_on_green.p_profile);
-    if (params.next_engine_on_yellow == e_IOC_FM_PCD_PLCR && params.params_on_yellow.p_profile)
-        DEV_TO_ID(params.params_on_yellow.p_profile);
-    if (params.next_engine_on_red == e_IOC_FM_PCD_PLCR && params.params_on_red.p_profile)
-        DEV_TO_ID(params.params_on_red.p_profile);
-
-    /* correct paramsOnGreen.h_Profile, paramsOnYellow.h_Profile, paramsOnRed.h_Profile
-     * if next engine is kg... that means that FM_PCD_KgSchemeSet was called */
-    if (params.next_engine_on_green == e_IOC_FM_PCD_KG && params.params_on_green.p_direct_scheme)
-        DEV_TO_ID(params.params_on_green.p_direct_scheme);
-    if (params.next_engine_on_yellow == e_IOC_FM_PCD_KG && params.params_on_yellow.p_direct_scheme)
-        DEV_TO_ID(params.params_on_yellow.p_direct_scheme);
-    if (params.next_engine_on_red == e_IOC_FM_PCD_KG && params.params_on_red.p_direct_scheme)
-        DEV_TO_ID(params.params_on_red.p_direct_scheme);
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_PLCR_PROFILE_SET, &params))
-    {
-        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-        return NULL;
-    }
-
-    p_Dev = (t_Device *)malloc(sizeof(t_Device));
-    if (!p_Dev)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Policer Profile device!!"));
-        return NULL;
-    }
-
-    memset(p_Dev, 0, sizeof(t_Device));
-    p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
-    p_PcdDev->owners++;
-    p_Dev->id = PTR_TO_UINT(params.id);
-
-    _fml_dbg("Called.\n");
-
-    return (t_Handle) p_Dev;
-}
-
-t_Error FM_PCD_PlcrProfileDelete(t_Handle h_Profile)
-{
-    t_Device *p_Dev = (t_Device*) h_Profile;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_obj_t id;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
-    id.obj = UINT_TO_PTR(p_Dev->id);
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_PLCR_PROFILE_DELETE, &id)){
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-    }
-
-    p_PcdDev->owners--;
-    free(p_Dev);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_FmPcdManipParams)
-{
-    t_Device *p_PcdDev = (t_Device*) h_FmPcd;
-    t_Device *p_Dev = NULL;
-    ioc_fm_pcd_manip_params_t params;
-
-    SANITY_CHECK_RETURN_VALUE(p_PcdDev, E_INVALID_HANDLE, NULL);
-
-    _fml_dbg("Calling...\n");
-
-    memset(&params, 0, sizeof(ioc_fm_pcd_manip_params_t));
-    memcpy(&params, p_FmPcdManipParams, sizeof(t_FmPcdManipParams));
-    if (p_FmPcdManipParams->h_NextManip)
-    {
-        p_Dev = (t_Device*)p_FmPcdManipParams->h_NextManip;
-        params.p_next_manip = UINT_TO_PTR(p_Dev->id);
-    }
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MANIP_NODE_SET, &params)){
-        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-        return NULL;
-    }
-
-    p_Dev = (t_Device *)malloc(sizeof(t_Device));
-    if (!p_Dev)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Manip Node device!!"));
-        return NULL;
-    }
-
-    memset(p_Dev, 0, sizeof(t_Device));
-    p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
-    p_PcdDev->owners++;
-    p_Dev->id = PTR_TO_UINT(params.id);
-
-    _fml_dbg("Called.\n");
-
-    return (t_Handle) p_Dev;
-}
-
-t_Error FM_PCD_ManipNodeReplace(t_Handle h_ManipNode, t_FmPcdManipParams *p_FmPcdManipParams)
-{
-    t_Device *p_Dev = (t_Device*)h_ManipNode;
-    t_Device *p_PcdDev;
-    ioc_fm_pcd_manip_params_t params;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
-
-    memset(&params, 0, sizeof(ioc_fm_pcd_manip_params_t));
-    memcpy(&params, p_FmPcdManipParams, sizeof(t_FmPcdManipParams));
-    params.id = UINT_TO_PTR(p_Dev->id);
-    /* REMINDER:
-       Also take care of params.p_next_manip here, although it's currently
-       ignored by the LLD! */
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MANIP_NODE_SET, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error  FM_PCD_ManipNodeDelete(t_Handle h_HdrManipNode)
-{
-    t_Device *p_Dev = (t_Device*) h_HdrManipNode;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_obj_t id;
-
-    SANITY_CHECK_EXIT(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
-    id.obj = UINT_TO_PTR(p_Dev->id);
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MANIP_NODE_DELETE, &id))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    p_PcdDev->owners--;
-    free(p_Dev);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-#ifdef FM_CAPWAP_SUPPORT
-#error CAPWAP feature not supported
-#endif
-
-typedef struct {
-    e_FmPortType            portType;           /**< Port type */
-    uint8_t                 portId;             /**< Port Id - relative to type */
-} t_FmPort;
-
-/********************************************************************************************/
-/*  FM_PORT FUNCTIONS                                                                       */
-/********************************************************************************************/
-
-t_Handle FM_PORT_Open(t_FmPortParams *p_FmPortParams)
-{
-    t_Device    *p_Dev;
-    int         fd;
-    char        devName[30];
-    t_FmPort    *p_FmPort;
-
-    _fml_dbg("Calling...\n");
-
-    p_Dev = (t_Device*) malloc(sizeof(t_Device));
-    if (!p_Dev)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Port device!!"));
-        return NULL;
-    }
-    memset(p_Dev, 0, sizeof(t_Device));
-
-    p_FmPort = (t_FmPort*) malloc(sizeof(t_FmPort));
-    if (!p_FmPort)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Port device!!"));
-        free(p_Dev);
-        return NULL;
-    }
-    memset(p_FmPort, 0, sizeof(t_FmPort));
-
-    memset(devName, 0, sizeof(devName));
-    switch (p_FmPortParams->portType)
-    {
-        case e_FM_PORT_TYPE_OH_OFFLINE_PARSING:
-            sprintf(devName, "%s%s%u-port-oh%d", "/dev/", DEV_FM_NAME,
-                    (uint32_t)((t_Device*)p_FmPortParams->h_Fm)->id, p_FmPortParams->portId);
-            break;
-        case e_FM_PORT_TYPE_RX:
-            sprintf(devName, "%s%s%u-port-rx%d", "/dev/", DEV_FM_NAME,
-                    (uint32_t)((t_Device*)p_FmPortParams->h_Fm)->id, p_FmPortParams->portId);
-            break;
-        case e_FM_PORT_TYPE_RX_10G:
-            sprintf(devName, "%s%s%u-port-rx%d", "/dev/", DEV_FM_NAME,
-                    (uint32_t)((t_Device*)p_FmPortParams->h_Fm)->id, FM_MAX_NUM_OF_1G_RX_PORTS+p_FmPortParams->portId);
-            break;
-        case e_FM_PORT_TYPE_TX:
-            sprintf(devName, "%s%s%u-port-tx%d", "/dev/", DEV_FM_NAME,
-                    (uint32_t)((t_Device*)p_FmPortParams->h_Fm)->id, p_FmPortParams->portId);
-            break;
-        case e_FM_PORT_TYPE_TX_10G:
-            sprintf(devName, "%s%s%u-port-tx%d", "/dev/", DEV_FM_NAME,
-                    (uint32_t)((t_Device*)p_FmPortParams->h_Fm)->id, FM_MAX_NUM_OF_1G_TX_PORTS+p_FmPortParams->portId);
-            break;
-        default:
-            free(p_FmPort);
-            free(p_Dev);
-            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("port id!"));
-            return NULL;
-    }
-
-    fd = open(devName, O_RDWR);
-    if (fd < 0)
-    {
-       free(p_FmPort);
-       free(p_Dev);
-       REPORT_ERROR(MAJOR, E_NO_DEVICE, ("Could not open FM-port %s. Ret code=%d, errno=%d. Aborting!!!",
-               devName,
-               fd,
-               errno));
-       return NULL;
-    }
-
-    p_FmPort->portType = p_FmPortParams->portType;
-    p_FmPort->portId = p_FmPortParams->portId;
-    p_Dev->id = p_FmPortParams->portId;
-    p_Dev->fd = fd;
-    p_Dev->h_UserPriv = (t_Handle) p_FmPort;
-
-    _fml_dbg("Called.\n");
-
-    return (t_Handle) p_Dev;
-}
-
-void FM_PORT_Close(t_Handle h_FmPort)
-{
-    t_Device    *p_Dev = (t_Device *)h_FmPort;
-
-    SANITY_CHECK_RETURN(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    close(p_Dev->fd);
-    if (p_Dev->h_UserPriv)
-        free(p_Dev->h_UserPriv);
-    free(p_Dev);
-
-    _fml_dbg("Called.\n");
-}
-
-t_Error FM_PORT_Disable(t_Handle h_FmPort)
-{
-    t_Device    *p_Dev = (t_Device *)h_FmPort;
-
-    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_DISABLE))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PORT_Enable(t_Handle h_FmPort)
-{
-    t_Device    *p_Dev = (t_Device *)h_FmPort;
-
-    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_ENABLE))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort)
-{
-    t_Device    *p_Dev = (t_Device*) h_FmPort;
-
-    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_REMOVE_RATE_LIMIT))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
-{
-    t_Device    *p_Dev = (t_Device*) h_FmPort;
-
-    ASSERT_COND(sizeof(t_FmPortRateLimit) == sizeof(ioc_fm_port_rate_limit_t));
-    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_SET_RATE_LIMIT, p_RateLimit))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
-{
-    t_Device    *p_Dev = (t_Device*) h_FmPort;
-    int         intCast = (int) errs;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_SET_ERRORS_ROUTE, &intCast))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-uint32_t FM_PORT_AllocPCDFqids (t_Handle h_FmPort, uint32_t numFqids, uint8_t alignment)
-{
-    t_Device    *p_Dev = (t_Device*) h_FmPort;
-    ioc_fm_port_pcd_fqids_params_t  param;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    param.num_fqids  = numFqids;
-    param.alignment = alignment;
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_ALLOC_PCD_FQIDS, &param))
-    {
-        REPORT_ERROR(MINOR, E_INVALID_OPERATION,
-                ("Failed to allocate %d queue IDs!", numFqids));
-        return 0;
-    }
-
-    _fml_dbg("Called.\n");
-
-    return param.base_fqid;
-}
-
-t_Error FM_PORT_FreePCDFqids (t_Handle h_FmPort, uint32_t base_fqid)
-{
-    t_Device    *p_Dev = (t_Device*) h_FmPort;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_FREE_PCD_FQIDS, &base_fqid))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION,
-                ("Invalid base FQID %d or other error!", base_fqid));
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_FmPortPcd)
-{
-    t_Device *p_Dev = (t_Device*) h_FmPort;
-    ioc_fm_port_pcd_params_t params;
-
-    ASSERT_COND(sizeof(t_FmPortPcdParams) == sizeof(ioc_fm_port_pcd_params_t));
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    memcpy(&params, p_FmPortPcd, sizeof(t_FmPortPcdParams));
-
-    /* correct h_NetEnv param from t_FmPortPcdParams */
-    DEV_TO_ID(params.net_env_id);
-
-    /* correct pcd structures according to what support was set */
-    if (params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC ||
-        params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR ||
-        params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC) {
-
-        if (params.p_cc_params && params.p_cc_params->cc_tree_id)
-            DEV_TO_ID(params.p_cc_params->cc_tree_id);
-        else
-            XX_Print("fmlib warning (%s): Coarse Clasification not set ! \n", __func__);
-    }
-
-    if (params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG ||
-        params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC ||
-        params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR ||
-        params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR ){
-
-        if (params.p_kg_params){
-            uint32_t i;
-            for (i = 0; i < params.p_kg_params->num_of_schemes; i++)
-                if (params.p_kg_params->scheme_ids[i])
-                    DEV_TO_ID(params.p_kg_params->scheme_ids[i]);
-                else
-                    XX_Print("fmlib warning (%s): Scheme:%u not set!\n", __func__, i);
-
-            if (params.p_kg_params && params.p_kg_params->direct_scheme)
-                DEV_TO_ID(params.p_kg_params->direct_scheme_id);
-        } else
-            XX_Print("fmlib warning (%s): KeyGen not set ! \n", __func__);
-    }
-
-    if (params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY ||
-        params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR ||
-        params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR ||
-        params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR){
-
-        if (params.p_plcr_params)
-        {
-            if (params.p_plcr_params->plcr_profile_id)
-                DEV_TO_ID(params.p_plcr_params->plcr_profile_id);
-            else
-                XX_Print("fmlib warning (%s): Policer not set !\n", __func__);
-        }
-    }
-
-    if (params.p_ip_reassembly_manip)
-        DEV_TO_ID(params.p_ip_reassembly_manip);
-
-#if (DPAA_VERSION >= 11)
-    if (params.p_capwap_reassembly_manip)
-	DEV_TO_ID(params.p_capwap_reassembly_manip);
-#endif
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_SET_PCD, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
-{
-    t_Device *p_Dev = (t_Device*) h_FmPort;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_DELETE_PCD))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
-{
-    t_Device    *p_Dev = (t_Device*) h_FmPort;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_DETACH_PCD))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
-{
-    t_Device *p_Dev = (t_Device*) h_FmPort;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_ATTACH_PCD))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
-{
-    t_Device *p_Dev = (t_Device*) h_FmPort;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES, &numOfProfiles))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort)
-{
-    t_Device *p_Dev = (t_Device*) h_FmPort;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_PCD_PLCR_FREE_PROFILES))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PORT_PcdKgModifyInitialScheme(t_Handle h_FmPort, t_FmPcdKgSchemeSelect *p_FmPcdKgScheme)
-{
-    t_Device *p_Dev = (t_Device*) h_FmPort;
-
-    ASSERT_COND(sizeof(t_FmPcdKgSchemeSelect) == sizeof(ioc_fm_pcd_kg_scheme_select_t));
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME, p_FmPcdKgScheme))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_Profile)
-{
-    t_Device *p_Dev = (t_Device*) h_FmPort;
-    ioc_fm_obj_t id;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    id.obj = h_Profile;
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE, &id))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
-{
-    t_Device *p_Dev = (t_Device*) h_FmPort;
-    ioc_fm_obj_t id;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    id.obj = h_CcTree;
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_PCD_CC_MODIFY_TREE, &id))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
-{
-    t_Device *p_Dev = (t_Device*) h_FmPort;
-    ioc_fm_pcd_port_schemes_params_t params;
-    uint32_t i;
-
-    ASSERT_COND(sizeof(t_FmPcdPortSchemesParams) == sizeof(ioc_fm_pcd_port_schemes_params_t));
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    memcpy(&params, p_PortScheme, sizeof(t_FmPcdPortSchemesParams));
-    for (i = 0; i < params.num_of_schemes; i++)
-	    DEV_TO_ID(params.scheme_ids[i]);
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_PCD_KG_BIND_SCHEMES, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
-{
-    t_Device *p_Dev = (t_Device*) h_FmPort;
-    ioc_fm_pcd_port_schemes_params_t params;
-    uint32_t i;
-
-    ASSERT_COND(sizeof(t_FmPcdPortSchemesParams) == sizeof(ioc_fm_pcd_port_schemes_params_t));
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    memcpy(&params, p_PortScheme, sizeof(t_FmPcdPortSchemesParams));
-    for (i = 0; i < params.num_of_schemes; i++)
-	    DEV_TO_ID(params.scheme_ids[i]);
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PORT_PcdModifyPrsStart (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart)
-{
-    t_Device *p_Dev = (t_Device*) h_FmPort;
-
-    ASSERT_COND(sizeof(t_FmPcdPrsStart) == sizeof(ioc_fm_pcd_prs_start_t));
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET, p_FmPcdPrsStart))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPort)
-{
-    t_Device    *p_Dev = (t_Device *)h_FmPort;
-
-    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PCD_IOC_SET_ADVANCED_OFFLOAD_SUPPORT))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-#if (DPAA_VERSION >= 11)
-t_Handle FM_PCD_FrmReplicSetGroup(t_Handle h_FmPcd, t_FmPcdFrmReplicGroupParams *p_FrmReplicGroupParam)
-{
-    t_Device *p_PcdDev = (t_Device*) h_FmPcd;
-    t_Device *p_Dev = NULL;
-    ioc_fm_pcd_frm_replic_group_params_t params;
-
-    SANITY_CHECK_RETURN_VALUE(p_PcdDev, E_INVALID_HANDLE, NULL);
-
-    _fml_dbg("Calling...\n");
-
-    memcpy(&params, p_FrmReplicGroupParam, sizeof(t_FmPcdFrmReplicGroupParams));
-    params.id = NULL;
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_FRM_REPLIC_GROUP_SET, &params))
-    {
-        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-        return NULL;
-    }
-
-    p_Dev = (t_Device *)malloc(sizeof(t_Device));
-    if (!p_Dev)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD NetEnv Chrs device!!"));
-        return NULL;
-    }
-    memset(p_Dev, 0, sizeof(t_Device));
-    p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
-    p_PcdDev->owners++;
-    p_Dev->id = PTR_TO_UINT(params.id);
-
-    _fml_dbg("Called.\n");
-
-    return (t_Handle) p_Dev;
-}
-
-t_Error FM_PCD_FrmReplicDeleteGroup(t_Handle h_FrmReplicGroup)
-{
-    t_Device *p_Dev = (t_Device*) h_FrmReplicGroup;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_obj_t id;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
-    id.obj = UINT_TO_PTR(p_Dev->id);
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_FRM_REPLIC_GROUP_DELETE, &id))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    p_PcdDev->owners--;
-    free(p_Dev);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PCD_FrmReplicAddMember(t_Handle h_ReplicGroup,
-                                  uint16_t memberIndex,
-                                  t_FmPcdCcNextEngineParams *p_MemberParams)
-{
-    t_Device *p_Dev = (t_Device*) h_ReplicGroup;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_pcd_frm_replic_member_params_t params;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
-
-    params.member.h_replic_group = UINT_TO_PTR(p_Dev->id);
-    params.member.member_index = memberIndex;
-    memcpy(&params.next_engine_params, p_MemberParams, sizeof(*p_MemberParams));
-    if (p_MemberParams->nextEngine == e_FM_PCD_CC) {
-        t_Device *p_NextDev = (t_Device*) p_MemberParams->params.ccParams.h_CcNode;
-
-        params.next_engine_params.params.cc_params.cc_node_id = UINT_TO_PTR(p_NextDev->id);
-    }
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_FRM_REPLIC_MEMBER_ADD, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PCD_FrmReplicRemoveMember(t_Handle   h_ReplicGroup,
-                                     uint16_t   memberIndex)
-{
-    t_Device *p_Dev = (t_Device*) h_ReplicGroup;
-    t_Device *p_PcdDev = NULL;
-    ioc_fm_pcd_frm_replic_member_t param;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
-
-    param.h_replic_group = UINT_TO_PTR(p_Dev->id);
-    param.member_index = memberIndex;
-
-    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_FRM_REPLIC_MEMBER_REMOVE, &param))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    p_PcdDev->owners--;
-    free(p_Dev);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-#endif
-
-t_Error FM_MAC_AddHashMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
-{
-    t_Device    *p_Dev = (t_Device *)h_FmMac;
-
-    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_ADD_RX_HASH_MAC_ADDR, p_EnetAddr))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_MAC_RemoveHashMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
-{
-    t_Device    *p_Dev = (t_Device *)h_FmMac;
-
-    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_REMOVE_RX_HASH_MAC_ADDR, p_EnetAddr))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_MAC_SetTxPauseFrames(t_Handle h_FmMac, uint8_t  priority, uint16_t pauseTime, uint16_t threshTime)
-{
-    t_Device    *p_Dev = (t_Device *)h_FmMac;
-    ioc_fm_port_tx_pause_frames_params_t param;
-
-    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
-
-    _fml_dbg("Calling...\n");
-
-    param.priority = priority;
-    param.pause_time = pauseTime;
-    param.thresh_time = threshTime;
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_SET_TX_PAUSE_FRAMES, &param))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_MAC_GetStatistics (t_Handle h_FmMac, t_FmMacStatistics *p_Statistics)
-{
-    t_Device    *p_Dev = (t_Device *)h_FmMac;
-    ioc_fm_port_mac_statistics_t *param;
-
-    param = (ioc_fm_port_mac_statistics_t *)p_Statistics;
-
-    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
-    SANITY_CHECK_RETURN_VALUE(param, E_INVALID_HANDLE, E_OK);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_GET_MAC_STATISTICS, param))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle h_FmPort, t_FmBufferPrefixContent *p_Params)
-{
-    t_Device    *p_Dev = (t_Device*) h_FmPort;
-
-    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_CONFIG_BUFFER_PREFIX_CONTENT, p_Params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-#if (DPAA_VERSION >= 11)
-
-t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_Params)
-{
-    t_Device    *p_Dev = (t_Device*) h_FmPort;
-
-    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_PORT_IOC_VSP_ALLOC, p_Params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Handle FM_VSP_Config(t_FmVspParams *p_FmVspParams)
-{
-    t_Device *p_Dev = NULL;
-    t_Device *p_VspDev = NULL;
-    ioc_fm_vsp_params_t param;
-
-    SANITY_CHECK_RETURN_VALUE((void *)p_FmVspParams, E_INVALID_HANDLE, NULL);
-    p_Dev = p_FmVspParams->h_Fm;
-    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, NULL);
-
-    _fml_dbg("Calling...\n");
-
-    memcpy(&param, p_FmVspParams, sizeof(param));
-    param.p_fm = UINT_TO_PTR(p_Dev->id);
-    param.id = NULL;
-
-    if (ioctl(p_Dev->fd, FM_IOC_VSP_CONFIG, &param))
-    {
-        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-        return NULL;
-    }
-
-    p_VspDev = (t_Device *)malloc(sizeof(t_Device));
-    if (!p_VspDev)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM VSP Params!"));
-        return NULL;
-    }
-    memset(p_VspDev, 0, sizeof(t_Device));
-    p_VspDev->h_UserPriv = (t_Handle)p_Dev;
-    p_Dev->owners++;
-    p_VspDev->id = PTR_TO_UINT(param.id);
-
-    _fml_dbg("Called.\n");
-
-    return (t_Handle)p_VspDev;
-}
-
-t_Error FM_VSP_Init(t_Handle h_FmVsp)
-{
-    t_Device *p_Dev = NULL;
-    t_Device *p_VspDev = (t_Device *)h_FmVsp;
-    ioc_fm_obj_t id;
-
-    SANITY_CHECK_RETURN_ERROR(p_VspDev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_Dev = (t_Device*)p_VspDev->h_UserPriv;
-    id.obj = UINT_TO_PTR(p_VspDev->id);
-
-    if (ioctl(p_Dev->fd, FM_IOC_VSP_INIT, &id))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_VSP_Free(t_Handle h_FmVsp)
-{
-    t_Device *p_Dev = NULL;
-    t_Device *p_VspDev = (t_Device *)h_FmVsp;
-    ioc_fm_obj_t id;
-
-    SANITY_CHECK_RETURN_ERROR(p_VspDev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    p_Dev = (t_Device*)p_VspDev->h_UserPriv;
-    id.obj = UINT_TO_PTR(p_VspDev->id);
-
-    if (ioctl(p_Dev->fd, FM_IOC_VSP_FREE, &id))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    p_Dev->owners--;
-    free(p_VspDev);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_VSP_ConfigPoolDepletion(t_Handle h_FmVsp, t_FmBufPoolDepletion *p_BufPoolDepletion)
-{
-    t_Device *p_Dev = NULL;
-    t_Device *p_VspDev = (t_Device *)h_FmVsp;
-    ioc_fm_buf_pool_depletion_params_t params;
-
-    SANITY_CHECK_RETURN_VALUE(p_VspDev, E_INVALID_HANDLE, E_OK);
-
-    _fml_dbg("Calling...\n");
-
-    p_Dev = (t_Device*)p_VspDev->h_UserPriv;
-    params.p_fm_vsp = UINT_TO_PTR(p_VspDev->id);
-    memcpy(&params.fm_buf_pool_depletion, p_BufPoolDepletion, sizeof(*p_BufPoolDepletion));
-
-    if (ioctl(p_Dev->fd, FM_IOC_VSP_CONFIG_POOL_DEPLETION, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_VSP_ConfigBufferPrefixContent(t_Handle h_FmVsp, t_FmBufferPrefixContent *p_FmBufferPrefixContent)
-{
-    t_Device *p_Dev = NULL;
-    t_Device *p_VspDev = (t_Device *)h_FmVsp;
-    ioc_fm_buffer_prefix_content_params_t params;
-
-    SANITY_CHECK_RETURN_VALUE(p_VspDev, E_INVALID_HANDLE, E_OK);
-
-    _fml_dbg("Calling...\n");
-
-    p_Dev = (t_Device*)p_VspDev->h_UserPriv;
-    params.p_fm_vsp = UINT_TO_PTR(p_VspDev->id);
-    memcpy(&params.fm_buffer_prefix_content, p_FmBufferPrefixContent, sizeof(*p_FmBufferPrefixContent));
-
-    if (ioctl(p_Dev->fd, FM_IOC_VSP_CONFIG_BUFFER_PREFIX_CONTENT, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_VSP_ConfigNoScatherGather(t_Handle h_FmVsp, bool noScatherGather)
-{
-    t_Device *p_Dev = NULL;
-    t_Device *p_VspDev = (t_Device *)h_FmVsp;
-    ioc_fm_vsp_config_no_sg_params_t params;
-
-    SANITY_CHECK_RETURN_VALUE(p_VspDev, E_INVALID_HANDLE, E_OK);
-
-    _fml_dbg("Calling...\n");
-
-    p_Dev = (t_Device*)p_VspDev->h_UserPriv;
-    params.p_fm_vsp = UINT_TO_PTR(p_VspDev->id);
-    params.no_sg = noScatherGather;
-
-    if (ioctl(p_Dev->fd, FM_IOC_VSP_CONFIG_NO_SG, &params))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_FmPrsResult * FM_VSP_GetBufferPrsResult(t_Handle h_FmVsp, char *p_Data)
-{
-    t_Device *p_Dev = NULL;
-    t_Device *p_VspDev = (t_Device *)h_FmVsp;
-    ioc_fm_vsp_prs_result_params_t params;
-
-    SANITY_CHECK_RETURN_VALUE(p_VspDev, E_INVALID_HANDLE, NULL);
-
-    _fml_dbg("Calling...\n");
-
-    p_Dev = (t_Device*)p_VspDev->h_UserPriv;
-    params.p_fm_vsp = UINT_TO_PTR(p_VspDev->id);
-    params.p_data = p_Data;
-
-    if (ioctl(p_Dev->fd, FM_IOC_VSP_GET_BUFFER_PRS_RESULT, &params))
-    {
-        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-        return NULL;
-    }
-
-    _fml_dbg("Called.\n");
-
-    return params.p_data;
-}
-#endif
-
-t_Error FM_CtrlMonStart(t_Handle h_Fm)
-{
-    t_Device    *p_Dev = (t_Device*) h_Fm;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_IOC_CTRL_MON_START))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_CtrlMonStop(t_Handle h_Fm)
-{
-    t_Device    *p_Dev = (t_Device*) h_Fm;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    if (ioctl(p_Dev->fd, FM_IOC_CTRL_MON_STOP))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-t_Error FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p_Mon)
-{
-    t_Device    *p_Dev = (t_Device*) h_Fm;
-    ioc_fm_ctrl_mon_counters_params_t param;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
-
-    _fml_dbg("Calling...\n");
-
-    param.fm_ctrl_index = fmCtrlIndex;
-    param.p_mon = (fm_ctrl_mon_t *)p_Mon;
-
-    if (ioctl(p_Dev->fd, FM_IOC_CTRL_MON_GET_COUNTERS, &param))
-        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
-
-    _fml_dbg("Called.\n");
-
-    return E_OK;
-}
-
-#ifdef P1023
-void Platform_is_P1023()
-{
-}
-#elif defined B4860 || defined T4240
-void Platform_is_B4860_T4240()
-{
-}
-#else
-void Platform_is_P3_P4_P5()
-{
-}
-#endif
--- fmlib-fslsdk-v1.7/src/README.orig	2022-05-26 11:28:30.970977909 -0700
+++ fmlib-fslsdk-v1.7/src/README	1969-12-31 16:00:00.000000000 -0800
@@ -1,40 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor, Inc
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *      * Redistributions of source code must retain the above copyright
- *        notice, this list of conditions and the following disclaimer.
- *      * Redistributions in binary form must reproduce the above copyright
- *        notice, this list of conditions and the following disclaimer in the
- *        documentation and/or other materials provided with the distribution.
- *      * Neither the name of Freescale Semiconductor nor the
- *        names of its contributors may be used to endorse or promote products
- *        derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * This software is provided by Freescale Semiconductor "as is" and any
- * express or implied warranties, including, but not limited to, the implied
- * warranties of merchantability and fitness for a particular purpose are
- * disclaimed. In no event shall Freescale Semiconductor be liable for any
- * direct, indirect, incidental, special, exemplary, or consequential damages
- * (including, but not limited to, procurement of substitute goods or services;
- * loss of use, data, or profits; or business interruption) however caused and
- * on any theory of liability, whether in contract, strict liability, or tort
- * (including negligence or otherwise) arising in any way out of the use of
- * this software, even if advised of the possibility of such damage.
- */
-
-This package contains Frame Manager user space library.
-
-The Frame Manager library provides an API on top of the Frame Manager driver
-ioctl calls, that provides a user space application with a simple way 
-to configure driver parameters and PCD (parse - classify - distribute) rules.
-
-The licensing information for this package is included in the COPYING file.
-
--- fmlib-fslsdk-v1.7/include/fmd/xx_ext.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/xx_ext.h	2022-05-26 11:28:31.142970877 -0700
@@ -0,0 +1,816 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          xx_ext.h
+
+ @Description   Prototypes, externals and typedefs for system-supplied
+                (external) routines
+*//***************************************************************************/
+
+#ifndef __XX_EXT_H
+#define __XX_EXT_H
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "std_ext.h"
+#include "part_ext.h"
+
+#if defined(NCSW_LINUX) && defined(NCSW_MULTI_PARTITION)
+#error "NCSW_MULTI_PARTITION not supported in NCSW_LINUX!"
+#endif  /* NCSW_LINUX && NCSW_MULTI_PARTITION */
+
+
+/**************************************************************************//**
+ @Group         xx_id  XX Interface (System call hooks)
+
+ @Description   Prototypes, externals and typedefs for system-supplied
+                (external) routines
+
+ @{
+*//***************************************************************************/
+
+#ifdef DEBUG_XX_MALLOC
+void * XX_MallocDebug(uint32_t size, char *fname, int line);
+
+void * XX_MallocSmartDebug(uint32_t size,
+                           int      memPartitionId,
+                           uint32_t alignment,
+                           char     *fname,
+                           int      line);
+
+#define XX_Malloc(sz) \
+    XX_MallocDebug((sz), __FILE__, __LINE__)
+
+#define XX_MallocSmart(sz, memt, al) \
+    XX_MallocSmartDebug((sz), (memt), (al), __FILE__, __LINE__)
+
+#else /* not DEBUG_XX_MALLOC */
+/**************************************************************************//**
+ @Function      XX_Malloc
+
+ @Description   allocates contiguous block of memory.
+
+ @Param[in]     size - Number of bytes to allocate.
+
+ @Return        The address of the newly allocated block on success, NULL on failure.
+*//***************************************************************************/
+#define XX_Malloc(size) XX_MallocSmart(size, 0, 0)
+
+/**************************************************************************//**
+ @Function      XX_MallocSmart
+
+ @Description   Allocates contiguous block of memory in a specified
+                alignment and from the specified segment.
+
+ @Param[in]     size            - Number of bytes to allocate.
+ @Param[in]     memPartitionId  - Memory partition ID; The value zero must
+                                  be mapped to the default heap partition.
+ @Param[in]     alignment       - Required memory alignment (in bytes).
+
+ @Return        The address of the newly allocated block on success, NULL on failure.
+*//***************************************************************************/
+void * XX_MallocSmart(uint32_t size, int memPartitionId, uint32_t alignment);
+#endif /* not DEBUG_XX_MALLOC */
+
+/**************************************************************************//**
+ @Function      XX_FreeSmart
+
+ @Description   Frees the memory block pointed to by "p".
+                Only for memory allocated by XX_MallocSmart
+
+ @Param[in]     p_Memory - pointer to the memory block.
+
+ @Return        None.
+*//***************************************************************************/
+#define XX_FreeSmart(p)  free((uint8_t*)(p) - sizeof(void*))
+
+/**************************************************************************//**
+ @Function      XX_Free
+
+ @Description   frees the memory block pointed to by "p".
+
+ @Param[in]     p_Memory - pointer to the memory block.
+
+ @Return        None.
+*//***************************************************************************/
+#define XX_Free(p) XX_FreeSmart(p)
+
+/**************************************************************************//**
+ @Function      XX_Print
+
+ @Description   print a string.
+
+ @Param[in]     str - string to print.
+
+ @Return        None.
+*//***************************************************************************/
+#define   XX_Print		printf
+
+/**************************************************************************//**
+ @Function      XX_EnableIntr
+
+ @Description   Enable a specific interrupt.
+
+ @Param[in]     irq - Interrupt ID (system-specific number).
+
+ @Return        E_OK on success; error code otherwise..
+*//***************************************************************************/
+#define XX_EnableIntr(irq)  (E_OK)
+
+/**************************************************************************//**
+ @Function      XX_DisableIntr
+
+ @Description   Disable a specific interrupt.
+
+ @Param[in]     irq - Interrupt ID (system-specific number).
+
+ @Return        E_OK on success; error code otherwise..
+*//***************************************************************************/
+#define XX_DisableIntr(irq) (E_OK)
+
+/**************************************************************************//**
+ @Function      XX_DisableAllIntr
+
+ @Description   Disable all interrupts by masking them at the CPU.
+
+ @Return        A value that represents the interrupts state before the
+                operation, and should be passed to the matching
+                XX_RestoreAllIntr() call.
+*//***************************************************************************/
+#define XX_DisableAllIntr()     (0L) 
+
+/**************************************************************************//**
+ @Function      XX_RestoreAllIntr
+
+ @Description   Restore previous state of interrupts level at the CPU.
+
+ @Param[in]     flags - A value that represents the interrupts state to restore,
+                        as returned by the matching call for XX_DisableAllIntr().
+
+ @Return        None.
+*//***************************************************************************/
+#define XX_RestoreAllIntr(flags)    UNUSED(flags)
+
+/**************************************************************************//**
+ @Function      XX_Exit
+
+ @Description   Stop execution and report status (where it is applicable)
+
+ @Param[in]     status - exit status
+*//***************************************************************************/
+#define	XX_Exit(status)	exit(status)
+
+/*****************************************************************************/
+/*                        Tasklet Service Routines                           */
+/*****************************************************************************/
+typedef t_Handle t_TaskletHandle;
+
+/**************************************************************************//**
+ @Function      XX_InitTasklet
+
+ @Description   Create and initialize a tasklet object.
+
+ @Param[in]     routine - A routine to be ran as a tasklet.
+ @Param[in]     data    - An argument to pass to the tasklet.
+
+ @Return        Tasklet handle is returned on success. NULL is returned otherwise.
+*//***************************************************************************/
+t_TaskletHandle XX_InitTasklet (void (*routine)(void *), void *data);
+
+/**************************************************************************//**
+ @Function      XX_FreeTasklet
+
+ @Description   Free a tasklet object.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be free.
+
+ @Return        None.
+*//***************************************************************************/
+#define XX_FreeTasklet(h_Tasklet)   XX_Free(h_Tasklet)
+
+/**************************************************************************//**
+ @Function      XX_ScheduleTask
+
+ @Description   Schedule a tasklet object.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be scheduled.
+ @Param[in]     immediate - Indicate whether to schedule this tasklet on
+                            the immediate queue or on the delayed one.
+
+ @Return        0 - on success. Error code - otherwise.
+*//***************************************************************************/
+int XX_ScheduleTask(t_TaskletHandle h_Tasklet, int immediate);
+
+/**************************************************************************//**
+ @Function      XX_FlushScheduledTasks
+
+ @Description   Flush all tasks there are in the scheduled tasks queue.
+
+ @Return        None.
+*//***************************************************************************/
+#define XX_FlushScheduledTasks()
+
+/**************************************************************************//**
+ @Function      XX_TaskletIsQueued
+
+ @Description   Check if task is queued.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be scheduled.
+
+ @Return        1 - task is queued. 0 - otherwise.
+*//***************************************************************************/
+int XX_TaskletIsQueued(t_TaskletHandle h_Tasklet);
+
+/**************************************************************************//**
+ @Function      XX_SetTaskletData
+
+ @Description   Set data to a scheduled task. Used to change data of already
+                scheduled task.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be scheduled.
+ @Param[in]     data      - Data to be set.
+*//***************************************************************************/
+void XX_SetTaskletData(t_TaskletHandle h_Tasklet, t_Handle data);
+
+/**************************************************************************//**
+ @Function      XX_GetTaskletData
+
+ @Description   Get the data of scheduled task.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be scheduled.
+
+ @Return        handle to the data of the task.
+*//***************************************************************************/
+t_Handle XX_GetTaskletData(t_TaskletHandle h_Tasklet);
+
+/**************************************************************************//**
+ @Function      XX_BottomHalf
+
+ @Description   Bottom half implementation, invoked by the interrupt handler.
+
+                This routine handles all bottom-half tasklets with interrupts
+                enabled.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_BottomHalf(void);
+
+
+#ifdef NCSW_SMP
+#include <pthread.h>
+/*****************************************************************************/
+/*                        Spinlock Service Routines                          */
+/*****************************************************************************/
+
+/**************************************************************************//**
+ @Function      XX_InitSpinlock
+
+ @Description   Creates a spinlock.
+
+ @Return        Spinlock handle is returned on success; NULL otherwise.
+*//***************************************************************************/
+t_Handle XX_InitSpinlock(void);
+
+/**************************************************************************//**
+ @Function      XX_FreeSpinlock
+
+ @Description   Frees the memory allocated for the spinlock creation.
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeSpinlock(t_Handle h_Spinlock);
+
+/**************************************************************************//**
+ @Function      XX_LockSpinlock
+
+ @Description   Locks a spinlock.
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        None.
+*//***************************************************************************/
+#define XX_LockSpinlock(h_Spinlock)    pthread_mutex_lock(h_Spinlock)
+
+/**************************************************************************//**
+ @Function      XX_UnlockSpinlock
+
+ @Description   Unlocks a spinlock.
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        None.
+*//***************************************************************************/
+#define	XX_UnlockSpinlock(h_Spinlock)  pthread_mutex_unlock(h_Spinlock)
+
+#else   /* NCSW_SMP */
+#define XX_InitSpinlock()                   ((t_Handle) 1)
+#define XX_FreeSpinlock(h_Spinlock)         UNUSED(h_Spinlock)
+#define XX_LockSpinlock(h_Spinlock)         UNUSED(h_Spinlock)
+#define	XX_UnlockSpinlock(h_Spinlock)       UNUSED(h_Spinlock)
+#endif  /* NCSW_SMP */
+
+/**************************************************************************//**
+ @Function      XX_LockIntrSpinlock
+
+ @Description   Locks a spinlock (interrupt safe).
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        A value that represents the interrupts state before the
+                operation, and should be passed to the matching
+                XX_UnlockIntrSpinlock() call.
+*//***************************************************************************/
+#define XX_LockIntrSpinlock(h_Spinlock) \
+        ({ XX_LockSpinlock(h_Spinlock); 0L;})
+
+/**************************************************************************//**
+ @Function      XX_UnlockIntrSpinlock
+
+ @Description   Unlocks a spinlock (interrupt safe).
+
+ @Param[in]     h_Spinlock  - A handle to a spinlock.
+ @Param[in]     intrFlags   - A value that represents the interrupts state to
+                              restore, as returned by the matching call for
+                              XX_LockIntrSpinlock().
+
+ @Return        None.
+*//***************************************************************************/
+#define XX_UnlockIntrSpinlock(h_Spinlock, intrFlags) \
+        XX_UnlockSpinlock(h_Spinlock)
+
+
+/*****************************************************************************/
+/*                        Timers Service Routines                            */
+/*****************************************************************************/
+
+/**************************************************************************//**
+ @Function      XX_CurrentTime
+
+ @Description   Returns current system time.
+
+ @Return        Current system time (in milliseconds).
+*//***************************************************************************/
+uint32_t XX_CurrentTime(void);
+
+/**************************************************************************//**
+ @Function      XX_CreateTimer
+
+ @Description   Creates a timer.
+
+ @Return        Timer handle is returned on success; NULL otherwise.
+*//***************************************************************************/
+t_Handle XX_CreateTimer(void);
+
+/**************************************************************************//**
+ @Function      XX_FreeTimer
+
+ @Description   Frees the memory allocated for the timer creation.
+
+ @Param[in]     h_Timer - A handle to a timer.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeTimer(t_Handle h_Timer);
+
+/**************************************************************************//**
+ @Function      XX_StartTimer
+
+ @Description   Starts a timer.
+
+                The user can select to start the timer as periodic timer or as
+                one-shot timer. The user should provide a callback routine that
+                will be called when the timer expires.
+
+ @Param[in]     h_Timer         - A handle to a timer.
+ @Param[in]     msecs           - Timer expiration period (in milliseconds).
+ @Param[in]     periodic        - TRUE for a periodic timer;
+                                  FALSE for a one-shot timer..
+ @Param[in]     f_TimerExpired  - A callback routine to be called when the
+                                  timer expires.
+ @Param[in]     h_Arg           - The argument to pass in the timer-expired
+                                  callback routine.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_StartTimer(t_Handle h_Timer,
+                   uint32_t msecs,
+                   bool     periodic,
+                   void     (*f_TimerExpired)(t_Handle h_Arg),
+                   t_Handle h_Arg);
+
+/**************************************************************************//**
+ @Function      XX_StopTimer
+
+ @Description   Frees the memory allocated for the timer creation.
+
+ @Param[in]     h_Timer - A handle to a timer.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_StopTimer(t_Handle h_Timer);
+
+/**************************************************************************//**
+ @Function      XX_GetExpirationTime
+
+ @Description   Returns the time (in milliseconds) remaining until the
+                expiration of a timer.
+
+ @Param[in]     h_Timer - A handle to a timer.
+
+ @Return        The time left until the timer expires.
+*//***************************************************************************/
+uint32_t XX_GetExpirationTime(t_Handle h_Timer);
+
+/**************************************************************************//**
+ @Function      XX_ModTimer
+
+ @Description   Updates the expiration time of a timer.
+
+                This routine adds the given time to the current system time,
+                and sets this value as the new expiration time of the timer.
+
+ @Param[in]     h_Timer - A handle to a timer.
+ @Param[in]     msecs   - The new interval until timer expiration
+                          (in milliseconds).
+
+ @Return        None.
+*//***************************************************************************/
+void XX_ModTimer(t_Handle h_Timer, uint32_t msecs);
+
+/**************************************************************************//**
+ @Function      XX_TimerIsActive
+
+ @Description   Checks whether a timer is active (pending) or not.
+
+ @Param[in]     h_Timer - A handle to a timer.
+
+ @Return        0 - the timer is inactive; Non-zero value - the timer is active;
+*//***************************************************************************/
+int XX_TimerIsActive(t_Handle h_Timer);
+
+/**************************************************************************//**
+ @Function      XX_Sleep
+
+ @Description   Non-busy wait until the desired time (in milliseconds) has passed.
+
+ @Param[in]     msecs - The requested sleep time (in milliseconds).
+
+ @Return        Zero if the requested time has elapsed; Otherwise, the value
+                returned will be the unslept amount) in milliseconds.
+
+ @Cautions      This routine enables interrupts during its wait time.
+*//***************************************************************************/
+uint32_t XX_Sleep(uint32_t msecs);
+
+/**************************************************************************//**
+ @Function      XX_UDelay
+
+ @Description   Busy-wait until the desired time (in microseconds) has passed.
+
+ @Param[in]     usecs - The requested delay time (in microseconds).
+
+ @Return        None.
+
+ @Cautions      It is highly unrecommended to call this routine during interrupt
+                time, because the system time may not be updated properly during
+                the delay loop. The behavior of this routine during interrupt
+                time is unexpected.
+*//***************************************************************************/
+#define XX_UDELAY_MAX   50000000
+void XX_UDelay(uint32_t usecs);
+
+
+/*****************************************************************************/
+/*                         Other Service Routines                            */
+/*****************************************************************************/
+
+/**************************************************************************//**
+ @Function      XX_PhysToVirt
+
+ @Description   Translates a physical address to the matching virtual address.
+
+ @Param[in]     addr - The physical address to translate.
+
+ @Return        Virtual address.
+*//***************************************************************************/
+#define XX_PhysToVirt(p_addr)                   \
+        ({ REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, \
+                        ("No physical addrs. in userspace!")); NULL; })
+
+/**************************************************************************//**
+ @Function      XX_VirtToPhys
+
+ @Description   Translates a virtual address to the matching physical address.
+
+ @Param[in]     addr - The virtual address to translate.
+
+ @Return        Physical address.
+*//***************************************************************************/
+#define XX_VirtToPhys(v_addr)                   \
+        ({ REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, \
+                        ("No physical addrs. in userspace!")); (physAddress_t) 0; })
+
+
+#ifdef NCSW_MULTI_PARTITION
+/**************************************************************************//**
+ @Group         xx_ipc  XX Inter-Partition-Communication API
+
+ @Description   The following API is to be used when working with multiple
+                partitions configuration.
+
+ @{
+*//***************************************************************************/
+
+#define XX_IPC_MAX_ADDR_NAME_LENGTH 16         /**< Maximum length of an endpoint name string;
+                                                    The IPC service can use this constant to limit
+                                                    the storage space for IPC endpoint names. */
+
+
+/**************************************************************************//**
+ @Function      t_IpcMsgCompletion
+
+ @Description   Callback function used upon IPC non-blocking transaction completion
+                to return message buffer to the caller and to forward reply if available.
+
+                This callback function may be attached by the source endpoint to any outgoing
+                IPC message to indicate a non-blocking send (see also XX_IpcSendMessage() routine).
+                Upon completion of an IPC transaction (consisting of a message and an optional reply),
+                the IPC service invokes this callback routine to return the message buffer to the sender
+                and to provide the received reply, if requested.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_Module        - Abstract handle to the sending module -  the same handle as was passed
+                                  in the XX_IpcSendMessage() function; This handle is typically used to point
+                                  to the internal data structure of the source endpoint.
+ @Param[in]     p_Msg           - Pointer to original (sent) message buffer;
+                                  The source endpoint can free (or reuse) this buffer when message
+                                  completion callback is called.
+ @Param[in]     p_Reply         - Pointer to (received) reply buffer;
+                                  This pointer is the same as was provided by the source endpoint in
+                                  XX_IpcSendMessage().
+ @Param[in]     replyLength     - Length (in bytes) of actual data in the reply buffer.
+ @Param[in]     status          - Completion status - E_OK or failure indication, e.g. IPC transaction completion
+                                  timeout.
+
+ @Return        None
+ *//***************************************************************************/
+typedef void    (t_IpcMsgCompletion)(t_Handle   h_Module,
+                                     uint8_t    *p_Msg,
+                                     uint8_t    *p_Reply,
+                                     uint32_t   replyLength,
+                                     t_Error    status);
+
+/**************************************************************************//**
+ @Function      t_IpcMsgHandler
+
+ @Description   Callback function used as IPC message handler.
+
+                The IPC service invokes message handlers for each IPC message received.
+                The actual function pointer should be registered by each destination endpoint
+                via the XX_IpcRegisterMsgHandler() routine.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_Module        - Abstract handle to the message handling module -  the same handle as
+                                  was passed in the XX_IpcRegisterMsgHandler() function; this handle is
+                                  typically used to point to the internal data structure of the destination
+                                  endpoint.
+ @Param[in]     p_Msg           - Pointer to message buffer with data received from peer.
+ @Param[in]     msgLength       - Length (in bytes) of message data.
+ @Param[in]     p_Reply         - Pointer to reply buffer, to be filled by the message handler and then sent
+                                  by the IPC service;
+                                  The reply buffer is allocated by the IPC service with size equals to the
+                                  replyLength parameter provided in message handler registration (see
+                                  XX_IpcRegisterMsgHandler() function);
+                                  If replyLength was initially specified as zero during message handler registration,
+                                  the IPC service may set this pointer to NULL and assume that a reply is not needed;
+                                  The IPC service is also responsible for freeing the reply buffer after the
+                                  reply has been sent or dismissed.
+ @Param[in,out] p_ReplyLength   - Pointer to reply length, which has a dual role in this function:
+                                  [In] equals the replyLength parameter provided in message handler
+                                  registration (see XX_IpcRegisterMsgHandler() function), and
+                                  [Out] should be updated by message handler to the actual reply length; if
+                                  this value is set to zero, the IPC service must assume that a reply should
+                                  not be sent;
+                                  Note: If p_Reply is not NULL, p_ReplyLength must not be NULL as well.
+
+ @Return        E_OK on success; Error code otherwise.
+ *//***************************************************************************/
+typedef t_Error (t_IpcMsgHandler)(t_Handle  h_Module,
+                                  uint8_t   *p_Msg,
+                                  uint32_t  msgLength,
+                                  uint8_t   *p_Reply,
+                                  uint32_t  *p_ReplyLength);
+
+/**************************************************************************//**
+ @Function      XX_IpcRegisterMsgHandler
+
+ @Description   IPC mailbox registration.
+
+                This function is used for registering an IPC message handler in the IPC service.
+                This function is called by each destination endpoint to indicate that it is ready
+                to handle incoming messages. The IPC service invokes the message handler upon receiving
+                a message addressed to the specified destination endpoint.
+
+ @Param[in]     addr                - The address name string associated with the destination endpoint;
+                                      This address must be unique across the IPC service domain to ensure
+                                      correct message routing.
+ @Param[in]     f_MsgHandler        - Pointer to the message handler callback for processing incoming
+                                      message; invoked by the IPC service upon receiving a message
+                                      addressed to the destination endpoint specified by the addr
+                                      parameter.
+ @Param[in]     h_Module            - Abstract handle to the message handling module, passed unchanged
+                                      to f_MsgHandler callback function.
+ @Param[in]     replyLength         - The maximal data length (in bytes) of any reply that the specified message handler
+                                      may generate; the IPC service provides the message handler with buffer
+                                      for reply according to the length specified here (refer also to the description
+                                      of #t_IpcMsgHandler callback function type);
+                                      This size shall be zero if the message handler never generates replies.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error XX_IpcRegisterMsgHandler(char                   addr[XX_IPC_MAX_ADDR_NAME_LENGTH],
+                                 t_IpcMsgHandler        *f_MsgHandler,
+                                 t_Handle               h_Module,
+                                 uint32_t               replyLength);
+
+/**************************************************************************//**
+ @Function      XX_IpcUnregisterMsgHandler
+
+ @Description   Release IPC mailbox routine.
+
+                 This function is used for unregistering an IPC message handler from the IPC service.
+                 This function is called by each destination endpoint to indicate that it is no longer
+                 capable of handling incoming messages.
+
+ @Param[in]     addr          - The address name string associated with the destination endpoint;
+                                This address is the same as was used when the message handler was
+                                registered via XX_IpcRegisterMsgHandler().
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error XX_IpcUnregisterMsgHandler(char addr[XX_IPC_MAX_ADDR_NAME_LENGTH]);
+
+/**************************************************************************//**
+ @Function      XX_IpcInitSession
+
+ @Description   This function is used for creating an IPC session between the source endpoint
+                and the destination endpoint.
+
+                The actual implementation and representation of a session is left for the IPC service.
+                The function returns an abstract handle to the created session. This handle shall be used
+                by the source endpoint in subsequent calls to XX_IpcSendMessage().
+                The IPC service assumes that before this function is called, no messages are sent from
+                the specified source endpoint to the specified destination endpoint.
+
+                The IPC service may use a connection-oriented approach or a connectionless approach (or both)
+                as described below.
+
+                @par Connection-Oriented Approach
+
+                The IPC service may implement a session in a connection-oriented approach -  when this function is called,
+                the IPC service should take the necessary steps to bring up a source-to-destination channel for messages
+                and a destination-to-source channel for replies. The returned handle should represent the internal
+                representation of these channels.
+
+                @par Connectionless Approach
+
+                The IPC service may implement a session in a connectionless approach -  when this function is called, the
+                IPC service should not perform any particular steps, but it must store the pair of source and destination
+                addresses in some session representation and return it as a handle. When XX_IpcSendMessage() shall be
+                called, the IPC service may use this handle to provide the necessary identifiers for routing the messages
+                through the connectionless medium.
+
+ @Param[in]     destAddr      - The address name string associated with the destination endpoint.
+ @Param[in]     srcAddr       - The address name string associated with the source endpoint.
+
+ @Return        Abstract handle to the initialized session, or NULL on error.
+*//***************************************************************************/
+t_Handle XX_IpcInitSession(char destAddr[XX_IPC_MAX_ADDR_NAME_LENGTH],
+                           char srcAddr[XX_IPC_MAX_ADDR_NAME_LENGTH]);
+
+/**************************************************************************//**
+ @Function      XX_IpcFreeSession
+
+ @Description   This function is used for terminating an existing IPC session between a source endpoint
+                and a destination endpoint.
+
+                The IPC service assumes that after this function is called, no messages shall be sent from
+                the associated source endpoint to the associated destination endpoint.
+
+ @Param[in]     h_Session      - Abstract handle to the IPC session -  the same handle as was originally
+                                 returned by the XX_IpcInitSession() function.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error XX_IpcFreeSession(t_Handle h_Session);
+
+/**************************************************************************//**
+ @Function      XX_IpcSendMessage
+
+ @Description   IPC message send routine.
+
+                This function may be used by a source endpoint to send an IPC message to a destination
+                endpoint. The source endpoint cannot send a message to the destination endpoint without
+                first initiating a session with that destination endpoint via XX_IpcInitSession() routine.
+
+                The source endpoint must provide the buffer pointer and length of the outgoing message.
+                Optionally, it may also provide a buffer for an expected reply. In the latter case, the
+                transaction is not considered complete by the IPC service until the reply has been received.
+                If the source endpoint does not provide a reply buffer, the transaction is considered
+                complete after the message has been sent. The source endpoint must keep the message (and
+                optional reply) buffers valid until the transaction is complete.
+
+                @par Non-blocking mode
+
+                The source endpoint may request a non-blocking send by providing a non-NULL pointer to a message
+                completion callback function (f_Completion). Upon completion of the IPC transaction (consisting of a
+                message and an optional reply), the IPC service invokes this callback routine to return the message
+                buffer to the sender and to provide the received reply, if requested.
+
+                @par Blocking mode
+
+                The source endpoint may request a blocking send by setting f_Completion to NULL. The function is
+                expected to block until the IPC transaction is complete -  either the reply has been received or (if no reply
+                was requested) the message has been sent.
+
+ @Param[in]     h_Session       - Abstract handle to the IPC session -  the same handle as was originally
+                                  returned by the XX_IpcInitSession() function.
+ @Param[in]     p_Msg           - Pointer to message buffer to send.
+ @Param[in]     msgLength       - Length (in bytes) of actual data in the message buffer.
+ @Param[in]     p_Reply         - Pointer to reply buffer -  if this buffer is not NULL, the IPC service
+                                  fills this buffer with the received reply data;
+                                  In blocking mode, the reply data must be valid when the function returns;
+                                  In non-blocking mode, the reply data is valid when f_Completion is called;
+                                  If this pointer is NULL, no reply is expected.
+ @Param[in,out] p_ReplyLength   - Pointer to reply length, which has a dual role in this function:
+                                  [In] specifies the maximal length (in bytes) of the reply buffer pointed by
+                                  p_Reply, and
+                                  [Out] in non-blocking mode this value is updated by the IPC service to the
+                                  actual reply length (in bytes).
+ @Param[in]     f_Completion    - Pointer to a completion callback to be used in non-blocking send mode;
+                                  The completion callback is invoked by the IPC service upon
+                                  completion of the IPC transaction (consisting of a message and an optional
+                                  reply);
+                                  If this pointer is NULL, the function is expected to block until the IPC
+                                  transaction is complete.
+ @Param[in]     h_Arg           - Abstract handle to the sending module; passed unchanged to the f_Completion
+                                  callback function as the first argument.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error XX_IpcSendMessage(t_Handle           h_Session,
+                          uint8_t            *p_Msg,
+                          uint32_t           msgLength,
+                          uint8_t            *p_Reply,
+                          uint32_t           *p_ReplyLength,
+                          t_IpcMsgCompletion *f_Completion,
+                          t_Handle           h_Arg);
+
+#else /* NCSW_MULTI_PARTITION */
+#define XX_IpcRegisterMsgHandler(a,b,c,d)   (E_OK)
+#define XX_IpcUnregisterMsgHandler(a)       (E_OK)
+#define XX_IpcInitSession(a,b)              (E_OK)
+#define XX_IpcFreeSession(a)                (E_OK)
+#define XX_IpcSendMessage(a,b,c,d,e,f,g)    (E_OK)
+#endif /* NCSW_MULTI_PARTITION */
+
+/** @} */ /* end of xx_ipc group */
+/** @} */ /* end of xx_id group */
+
+
+#endif /* __XX_EXT_H */
--- fmlib-fslsdk-v1.7/include/fmd/types_linux.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/types_linux.h	2022-05-26 11:28:31.134971204 -0700
@@ -0,0 +1,162 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+#ifndef __TYPES_LINUX_H
+#define __TYPES_LINUX_H
+#ifdef __GNUC__
+/* __inline__ is already valid in GNUC */
+#define _Packed
+#define _PackedType __attribute__ ((packed))
+#else   /* ! __GNUC__ */
+#define _PackedType
+#endif
+
+#ifdef DIAB
+#define _Packed __packed__
+#endif
+
+#ifdef _DIAB_TOOL
+#define _Packed __packed__
+#define __asm__ asm
+#define __volatile__ volatile
+#endif
+
+/* type definitions */
+#if defined(__KERNEL__)
+# include <linux/types.h>
+#else
+# include <stdint.h>
+# include <stddef.h>
+# include <stdbool.h>
+#endif
+
+#ifdef NETCOMMSW_ALIASING
+#define uint8_t        _NETCOMMSW_UINT8_T_
+#define uint16_t       _NETCOMMSW_UINT16_T_
+#define uint32_t       _NETCOMMSW_UINT32_T_
+#define uint64_t       _NETCOMMSW_UINT64_T_
+#define int8_t         _NETCOMMSW_INT8_T_
+#define int16_t        _NETCOMMSW_INT16_T_
+#define int32_t        _NETCOMMSW_INT32_T_
+#define int64_t        _NETCOMMSW_INT64_T_
+#define float_t        _NETCOMMSW_FLOAT_T_
+#define double_t       _NETCOMMSW_DOUBLE_T_
+#define bool           _NETCOMMSW_BOOL_
+#endif /* NETCOMMSW_ALIASING */
+
+/* physAddress_t should be uintptr_t */
+typedef uint64_t physAddress_t;
+
+#if (defined(__cplusplus))
+#undef FALSE
+#undef TRUE
+#define FALSE   false
+#define TRUE    true
+/* bool is already defined */
+
+#else
+#undef FALSE
+#undef TRUE
+#define FALSE   0
+#define TRUE    1
+/* TOBE removed: typedef char bool;*/
+#endif /* defined(__cplusplus) */
+
+/************************/
+/* Memory access macros */
+/************************/
+#define GET_UINT32(arg)             *(volatile uint32_t*)(&(arg))
+#define GET_UINT64(arg)             *(volatile uint64_t*)(&(arg))
+
+#define _WRITE_UINT32(arg, data)    *(volatile uint32_t*)(&(arg)) = (data)
+#define _WRITE_UINT64(arg, data)    *(volatile uint64_t*)(&(arg)) = (data)
+
+#ifndef QE_32_BIT_ACCESS_RESTRICTION
+
+#define GET_UINT8(arg)              *(volatile uint8_t *)(&(arg))
+#define GET_UINT16(arg)             *(volatile uint16_t*)(&(arg))
+
+#define _WRITE_UINT8(arg, data)     *(volatile uint8_t *)(&(arg)) = (data)
+#define _WRITE_UINT16(arg, data)    *(volatile uint16_t*)(&(arg)) = (data)
+
+#else  /* QE_32_BIT_ACCESS_RESTRICTION */
+
+#define QE_32_BIT_ADDR(_arg)        (uint32_t)((uint32_t)&(_arg) & 0xFFFFFFFC)
+#define QE_32_BIT_SHIFT8(__arg)     (uint32_t)((3 - ((uint32_t)&(__arg) & 0x3)) * 8)
+#define QE_32_BIT_SHIFT16(__arg)    (uint32_t)((2 - ((uint32_t)&(__arg) & 0x3)) * 8)
+
+#define GET_UINT8(arg)              (uint8_t)((*(volatile uint32_t *)QE_32_BIT_ADDR(arg)) >> QE_32_BIT_SHIFT8(arg))
+#define GET_UINT16(arg)             (uint16_t)((*(volatile uint32_t *)QE_32_BIT_ADDR(arg)) >> QE_32_BIT_SHIFT16(arg))
+
+#define _WRITE_UINT8(arg, data)                                                                         \
+    do                                                                                                  \
+    {                                                                                                   \
+        uint32_t addr = QE_32_BIT_ADDR(arg);                                                            \
+        uint32_t shift = QE_32_BIT_SHIFT8(arg);                                                         \
+        uint32_t tmp = *(volatile uint32_t *)addr;                                                      \
+        tmp = (uint32_t)((tmp & ~(0x000000FF << shift)) | ((uint32_t)(data & 0x000000FF) << shift));    \
+        *(volatile uint32_t *)addr = tmp;                                                               \
+    } while (0)
+
+#define _WRITE_UINT16(arg, data)                                                                        \
+    do                                                                                                  \
+    {                                                                                                   \
+        uint32_t addr = QE_32_BIT_ADDR(arg);                                                            \
+        uint32_t shift = QE_32_BIT_SHIFT16(arg);                                                        \
+        uint32_t tmp = *(volatile uint32_t *)addr;                                                      \
+        tmp = (uint32_t)((tmp & ~(0x0000FFFF << shift)) | ((uint32_t)(data & 0x0000FFFF) << shift));    \
+        *(volatile uint32_t *)addr = tmp;                                                               \
+    } while (0)
+
+#endif /* QE_32_BIT_ACCESS_RESTRICTION */
+
+
+#ifdef VERBOSE_WRITE
+
+#define WRITE_UINT8(arg, data)  \
+    do { XX_Print("ADDR: 0x%08x, VAL: 0x%02x\r\n",    (uint32_t)&(arg), (data)); _WRITE_UINT8((arg), (data)); } while (0)
+#define WRITE_UINT16(arg, data) \
+    do { XX_Print("ADDR: 0x%08x, VAL: 0x%04x\r\n",    (uint32_t)&(arg), (data)); _WRITE_UINT16((arg), (data)); } while (0)
+#define WRITE_UINT32(arg, data) \
+    do { XX_Print("ADDR: 0x%08x, VAL: 0x%08x\r\n",    (uint32_t)&(arg), (data)); _WRITE_UINT32((arg), (data)); } while (0)
+#define WRITE_UINT64(arg, data) \
+    do { XX_Print("ADDR: 0x%08x, VAL: 0x%016llx\r\n", (uint32_t)&(arg), (data)); _WRITE_UINT64((arg), (data)); } while (0)
+
+#else  /* not VERBOSE_WRITE */
+
+#define WRITE_UINT8                 _WRITE_UINT8
+#define WRITE_UINT16                _WRITE_UINT16
+#define WRITE_UINT32                _WRITE_UINT32
+#define WRITE_UINT64                _WRITE_UINT64
+
+#endif /* not VERBOSE_WRITE */
+#endif /* __TYPES_LINUX_H */
--- fmlib-fslsdk-v1.7/include/fmd/integrations/dpaa_integration_B4_T4.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/integrations/dpaa_integration_B4_T4.h	2022-05-26 11:28:31.098972675 -0700
@@ -0,0 +1,276 @@
+/* Copyright (c) 2009-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          dpaa_integration_B4_T4.h
+
+ @Description   B4860/T4240 FM external definitions and structures.
+*//***************************************************************************/
+#ifndef __DPAA_INTEGRATION_B4_T4_H
+#define __DPAA_INTEGRATION_B4_T4_H
+
+#include "std_ext.h"
+
+#ifdef P1023
+#error "file for B4, T4"
+#endif
+
+
+#define DPAA_VERSION    11
+
+/**************************************************************************//**
+ @Description   DPAA SW Portals Enumeration.
+*//***************************************************************************/
+typedef enum
+{
+    e_DPAA_SWPORTAL0 = 0,
+    e_DPAA_SWPORTAL1,
+    e_DPAA_SWPORTAL2,
+    e_DPAA_SWPORTAL3,
+    e_DPAA_SWPORTAL4,
+    e_DPAA_SWPORTAL5,
+    e_DPAA_SWPORTAL6,
+    e_DPAA_SWPORTAL7,
+    e_DPAA_SWPORTAL8,
+    e_DPAA_SWPORTAL9,
+    e_DPAA_SWPORTAL10,
+    e_DPAA_SWPORTAL11,
+    e_DPAA_SWPORTAL12,
+    e_DPAA_SWPORTAL13,
+    e_DPAA_SWPORTAL14,
+    e_DPAA_SWPORTAL15,
+    e_DPAA_SWPORTAL16,
+    e_DPAA_SWPORTAL17,
+    e_DPAA_SWPORTAL18,
+    e_DPAA_SWPORTAL19,
+    e_DPAA_SWPORTAL20,
+    e_DPAA_SWPORTAL21,
+    e_DPAA_SWPORTAL22,
+    e_DPAA_SWPORTAL23,
+    e_DPAA_SWPORTAL24,
+    e_DPAA_SWPORTAL_DUMMY_LAST
+} e_DpaaSwPortal;
+
+/**************************************************************************//**
+ @Description   DPAA Direct Connect Portals Enumeration.
+*//***************************************************************************/
+typedef enum
+{
+    e_DPAA_DCPORTAL0 = 0,
+    e_DPAA_DCPORTAL1,
+    e_DPAA_DCPORTAL2,
+    e_DPAA_DCPORTAL_DUMMY_LAST
+} e_DpaaDcPortal;
+
+#define DPAA_MAX_NUM_OF_SW_PORTALS      e_DPAA_SWPORTAL_DUMMY_LAST
+#define DPAA_MAX_NUM_OF_DC_PORTALS      e_DPAA_DCPORTAL_DUMMY_LAST
+
+/*****************************************************************************
+ QMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define QM_MAX_NUM_OF_POOL_CHANNELS     15      /**< Total number of channels, dedicated and pool */
+#define QM_MAX_NUM_OF_WQ                8       /**< Number of work queues per channel */
+#define QM_MAX_NUM_OF_CGS               256     /**< Congestion groups number */
+#define QM_MAX_NUM_OF_FQIDS             (16 * MEGABYTE)
+                                                /**< FQIDs range - 24 bits */
+
+/**************************************************************************//**
+ @Description   Work Queue Channel assignments in QMan.
+*//***************************************************************************/
+typedef enum
+{
+    e_QM_FQ_CHANNEL_SWPORTAL0 = 0x0,              /**< Dedicated channels serviced by software portals 0 to 24 */
+    e_QM_FQ_CHANNEL_SWPORTAL1,
+    e_QM_FQ_CHANNEL_SWPORTAL2,
+    e_QM_FQ_CHANNEL_SWPORTAL3,
+    e_QM_FQ_CHANNEL_SWPORTAL4,
+    e_QM_FQ_CHANNEL_SWPORTAL5,
+    e_QM_FQ_CHANNEL_SWPORTAL6,
+    e_QM_FQ_CHANNEL_SWPORTAL7,
+    e_QM_FQ_CHANNEL_SWPORTAL8,
+    e_QM_FQ_CHANNEL_SWPORTAL9,
+    e_QM_FQ_CHANNEL_SWPORTAL10,
+    e_QM_FQ_CHANNEL_SWPORTAL11,
+    e_QM_FQ_CHANNEL_SWPORTAL12,
+    e_QM_FQ_CHANNEL_SWPORTAL13,
+    e_QM_FQ_CHANNEL_SWPORTAL14,
+    e_QM_FQ_CHANNEL_SWPORTAL15,
+    e_QM_FQ_CHANNEL_SWPORTAL16,
+    e_QM_FQ_CHANNEL_SWPORTAL17,
+    e_QM_FQ_CHANNEL_SWPORTAL18,
+    e_QM_FQ_CHANNEL_SWPORTAL19,
+    e_QM_FQ_CHANNEL_SWPORTAL20,
+    e_QM_FQ_CHANNEL_SWPORTAL21,
+    e_QM_FQ_CHANNEL_SWPORTAL22,
+    e_QM_FQ_CHANNEL_SWPORTAL23,
+    e_QM_FQ_CHANNEL_SWPORTAL24,
+
+    e_QM_FQ_CHANNEL_POOL1 = 0x401,               /**< Pool channels that can be serviced by any of the software portals */
+    e_QM_FQ_CHANNEL_POOL2,
+    e_QM_FQ_CHANNEL_POOL3,
+    e_QM_FQ_CHANNEL_POOL4,
+    e_QM_FQ_CHANNEL_POOL5,
+    e_QM_FQ_CHANNEL_POOL6,
+    e_QM_FQ_CHANNEL_POOL7,
+    e_QM_FQ_CHANNEL_POOL8,
+    e_QM_FQ_CHANNEL_POOL9,
+    e_QM_FQ_CHANNEL_POOL10,
+    e_QM_FQ_CHANNEL_POOL11,
+    e_QM_FQ_CHANNEL_POOL12,
+    e_QM_FQ_CHANNEL_POOL13,
+    e_QM_FQ_CHANNEL_POOL14,
+    e_QM_FQ_CHANNEL_POOL15,
+
+    e_QM_FQ_CHANNEL_FMAN0_SP0 = 0x800,           /**< Dedicated channels serviced by Direct Connect Portal 0:
+                                                      connected to FMan 0; assigned in incrementing order to
+                                                      each sub-portal (SP) in the portal */
+    e_QM_FQ_CHANNEL_FMAN0_SP1,
+    e_QM_FQ_CHANNEL_FMAN0_SP2,
+    e_QM_FQ_CHANNEL_FMAN0_SP3,
+    e_QM_FQ_CHANNEL_FMAN0_SP4,
+    e_QM_FQ_CHANNEL_FMAN0_SP5,
+    e_QM_FQ_CHANNEL_FMAN0_SP6,
+    e_QM_FQ_CHANNEL_FMAN0_SP7,
+    e_QM_FQ_CHANNEL_FMAN0_SP8,
+    e_QM_FQ_CHANNEL_FMAN0_SP9,
+    e_QM_FQ_CHANNEL_FMAN0_SP10,
+    e_QM_FQ_CHANNEL_FMAN0_SP11,
+    e_QM_FQ_CHANNEL_FMAN0_SP12,
+    e_QM_FQ_CHANNEL_FMAN0_SP13,
+    e_QM_FQ_CHANNEL_FMAN0_SP14,
+    e_QM_FQ_CHANNEL_FMAN0_SP15,
+
+    e_QM_FQ_CHANNEL_RMAN_SP0 = 0x820,            /**< Dedicated channels serviced by Direct Connect Portal 1: connected to RMan */
+    e_QM_FQ_CHANNEL_RMAN_SP1,
+
+    e_QM_FQ_CHANNEL_CAAM = 0x840                 /**< Dedicated channel serviced by Direct Connect Portal 2:
+                                                      connected to SEC */
+} e_QmFQChannel;
+
+/*****************************************************************************
+ BMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define BM_MAX_NUM_OF_POOLS         64          /**< Number of buffers pools */
+
+
+/*****************************************************************************
+ SEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define SEC_NUM_OF_DECOS            3
+#define SEC_ALL_DECOS_MASK          0x00000003
+
+/*****************************************************************************
+ FM INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define INTG_MAX_NUM_OF_FM          2
+
+/* Ports defines */
+#define FM_MAX_NUM_OF_1G_MACS       6
+#define FM_MAX_NUM_OF_10G_MACS      2
+#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS + FM_MAX_NUM_OF_10G_MACS)
+#define FM_MAX_NUM_OF_OH_PORTS      6
+
+#define FM_MAX_NUM_OF_1G_RX_PORTS   FM_MAX_NUM_OF_1G_MACS
+#define FM_MAX_NUM_OF_10G_RX_PORTS  FM_MAX_NUM_OF_10G_MACS
+#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS + FM_MAX_NUM_OF_1G_RX_PORTS)
+
+#define FM_MAX_NUM_OF_1G_TX_PORTS   FM_MAX_NUM_OF_1G_MACS
+#define FM_MAX_NUM_OF_10G_TX_PORTS  FM_MAX_NUM_OF_10G_MACS
+#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS + FM_MAX_NUM_OF_1G_TX_PORTS)
+
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS            4           /**< Number of external BM pools per Rx port */
+#define FM_PORT_NUM_OF_CONGESTION_GRPS          256         /**< Total number of congestion groups in QM */
+#define FM_MAX_NUM_OF_SUB_PORTALS               16
+#define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   0
+
+#define FM_VSP_MAX_NUM_OF_ENTRIES               64
+#define FM_MAX_NUM_OF_PFC_PRIORITIES            8
+
+/* RAMs defines */
+#define FM_MURAM_SIZE                   (384 * KILOBYTE)
+#define FM_IRAM_SIZE                    ( 64 * KILOBYTE)
+
+/* PCD defines */
+#define FM_PCD_PLCR_NUM_ENTRIES         256                 /**< Total number of policer profiles */
+#define FM_PCD_KG_NUM_OF_SCHEMES        32                  /**< Total number of KG schemes */
+#define FM_PCD_MAX_NUM_OF_CLS_PLANS     256                 /**< Number of classification plan entries. */
+
+/* RTC defines */
+#define FM_RTC_NUM_OF_ALARMS            2                   /**< RTC number of alarms */
+#define FM_RTC_NUM_OF_PERIODIC_PULSES   3                   /**< RTC number of periodic pulses */
+#define FM_RTC_NUM_OF_EXT_TRIGGERS      2                   /**< RTC number of external triggers */
+
+/* QMI defines */
+#define QMI_MAX_NUM_OF_TNUMS            64
+#define QMI_DEF_TNUMS_THRESH            48
+
+/* FPM defines */
+#define FM_NUM_OF_FMAN_CTRL_EVENT_REGS  4
+
+/* DMA defines */
+#define DMA_THRESH_MAX_COMMQ            83
+#define DMA_THRESH_MAX_BUF              127
+
+/* BMI defines */
+#define BMI_MAX_NUM_OF_TASKS            128
+#define BMI_MAX_NUM_OF_DMAS             84
+#define BMI_MAX_FIFO_SIZE               (FM_MURAM_SIZE)
+#define PORT_MAX_WEIGHT                 16
+
+#define FM_CHECK_PORT_RESTRICTIONS(__validPorts, __newPortIndx)   TRUE
+
+/* Unique T4240 */
+#define FM_OP_OPEN_DMA_MIN_LIMIT
+#define FM_NO_RESTRICT_ON_ACCESS_RSRC
+#define FM_NO_OP_OBSERVED_POOLS
+#define FM_FRAME_END_PARAMS_FOR_OP
+#define FM_DEQ_PIPELINE_PARAMS_FOR_OP
+#define FM_NO_TOTAL_DMAS
+#define FM_QMI_NO_SINGLE_ECC_EXCEPTION
+//TODO - for simulator only, due to wrong reset values. Remove when fixed,
+//and also search for the places it appears in the source files and remove
+//comments of majorRev<6
+#define FM_NO_GUARANTEED_RESET_VALUES
+
+/* FM erratas */
+//#define FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+
+#define FM_RX_PREAM_4_ERRATA_DTSEC_A001
+#define FM_MAGIC_PACKET_UNRECOGNIZED_ERRATA_DTSEC2              /* No implementation, Out of LLD scope */
+
+
+#define FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173
+
+#define FM_LEN_CHECK_ERRATA_FMAN_SW002
+
+
+#endif /* __DPAA_INTEGRATION_B4_T4_H */
--- fmlib-fslsdk-v1.7/include/fmd/integrations/part_ext.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/integrations/part_ext.h	2022-05-26 11:28:31.118971857 -0700
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          part_ext.h
+
+ @Description   Definitions for the part (integration) module.
+*//***************************************************************************/
+
+#ifndef __PART_EXT_H
+#define __PART_EXT_H
+
+#include "std_ext.h"
+#include "part_integration_ext.h"
+
+
+#if !(defined(P1023) || defined(P2041) || defined(P3041) || defined(P4080) || defined(P5020) || defined(P5040) || defined(B4860) || defined(T4240))
+#error "unable to proceed without chip-definition"
+#endif
+
+
+/**************************************************************************//*
+ @Description   Part data structure - must be contained in any integration
+                data structure.
+*//***************************************************************************/
+typedef struct t_Part
+{
+    uintptr_t   (* f_GetModuleBase)(t_Handle h_Part, e_ModuleId moduleId);
+                /**< Returns the address of the module's memory map base. */
+    e_ModuleId  (* f_GetModuleIdByBase)(t_Handle h_Part, uintptr_t baseAddress);
+                /**< Returns the module's ID according to its memory map base. */
+} t_Part;
+
+#ifdef P1023
+#include "part_P1023.h"
+#elif defined B4860 || defined T4240
+#include "part_B4_T4.h"
+#else
+#include "part_P3_P4_P5.h"
+#endif
+
+#endif /* __PART_EXT_H */
--- fmlib-fslsdk-v1.7/include/fmd/integrations/dpaa_integration_ext.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/integrations/dpaa_integration_ext.h	2022-05-26 11:28:31.118971857 -0700
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2009-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          dpaa_integration_ext.h
+
+ @Description   FM external definitions and structures.
+*//***************************************************************************/
+#ifndef __DPAA_INTEGRATION_EXT_H
+#define __DPAA_INTEGRATION_EXT_H
+
+#ifdef P1023
+#include "dpaa_integration_P1023.h"
+#elif defined B4860 || defined T4240
+#include "dpaa_integration_B4_T4.h"
+#else
+#include "dpaa_integration_P3_P4_P5.h"
+#endif
+
+#endif /* __DPAA_INTEGRATION_EXT_H */
--- fmlib-fslsdk-v1.7/include/fmd/integrations/part_integration_B4_T4.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/integrations/part_integration_B4_T4.h	2022-05-26 11:28:31.118971857 -0700
@@ -0,0 +1,304 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          part_integration_B4_T4.h
+
+ @Description   B4860/T4240 external definitions and structures.
+*//***************************************************************************/
+#ifndef __PART_INTEGRATION_B4_T4_H
+#define __PART_INTEGRATION_B4_T4_H
+
+#include "std_ext.h"
+#include "dpaa_integration_ext.h"
+
+
+/**************************************************************************//**
+ @Group         T4240_chip_id T4240 Application Programming Interface
+
+ @Description   T4240 Chip functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+#define CORE_E6500
+
+#define INTG_MAX_NUM_OF_CORES   1
+#define CORE_GetId()            0
+#define CORE_IS_BIG_ENDIAN
+#define SYS_ANY_CORE    ((uint32_t)-1)  /**< Assignment to any valid core */
+#define SYS_IS_MASTER_CORE()    TRUE
+
+
+/**************************************************************************//**
+ @Description   Module types.
+*//***************************************************************************/
+typedef enum e_ModuleId
+{
+    e_MODULE_ID_DUART_1 = 0,
+    e_MODULE_ID_DUART_2,
+    e_MODULE_ID_DUART_3,
+    e_MODULE_ID_DUART_4,
+    e_MODULE_ID_LAW,
+    e_MODULE_ID_IFC,
+    e_MODULE_ID_PAMU,
+    e_MODULE_ID_QM,                 /**< Queue manager module */
+    e_MODULE_ID_BM,                 /**< Buffer manager module */
+    e_MODULE_ID_QM_CE_PORTAL_0,
+    e_MODULE_ID_QM_CI_PORTAL_0,
+    e_MODULE_ID_QM_CE_PORTAL_1,
+    e_MODULE_ID_QM_CI_PORTAL_1,
+    e_MODULE_ID_QM_CE_PORTAL_2,
+    e_MODULE_ID_QM_CI_PORTAL_2,
+    e_MODULE_ID_QM_CE_PORTAL_3,
+    e_MODULE_ID_QM_CI_PORTAL_3,
+    e_MODULE_ID_QM_CE_PORTAL_4,
+    e_MODULE_ID_QM_CI_PORTAL_4,
+    e_MODULE_ID_QM_CE_PORTAL_5,
+    e_MODULE_ID_QM_CI_PORTAL_5,
+    e_MODULE_ID_QM_CE_PORTAL_6,
+    e_MODULE_ID_QM_CI_PORTAL_6,
+    e_MODULE_ID_QM_CE_PORTAL_7,
+    e_MODULE_ID_QM_CI_PORTAL_7,
+    e_MODULE_ID_QM_CE_PORTAL_8,
+    e_MODULE_ID_QM_CI_PORTAL_8,
+    e_MODULE_ID_QM_CE_PORTAL_9,
+    e_MODULE_ID_QM_CI_PORTAL_9,
+    e_MODULE_ID_BM_CE_PORTAL_0,
+    e_MODULE_ID_BM_CI_PORTAL_0,
+    e_MODULE_ID_BM_CE_PORTAL_1,
+    e_MODULE_ID_BM_CI_PORTAL_1,
+    e_MODULE_ID_BM_CE_PORTAL_2,
+    e_MODULE_ID_BM_CI_PORTAL_2,
+    e_MODULE_ID_BM_CE_PORTAL_3,
+    e_MODULE_ID_BM_CI_PORTAL_3,
+    e_MODULE_ID_BM_CE_PORTAL_4,
+    e_MODULE_ID_BM_CI_PORTAL_4,
+    e_MODULE_ID_BM_CE_PORTAL_5,
+    e_MODULE_ID_BM_CI_PORTAL_5,
+    e_MODULE_ID_BM_CE_PORTAL_6,
+    e_MODULE_ID_BM_CI_PORTAL_6,
+    e_MODULE_ID_BM_CE_PORTAL_7,
+    e_MODULE_ID_BM_CI_PORTAL_7,
+    e_MODULE_ID_BM_CE_PORTAL_8,
+    e_MODULE_ID_BM_CI_PORTAL_8,
+    e_MODULE_ID_BM_CE_PORTAL_9,
+    e_MODULE_ID_BM_CI_PORTAL_9,
+    e_MODULE_ID_FM,                 /**< Frame manager module */
+    e_MODULE_ID_FM_RTC,             /**< FM Real-Time-Clock */
+    e_MODULE_ID_FM_MURAM,           /**< FM Multi-User-RAM */
+    e_MODULE_ID_FM_BMI,             /**< FM BMI block */
+    e_MODULE_ID_FM_QMI,             /**< FM QMI block */
+    e_MODULE_ID_FM_PARSER,          /**< FM parser block */
+    e_MODULE_ID_FM_PORT_HO1,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO2,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO3,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO4,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO5,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO6,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO7,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_1GRx1,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx2,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx3,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx4,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx5,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx6,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_10GRx1,     /**< FM Rx 10G MAC port block */
+    e_MODULE_ID_FM_PORT_10GRx2,     /**< FM Rx 10G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx1,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx2,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx3,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx4,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx5,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx6,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_10GTx1,     /**< FM Tx 10G MAC port block */
+    e_MODULE_ID_FM_PORT_10GTx2,     /**< FM Tx 10G MAC port block */
+    e_MODULE_ID_FM_PLCR,            /**< FM Policer */
+    e_MODULE_ID_FM_KG,              /**< FM Keygen */
+    e_MODULE_ID_FM_DMA,             /**< FM DMA */
+    e_MODULE_ID_FM_FPM,             /**< FM FPM */
+    e_MODULE_ID_FM_IRAM,            /**< FM Instruction-RAM */
+    e_MODULE_ID_FM_1GMDIO,          /**< FM 1G MDIO MAC */
+    e_MODULE_ID_FM_10GMDIO,         /**< FM 10G MDIO */
+    e_MODULE_ID_FM_PRS_IRAM,        /**< FM SW-parser Instruction-RAM */
+    e_MODULE_ID_FM_1GMAC1,          /**< FM 1G MAC #1 */
+    e_MODULE_ID_FM_1GMAC2,          /**< FM 1G MAC #2 */
+    e_MODULE_ID_FM_1GMAC3,          /**< FM 1G MAC #3 */
+    e_MODULE_ID_FM_1GMAC4,          /**< FM 1G MAC #4 */
+    e_MODULE_ID_FM_1GMAC5,          /**< FM 1G MAC #5 */
+    e_MODULE_ID_FM_1GMAC6,          /**< FM 1G MAC #6 */
+    e_MODULE_ID_FM_10GMAC1,         /**< FM 10G MAC */
+    e_MODULE_ID_FM_10GMAC2,         /**< FM 10G MAC */
+
+    e_MODULE_ID_SEC_GEN,            /**< SEC 4.0 General registers      */
+    e_MODULE_ID_SEC_QI,             /**< SEC 4.0 QI registers           */
+    e_MODULE_ID_SEC_JQ0,            /**< SEC 4.0 JQ-0 registers         */
+    e_MODULE_ID_SEC_JQ1,            /**< SEC 4.0 JQ-1 registers         */
+    e_MODULE_ID_SEC_JQ2,            /**< SEC 4.0 JQ-2 registers         */
+    e_MODULE_ID_SEC_JQ3,            /**< SEC 4.0 JQ-3 registers         */
+    e_MODULE_ID_SEC_RTIC,           /**< SEC 4.0 RTIC registers         */
+    e_MODULE_ID_SEC_DECO0_CCB0,     /**< SEC 4.0 DECO-0/CCB-0 registers */
+    e_MODULE_ID_SEC_DECO1_CCB1,     /**< SEC 4.0 DECO-1/CCB-1 registers */
+    e_MODULE_ID_SEC_DECO2_CCB2,     /**< SEC 4.0 DECO-2/CCB-2 registers */
+    e_MODULE_ID_SEC_DECO3_CCB3,     /**< SEC 4.0 DECO-3/CCB-3 registers */
+    e_MODULE_ID_SEC_DECO4_CCB4,     /**< SEC 4.0 DECO-4/CCB-4 registers */
+
+    e_MODULE_ID_PIC,                /**< PIC */
+    e_MODULE_ID_GPIO,               /**< GPIO */
+    e_MODULE_ID_SERDES,             /**< SERDES */
+    e_MODULE_ID_CPC_1,              /**< CoreNet-Platform-Cache 1 */
+    e_MODULE_ID_CPC_2,              /**< CoreNet-Platform-Cache 2 */
+
+    e_MODULE_ID_SRIO_PORTS,         /**< RapidIO controller */
+
+    e_MODULE_ID_DUMMY_LAST
+} e_ModuleId;
+
+#define NUM_OF_MODULES  e_MODULE_ID_DUMMY_LAST
+
+#if 0 /* using unified values */
+/*****************************************************************************
+ INTEGRATION-SPECIFIC MODULE CODES
+******************************************************************************/
+#define MODULE_UNKNOWN          0x00000000
+#define MODULE_MEM              0x00010000
+#define MODULE_MM               0x00020000
+#define MODULE_CORE             0x00030000
+#define MODULE_T4240            0x00040000
+#define MODULE_T4240_PLATFORM   0x00050000
+#define MODULE_PM               0x00060000
+#define MODULE_MMU              0x00070000
+#define MODULE_PIC              0x00080000
+#define MODULE_CPC              0x00090000
+#define MODULE_DUART            0x000a0000
+#define MODULE_SERDES           0x000b0000
+#define MODULE_PIO              0x000c0000
+#define MODULE_QM               0x000d0000
+#define MODULE_BM               0x000e0000
+#define MODULE_SEC              0x000f0000
+#define MODULE_LAW              0x00100000
+#define MODULE_LBC              0x00110000
+#define MODULE_PAMU             0x00120000
+#define MODULE_FM               0x00130000
+#define MODULE_FM_MURAM         0x00140000
+#define MODULE_FM_PCD           0x00150000
+#define MODULE_FM_RTC           0x00160000
+#define MODULE_FM_MAC           0x00170000
+#define MODULE_FM_PORT          0x00180000
+#define MODULE_FM_SP            0x00190000
+#define MODULE_DPA_PORT         0x001a0000
+#define MODULE_MII              0x001b0000
+#define MODULE_I2C              0x001c0000
+#define MODULE_DMA              0x001d0000
+#define MODULE_DDR              0x001e0000
+#define MODULE_ESPI             0x001f0000
+#define MODULE_DPAA_IPSEC       0x00200000
+#endif /* using unified values */
+
+/*****************************************************************************
+ PAMU INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define PAMU_NUM_OF_PARTITIONS  4
+
+/*****************************************************************************
+ LAW INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define LAW_NUM_OF_WINDOWS      32
+#define LAW_MIN_WINDOW_SIZE     0x0000000000001000LL    /**< 4 Kbytes */
+#define LAW_MAX_WINDOW_SIZE     0x0000010000000000LL    /**< 1 Tbytes for 40-bit address space */
+
+/*****************************************************************************
+ LBC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+/**************************************************************************//**
+ @Group         lbc_exception_grp LBC Exception Unit
+
+ @Description   LBC Exception unit API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Anchor        lbc_exbm
+
+ @Collection    LBC Errors Bit Mask
+
+                These errors are reported through the exceptions callback..
+                The values can be or'ed in any combination in the errors mask
+                parameter of the errors report structure.
+
+                These errors can also be passed as a bit-mask to
+                LBC_EnableErrorChecking() or LBC_DisableErrorChecking(),
+                for enabling or disabling error checking.
+ @{
+*//***************************************************************************/
+#define LBC_ERR_BUS_MONITOR     0x80000000  /**< Bus monitor error */
+#define LBC_ERR_PARITY_ECC      0x20000000  /**< Parity error for GPCM/UPM */
+#define LBC_ERR_WRITE_PROTECT   0x04000000  /**< Write protection error */
+#define LBC_ERR_CHIP_SELECT     0x00080000  /**< Unrecognized chip select */
+
+#define LBC_ERR_ALL             (LBC_ERR_BUS_MONITOR | LBC_ERR_PARITY_ECC | \
+                                 LBC_ERR_WRITE_PROTECT | LBC_ERR_CHIP_SELECT)
+                                            /**< All possible errors */
+/* @} */
+/** @} */ /* end of lbc_exception_grp group */
+
+#define LBC_INCORRECT_ERROR_REPORT_ERRATA
+
+#define LBC_NUM_OF_BANKS            8
+#define LBC_MAX_CS_SIZE             0x0000000100000000LL  /* Up to 4G memory block size */
+#define LBC_PARITY_SUPPORT
+#define LBC_ADDRESS_HOLD_TIME_CTRL
+#define LBC_HIGH_CLK_DIVIDERS
+#define LBC_FCM_AVAILABLE
+
+/*****************************************************************************
+ GPIO INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define GPIO_PORT_OFFSET_0x1000
+
+#define GPIO_NUM_OF_PORTS   3   /**< Number of ports in GPIO module;
+                                     Each port contains up to 32 I/O pins. */
+
+#define GPIO_VALID_PIN_MASKS   \
+    { /* Port A */ 0xFFFFFFFF, \
+	  /* Port B */ 0xFFFFFFFF, \
+      /* Port C */ 0xFFFFFFFF }
+
+#define GPIO_VALID_INTR_MASKS  \
+    { /* Port A */ 0xFFFFFFFF, \
+      /* Port B */ 0xFFFFFFFF, \
+      /* Port C */ 0xFFFFFFFF }
+
+
+
+#endif /* __PART_INTEGRATION_B4_T4_H */
--- fmlib-fslsdk-v1.7/include/fmd/integrations/part_B4_T4.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/integrations/part_B4_T4.h	2022-05-26 11:28:31.118971857 -0700
@@ -0,0 +1,44 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          part_B4_T4.h
+
+ @Description   Definitions for the part (integration) module.
+*//***************************************************************************/
+
+#ifndef __PART_B4_T4_H
+#define __PART_B4_T4_H
+
+/* B4/T4 chip-specific defs. should go here. */
+
+#endif /* __PART_B4_T4_H */
--- fmlib-fslsdk-v1.7/include/fmd/integrations/part_integration_ext.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/integrations/part_integration_ext.h	2022-05-26 11:28:31.118971857 -0700
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2009-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          part_integration_ext.h
+
+ @Description   P4080/P5020/P3041/P1023 external definitions and structures.
+*//***************************************************************************/
+#ifndef __PART_INTEGRATION_EXT_H
+#define __PART_INTEGRATION_EXT_H
+
+#ifdef P1023
+#include "part_integration_P1023.h"
+#elif defined B4860 || defined T4240
+#include "part_integration_B4_T4.h"
+#else
+#include "part_integration_P3_P4_P5.h"
+#endif
+
+/*****************************************************************************
+ *  UNIFIED MODULE CODES
+ *****************************************************************************/
+  #define MODULE_UNKNOWN          0x00000000
+  #define MODULE_FM               0x00010000
+  #define MODULE_FM_MURAM         0x00020000
+  #define MODULE_FM_PCD           0x00030000
+  #define MODULE_FM_RTC           0x00040000
+  #define MODULE_FM_MAC           0x00050000
+  #define MODULE_FM_PORT          0x00060000
+  #define MODULE_MM               0x00070000
+  #define MODULE_FM_SP            0x00080000
+
+#endif /* __PART_INTEGRATION_EXT_H */
--- fmlib-fslsdk-v1.7/include/fmd/integrations/dpaa_integration_P3_P4_P5.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/integrations/dpaa_integration_P3_P4_P5.h	2022-05-26 11:28:31.118971857 -0700
@@ -0,0 +1,276 @@
+/*
+ * Copyright 2009-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          dpaa_integration_P3_P4_P5.h
+
+ @Description   P4080/P5020/P3041 FM external definitions and structures.
+*//***************************************************************************/
+#ifndef __DPAA_INTEGRATION_P3_P4_P5_H
+#define __DPAA_INTEGRATION_P3_P4_P5_H
+
+#include "std_ext.h"
+
+#ifdef P1023
+#error "file for p3, p4, p5"
+#endif
+
+
+#define DPAA_VERSION    10
+
+/**************************************************************************//**
+ @Description   DPAA SW Portals Enumeration.
+*//***************************************************************************/
+typedef enum
+{
+    e_DPAA_SWPORTAL0 = 0,
+    e_DPAA_SWPORTAL1,
+    e_DPAA_SWPORTAL2,
+    e_DPAA_SWPORTAL3,
+    e_DPAA_SWPORTAL4,
+    e_DPAA_SWPORTAL5,
+    e_DPAA_SWPORTAL6,
+    e_DPAA_SWPORTAL7,
+    e_DPAA_SWPORTAL8,
+    e_DPAA_SWPORTAL9,
+    e_DPAA_SWPORTAL_DUMMY_LAST
+} e_DpaaSwPortal;
+
+/**************************************************************************//**
+ @Description   DPAA Direct Connect Portals Enumeration.
+*//***************************************************************************/
+typedef enum
+{
+    e_DPAA_DCPORTAL0 = 0,
+    e_DPAA_DCPORTAL1,
+    e_DPAA_DCPORTAL2,
+    e_DPAA_DCPORTAL3,
+    e_DPAA_DCPORTAL4,
+    e_DPAA_DCPORTAL_DUMMY_LAST
+} e_DpaaDcPortal;
+
+#define DPAA_MAX_NUM_OF_SW_PORTALS      e_DPAA_SWPORTAL_DUMMY_LAST
+#define DPAA_MAX_NUM_OF_DC_PORTALS      e_DPAA_DCPORTAL_DUMMY_LAST
+
+/*****************************************************************************
+ QMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define QM_MAX_NUM_OF_POOL_CHANNELS 15              /**< Total number of channels, dedicated and pool */
+#define QM_MAX_NUM_OF_WQ            8               /**< Number of work queues per channel */
+#define QM_MAX_NUM_OF_SWP_AS        4
+#define QM_MAX_NUM_OF_CGS           256             /**< Number of congestion groups */
+#define QM_MAX_NUM_OF_FQIDS         (16 * MEGABYTE) /**< FQIDs range - 24 bits */
+
+/**************************************************************************//**
+ @Description   Work Queue Channel assignments in QMan.
+*//***************************************************************************/
+typedef enum
+{
+    e_QM_FQ_CHANNEL_SWPORTAL0 = 0,              /**< Dedicated channels serviced by software portals 0 to 9 */
+    e_QM_FQ_CHANNEL_SWPORTAL1,
+    e_QM_FQ_CHANNEL_SWPORTAL2,
+    e_QM_FQ_CHANNEL_SWPORTAL3,
+    e_QM_FQ_CHANNEL_SWPORTAL4,
+    e_QM_FQ_CHANNEL_SWPORTAL5,
+    e_QM_FQ_CHANNEL_SWPORTAL6,
+    e_QM_FQ_CHANNEL_SWPORTAL7,
+    e_QM_FQ_CHANNEL_SWPORTAL8,
+    e_QM_FQ_CHANNEL_SWPORTAL9,
+
+    e_QM_FQ_CHANNEL_POOL1 = 0x21,               /**< Pool channels that can be serviced by any of the software portals */
+    e_QM_FQ_CHANNEL_POOL2,
+    e_QM_FQ_CHANNEL_POOL3,
+    e_QM_FQ_CHANNEL_POOL4,
+    e_QM_FQ_CHANNEL_POOL5,
+    e_QM_FQ_CHANNEL_POOL6,
+    e_QM_FQ_CHANNEL_POOL7,
+    e_QM_FQ_CHANNEL_POOL8,
+    e_QM_FQ_CHANNEL_POOL9,
+    e_QM_FQ_CHANNEL_POOL10,
+    e_QM_FQ_CHANNEL_POOL11,
+    e_QM_FQ_CHANNEL_POOL12,
+    e_QM_FQ_CHANNEL_POOL13,
+    e_QM_FQ_CHANNEL_POOL14,
+    e_QM_FQ_CHANNEL_POOL15,
+
+    e_QM_FQ_CHANNEL_FMAN0_SP0 = 0x40,           /**< Dedicated channels serviced by Direct Connect Portal 0:
+                                                     connected to FMan 0; assigned in incrementing order to
+                                                     each sub-portal (SP) in the portal */
+    e_QM_FQ_CHANNEL_FMAN0_SP1,
+    e_QM_FQ_CHANNEL_FMAN0_SP2,
+    e_QM_FQ_CHANNEL_FMAN0_SP3,
+    e_QM_FQ_CHANNEL_FMAN0_SP4,
+    e_QM_FQ_CHANNEL_FMAN0_SP5,
+    e_QM_FQ_CHANNEL_FMAN0_SP6,
+    e_QM_FQ_CHANNEL_FMAN0_SP7,
+    e_QM_FQ_CHANNEL_FMAN0_SP8,
+    e_QM_FQ_CHANNEL_FMAN0_SP9,
+    e_QM_FQ_CHANNEL_FMAN0_SP10,
+    e_QM_FQ_CHANNEL_FMAN0_SP11,
+/* difference between 5020 and 4080 :) */
+    e_QM_FQ_CHANNEL_FMAN1_SP0 = 0x60,
+    e_QM_FQ_CHANNEL_FMAN1_SP1,
+    e_QM_FQ_CHANNEL_FMAN1_SP2,
+    e_QM_FQ_CHANNEL_FMAN1_SP3,
+    e_QM_FQ_CHANNEL_FMAN1_SP4,
+    e_QM_FQ_CHANNEL_FMAN1_SP5,
+    e_QM_FQ_CHANNEL_FMAN1_SP6,
+    e_QM_FQ_CHANNEL_FMAN1_SP7,
+    e_QM_FQ_CHANNEL_FMAN1_SP8,
+    e_QM_FQ_CHANNEL_FMAN1_SP9,
+    e_QM_FQ_CHANNEL_FMAN1_SP10,
+    e_QM_FQ_CHANNEL_FMAN1_SP11,
+
+    e_QM_FQ_CHANNEL_CAAM = 0x80,                /**< Dedicated channel serviced by Direct Connect Portal 2:
+                                                     connected to SEC 4.x */
+
+    e_QM_FQ_CHANNEL_PME = 0xA0,                 /**< Dedicated channel serviced by Direct Connect Portal 3:
+                                                     connected to PME */
+    e_QM_FQ_CHANNEL_RAID = 0xC0                 /**< Dedicated channel serviced by Direct Connect Portal 4:
+                                                     connected to RAID */
+} e_QmFQChannel;
+
+/*****************************************************************************
+ BMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define BM_MAX_NUM_OF_POOLS         64          /**< Number of buffers pools */
+
+
+/*****************************************************************************
+ FM INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define INTG_MAX_NUM_OF_FM          2
+
+/* Ports defines */
+#define FM_MAX_NUM_OF_1G_RX_PORTS   5
+#define FM_MAX_NUM_OF_10G_RX_PORTS  1
+#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS+FM_MAX_NUM_OF_1G_RX_PORTS)
+#define FM_MAX_NUM_OF_1G_TX_PORTS   5
+#define FM_MAX_NUM_OF_10G_TX_PORTS  1
+#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS+FM_MAX_NUM_OF_1G_TX_PORTS)
+#define FM_MAX_NUM_OF_OH_PORTS      7
+#define FM_MAX_NUM_OF_1G_MACS       (FM_MAX_NUM_OF_1G_RX_PORTS)
+#define FM_MAX_NUM_OF_10G_MACS      (FM_MAX_NUM_OF_10G_RX_PORTS)
+#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS+FM_MAX_NUM_OF_10G_MACS)
+
+
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS            8           /**< Number of external BM pools per Rx port */
+#define FM_PORT_NUM_OF_CONGESTION_GRPS          256         /**< Total number of congestion groups in QM */
+#define FM_MAX_NUM_OF_SUB_PORTALS               12
+#define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   0
+
+#define FM_IPSEC_SUPPORT
+
+/* RAMs defines */
+#define FM_MURAM_SIZE                   (160 * KILOBYTE)
+#define FM_IRAM_SIZE                    ( 64 * KILOBYTE)
+
+/* PCD defines */
+#define FM_PCD_PLCR_NUM_ENTRIES         256                 /**< Total number of policer profiles */
+#define FM_PCD_KG_NUM_OF_SCHEMES        32                  /**< Total number of KG schemes */
+#define FM_PCD_MAX_NUM_OF_CLS_PLANS     256                 /**< Number of classification plan entries. */
+
+/* RTC defines */
+#define FM_RTC_NUM_OF_ALARMS            2                   /**< RTC number of alarms */
+#define FM_RTC_NUM_OF_PERIODIC_PULSES   2                   /**< RTC number of periodic pulses */
+#define FM_RTC_NUM_OF_EXT_TRIGGERS      2                   /**< RTC number of external triggers */
+
+/* QMI defines */
+#define QMI_MAX_NUM_OF_TNUMS            64
+#define QMI_DEF_TNUMS_THRESH            48
+
+/* FPM defines */
+#define FM_NUM_OF_FMAN_CTRL_EVENT_REGS  4
+
+/* DMA defines */
+#define DMA_THRESH_MAX_COMMQ            31
+#define DMA_THRESH_MAX_BUF              127
+
+/* BMI defines */
+#define BMI_MAX_NUM_OF_TASKS            128
+#define BMI_MAX_NUM_OF_DMAS             32
+#define BMI_MAX_FIFO_SIZE               (FM_MURAM_SIZE)
+#define PORT_MAX_WEIGHT                 16
+
+
+#define FM_CHECK_PORT_RESTRICTIONS(__validPorts, __newPortIndx)   TRUE
+
+/* p4080-rev1 unique features */
+#define QM_CGS_NO_FRAME_MODE
+
+/* p4080 unique features */
+#define FM_NO_DISPATCH_RAM_ECC
+#define FM_FIFO_ALLOCATION_OLD_ALG
+#define FM_NO_WATCHDOG
+#define FM_NO_TNUM_AGING
+#define FM_KG_NO_BYPASS_FQID_GEN
+#define FM_KG_NO_BYPASS_PLCR_PROFILE_GEN
+#define FM_NO_BACKUP_POOLS
+#define FM_NO_OP_OBSERVED_POOLS
+#define FM_NO_ADVANCED_RATE_LIMITER
+#define FM_NO_OP_OBSERVED_CGS
+#define FM_HAS_TOTAL_DMAS
+#define FM_KG_NO_IPPID_SUPPORT
+#define FM_NO_GUARANTEED_RESET_VALUES
+#define FM_MAC_RESET
+
+/* FM erratas */
+#define FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+#define FM_TX_SHORT_FRAME_BAD_TS_ERRATA_10GMAC_A006     /* No implementation, Out of LLD scope */
+#define FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007
+#define FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008
+#define FM_TX_INVALID_ECC_ERRATA_10GMAC_A009
+#define FM_BAD_VLAN_DETECT_ERRATA_10GMAC_A010
+
+#define FM_RX_PREAM_4_ERRATA_DTSEC_A001
+#define FM_GRS_ERRATA_DTSEC_A002
+#define FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003
+#define FM_GTS_ERRATA_DTSEC_A004
+#define FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012
+#define FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014
+
+#define FM_MAGIC_PACKET_UNRECOGNIZED_ERRATA_DTSEC2          /* No implementation, Out of LLD scope */
+#define FM_TX_LOCKUP_ERRATA_DTSEC6
+
+#define FM_HC_DEF_FQID_ONLY_ERRATA_FMAN_A003                /* Implemented by ucode */
+#define FM_DEBUG_TRACE_FMAN_A004                            /* No implementation, Out of LLD scope */
+
+#define FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173
+
+#define FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005
+
+#define FM_LEN_CHECK_ERRATA_FMAN_SW002
+
+#define FM_NO_CTXA_COPY_ERRATA_FMAN_SW001
+#define FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
+
+#endif /* __DPAA_INTEGRATION_P3_P4_P5_H */
--- fmlib-fslsdk-v1.7/include/fmd/integrations/part_P1023.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/integrations/part_P1023.h	2022-05-26 11:28:31.118971857 -0700
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          part_P1023.h
+
+ @Description   Definitions for the part (integration) module.
+*//***************************************************************************/
+
+#ifndef __PART_P1023_H
+#define __PART_P1023_H
+
+#ifndef	P1023
+#error	"This file should not be #included for any platform other than P1023!"
+#endif
+
+/* P1023 chip-specific defs. should go here. */
+
+#endif /* __PART_P1023_H */
--- fmlib-fslsdk-v1.7/include/fmd/integrations/part_integration_P1023.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/integrations/part_integration_P1023.h	2022-05-26 11:28:31.118971857 -0700
@@ -0,0 +1,590 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          part_integration_P1023.h
+
+ @Description   P1023 external definitions and structures.
+*//***************************************************************************/
+#ifndef __PART_INTEGRATION_P1023_H
+#define __PART_INTEGRATION_P1023_H
+
+#include "std_ext.h"
+#include "dpaa_integration_ext.h"
+
+#ifdef P1023
+
+/**************************************************************************//**
+ @Group         1023_chip_id P1023 Application Programming Interface
+
+ @Description   P1023 Chip functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+#define CORE_E500MC
+
+#define INTG_MAX_NUM_OF_CORES   1
+#define CORE_GetId()            0
+#define CORE_IS_BIG_ENDIAN
+#define SYS_ANY_CORE    ((uint32_t)-1)  /**< Assignment to any valid core */
+#define SYS_IS_MASTER_CORE()    TRUE
+
+
+/**************************************************************************//**
+ @Description   Module types.
+*//***************************************************************************/
+typedef enum e_ModuleId
+{
+    e_MODULE_ID_LAW,            /**< Local Access module                     */
+    e_MODULE_ID_ECM,            /**< e500 Coherency Module                   */
+    e_MODULE_ID_DDR,            /**< DDR memory controller                   */
+    e_MODULE_ID_I2C_1,          /**< I2C 1                                   */
+    e_MODULE_ID_I2C_2,          /**< I2C 1                                   */
+    e_MODULE_ID_DUART_1,        /**< DUART module 1                          */
+    e_MODULE_ID_DUART_2,        /**< DUART module 2                          */
+    e_MODULE_ID_LBC,            /**< Local bus memory controller module      */
+    e_MODULE_ID_PCIE_1,         /**< PCI Express 1 controller module         */
+    e_MODULE_ID_PCIE_ATMU_1,    /**< PCI 1 ATMU Window                       */
+    e_MODULE_ID_PCIE_2,         /**< PCI Express 2 controller module         */
+    e_MODULE_ID_PCIE_ATMU_2,    /**< PCI 2 ATMU Window                       */
+    e_MODULE_ID_PCIE_3,         /**< PCI Express 3 controller module         */
+    e_MODULE_ID_PCIE_ATMU_3,    /**< PCI 3 ATMU Window                       */
+    e_MODULE_ID_MSI,            /**< MSI registers                           */
+    e_MODULE_ID_L2_SRAM,        /**< L2/SRAM Memory-Mapped controller module */
+    e_MODULE_ID_DMA_1,          /**< DMA controller 1                        */
+    e_MODULE_ID_DMA_2,          /**< DMA controller 2                        */
+    e_MODULE_ID_EPIC,           /**< Programmable interrupt controller       */
+    e_MODULE_ID_ESPI,           /**< ESPI module                             */
+    e_MODULE_ID_GPIO,           /**< General Purpose I/O                     */
+    e_MODULE_ID_SEC_GEN,        /**< SEC 4.0 General registers               */
+    e_MODULE_ID_SEC_QI,         /**< SEC 4.0 QI registers                    */
+    e_MODULE_ID_SEC_JQ0,        /**< SEC 4.0 JQ-0 registers                  */
+    e_MODULE_ID_SEC_JQ1,        /**< SEC 4.0 JQ-1 registers                  */
+    e_MODULE_ID_SEC_JQ2,        /**< SEC 4.0 JQ-2 registers                  */
+    e_MODULE_ID_SEC_JQ3,        /**< SEC 4.0 JQ-3 registers                  */
+    e_MODULE_ID_SEC_RTIC,       /**< SEC 4.0 RTIC registers                  */
+    e_MODULE_ID_SEC_DECO0_CCB0, /**< SEC 4.0 DECO-0/CCB-0 registers          */
+    e_MODULE_ID_SEC_DECO1_CCB1, /**< SEC 4.0 DECO-1/CCB-1 registers          */
+    e_MODULE_ID_SEC_DECO2_CCB2, /**< SEC 4.0 DECO-2/CCB-2 registers          */
+    e_MODULE_ID_SEC_DECO3_CCB3, /**< SEC 4.0 DECO-3/CCB-3 registers          */
+    e_MODULE_ID_SEC_DECO4_CCB4, /**< SEC 4.0 DECO-4/CCB-4 registers          */
+    e_MODULE_ID_USB_DR_1,       /**< USB 2.0 module 1                        */
+    e_MODULE_ID_USB_DR_2,       /**< USB 2.0 module 2                        */
+    e_MODULE_ID_ETSEC_MII_MNG,  /**< MII MNG registers                       */
+    e_MODULE_ID_ETSEC_1,        /**< ETSEC module 1                             */
+    e_MODULE_ID_ETSEC_2,        /**< ETSEC module 2                             */
+    e_MODULE_ID_GUTS,           /**< Serial DMA                              */
+    e_MODULE_ID_PM,             /**< Performance Monitor module              */
+    e_MODULE_ID_QM,                 /**< Queue manager module */
+    e_MODULE_ID_BM,                 /**< Buffer manager module */
+    e_MODULE_ID_QM_CE_PORTAL,
+    e_MODULE_ID_QM_CI_PORTAL,
+    e_MODULE_ID_BM_CE_PORTAL,
+    e_MODULE_ID_BM_CI_PORTAL,
+    e_MODULE_ID_FM,                /**< Frame manager #1 module */
+    e_MODULE_ID_FM_RTC,            /**< FM Real-Time-Clock */
+    e_MODULE_ID_FM_MURAM,          /**< FM Multi-User-RAM */
+    e_MODULE_ID_FM_BMI,            /**< FM BMI block */
+    e_MODULE_ID_FM_QMI,            /**< FM QMI block */
+    e_MODULE_ID_FM_PRS,            /**< FM parser block */
+    e_MODULE_ID_FM_PORT_HO0,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO1,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO2,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO3,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO4,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_1GRx0,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx1,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx0,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx1,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PLCR,           /**< FM Policer */
+    e_MODULE_ID_FM_KG,             /**< FM Keygen */
+    e_MODULE_ID_FM_DMA,            /**< FM DMA */
+    e_MODULE_ID_FM_FPM,            /**< FM FPM */
+    e_MODULE_ID_FM_IRAM,           /**< FM Instruction-RAM */
+    e_MODULE_ID_FM_1GMDIO0,        /**< FM 1G MDIO MAC 0*/
+    e_MODULE_ID_FM_1GMDIO1,        /**< FM 1G MDIO MAC 1*/
+    e_MODULE_ID_FM_PRS_IRAM,       /**< FM SW-parser Instruction-RAM */
+    e_MODULE_ID_FM_RISC0,          /**< FM risc #0 */
+    e_MODULE_ID_FM_RISC1,          /**< FM risc #1 */
+    e_MODULE_ID_FM_1GMAC0,         /**< FM 1G MAC #0 */
+    e_MODULE_ID_FM_1GMAC1,         /**< FM 1G MAC #1 */
+    e_MODULE_ID_FM_MACSEC,         /**< FM MACSEC */
+
+    e_MODULE_ID_DUMMY_LAST
+} e_ModuleId;
+
+#define NUM_OF_MODULES  e_MODULE_ID_DUMMY_LAST
+
+#define P1023_OFFSET_LAW                    0x00000C08
+#define P1023_OFFSET_ECM                    0x00001000
+#define P1023_OFFSET_DDR                    0x00002000
+#define P1023_OFFSET_I2C1                   0x00003000
+#define P1023_OFFSET_I2C2                   0x00003100
+#define P1023_OFFSET_DUART1                 0x00004500
+#define P1023_OFFSET_DUART2                 0x00004600
+#define P1023_OFFSET_LBC                    0x00005000
+#define P1023_OFFSET_ESPI                   0x00007000
+#define P1023_OFFSET_PCIE2                  0x00009000
+#define P1023_OFFSET_PCIE2_ATMU             0x00009C00
+#define P1023_OFFSET_PCIE1                  0x0000A000
+#define P1023_OFFSET_PCIE1_ATMU             0x0000AC00
+#define P1023_OFFSET_PCIE3                  0x0000B000
+#define P1023_OFFSET_PCIE3_ATMU             0x0000BC00
+#define P1023_OFFSET_DMA2                   0x0000C100
+#define P1023_OFFSET_GPIO                   0x0000F000
+#define P1023_OFFSET_L2_SRAM                0x00020000
+#define P1023_OFFSET_DMA1                   0x00021100
+#define P1023_OFFSET_USB1                   0x00022000
+#define P1023_OFFSET_SEC_GEN                0x00030000
+#define P1023_OFFSET_SEC_JQ0                0x00031000
+#define P1023_OFFSET_SEC_JQ1                0x00032000
+#define P1023_OFFSET_SEC_JQ2                0x00033000
+#define P1023_OFFSET_SEC_JQ3                0x00034000
+#define P1023_OFFSET_SEC_RTIC               0x00036000
+#define P1023_OFFSET_SEC_QI                 0x00037000
+#define P1023_OFFSET_SEC_DECO0_CCB0         0x00038000
+#define P1023_OFFSET_SEC_DECO1_CCB1         0x00039000
+#define P1023_OFFSET_SEC_DECO2_CCB2         0x0003a000
+#define P1023_OFFSET_SEC_DECO3_CCB3         0x0003b000
+#define P1023_OFFSET_SEC_DECO4_CCB4         0x0003c000
+#define P1023_OFFSET_PIC                    0x00040000
+#define P1023_OFFSET_MSI                    0x00041600
+#define P1023_OFFSET_AXI                    0x00081000
+#define P1023_OFFSET_QM                     0x00088000
+#define P1023_OFFSET_BM                     0x0008A000
+#define P1022_OFFSET_PM                     0x000E1000
+
+#define P1023_OFFSET_GUTIL                  0x000E0000
+#define P1023_OFFSET_PM                     0x000E1000
+#define P1023_OFFSET_DEBUG                  0x000E2000
+#define P1023_OFFSET_SERDES                 0x000E3000
+#define P1023_OFFSET_ROM                    0x000F0000
+#define P1023_OFFSET_FM                     0x00100000
+
+#define P1023_OFFSET_FM_MURAM               (P1023_OFFSET_FM + 0x00000000)
+#define P1023_OFFSET_FM_BMI                 (P1023_OFFSET_FM + 0x00080000)
+#define P1023_OFFSET_FM_QMI                 (P1023_OFFSET_FM + 0x00080400)
+#define P1023_OFFSET_FM_PRS                 (P1023_OFFSET_FM + 0x00080800)
+#define P1023_OFFSET_FM_PORT_HO0            (P1023_OFFSET_FM + 0x00081000)
+#define P1023_OFFSET_FM_PORT_HO1            (P1023_OFFSET_FM + 0x00082000)
+#define P1023_OFFSET_FM_PORT_HO2            (P1023_OFFSET_FM + 0x00083000)
+#define P1023_OFFSET_FM_PORT_HO3            (P1023_OFFSET_FM + 0x00084000)
+#define P1023_OFFSET_FM_PORT_HO4            (P1023_OFFSET_FM + 0x00085000)
+#define P1023_OFFSET_FM_PORT_1GRX0          (P1023_OFFSET_FM + 0x00088000)
+#define P1023_OFFSET_FM_PORT_1GRX1          (P1023_OFFSET_FM + 0x00089000)
+#define P1023_OFFSET_FM_PORT_1GTX0          (P1023_OFFSET_FM + 0x000A8000)
+#define P1023_OFFSET_FM_PORT_1GTX1          (P1023_OFFSET_FM + 0x000A9000)
+#define P1023_OFFSET_FM_PLCR                (P1023_OFFSET_FM + 0x000C0000)
+#define P1023_OFFSET_FM_KG                  (P1023_OFFSET_FM + 0x000C1000)
+#define P1023_OFFSET_FM_DMA                 (P1023_OFFSET_FM + 0x000C2000)
+#define P1023_OFFSET_FM_FPM                 (P1023_OFFSET_FM + 0x000C3000)
+#define P1023_OFFSET_FM_IRAM                (P1023_OFFSET_FM + 0x000C4000)
+#define P1023_OFFSET_FM_PRS_IRAM            (P1023_OFFSET_FM + 0x000C7000)
+#define P1023_OFFSET_FM_RISC0               (P1023_OFFSET_FM + 0x000D0000)
+#define P1023_OFFSET_FM_RISC1               (P1023_OFFSET_FM + 0x000D0400)
+#define P1023_OFFSET_FM_MACSEC              (P1023_OFFSET_FM + 0x000D8000)
+#define P1023_OFFSET_FM_1GMAC0              (P1023_OFFSET_FM + 0x000E0000)
+#define P1023_OFFSET_FM_1GMDIO0             (P1023_OFFSET_FM + 0x000E1120)
+#define P1023_OFFSET_FM_1GMAC1              (P1023_OFFSET_FM + 0x000E2000)
+#define P1023_OFFSET_FM_1GMDIO1             (P1023_OFFSET_FM + 0x000E3000)
+#define P1023_OFFSET_FM_RTC                 (P1023_OFFSET_FM + 0x000FE000)
+
+/* Offsets relative to QM or BM portals base */
+#define P1023_OFFSET_PORTALS_CE_AREA        0x00000000        /* cache enabled area */
+#define P1023_OFFSET_PORTALS_CI_AREA        0x00100000        /* cache inhibited area */
+
+#define P1023_OFFSET_PORTALS_CE(portal)     (P1023_OFFSET_PORTALS_CE_AREA + 0x4000 * (portal))
+#define P1023_OFFSET_PORTALS_CI(portal)     (P1023_OFFSET_PORTALS_CI_AREA + 0x1000 * (portal))
+
+/**************************************************************************//**
+ @Description   Transaction source ID (for memory controllers error reporting).
+*//***************************************************************************/
+typedef enum e_TransSrc
+{
+    e_TRANS_SRC_PCIE_2          = 0x01, /**< PCIe port 2                    */
+    e_TRANS_SRC_PCIE_1          = 0x02, /**< PCIe port 1                    */
+    e_TRANS_SRC_PCIE_3          = 0x03, /**< PCIe port 3                    */
+    e_TRANS_SRC_LBC             = 0x04, /**< Enhanced local bus             */
+    e_TRANS_SRC_DPAA_SW_PORTALS = 0x0E, /**< DPAA software portals or SRAM  */
+    e_TRANS_SRC_DDR             = 0x0F, /**< DDR controller                 */
+    e_TRANS_SRC_CORE_INS_FETCH  = 0x10, /**< Processor (instruction)        */
+    e_TRANS_SRC_CORE_DATA       = 0x11, /**< Processor (data)               */
+    e_TRANS_SRC_DMA             = 0x15  /**< DMA                            */
+} e_TransSrc;
+
+/**************************************************************************//**
+ @Description   Local Access Window Target interface ID
+*//***************************************************************************/
+typedef enum e_P1023LawTargetId
+{
+    e_P1023_LAW_TARGET_PCIE_2       = 0x01, /**< PCI Express 2 target interface */
+    e_P1023_LAW_TARGET_PCIE_1       = 0x02, /**< PCI Express 1 target interface */
+    e_P1023_LAW_TARGET_PCIE_3       = 0x03, /**< PCI Express 3 target interface */
+    e_P1023_LAW_TARGET_LBC          = 0x04, /**< Local bus target interface */
+    e_P1023_LAW_TARGET_QM_PORTALS   = 0x0E, /**< Queue Manager Portals */
+    e_P1023_LAW_TARGET_BM_PORTALS   = 0x0E, /**< Buffer Manager Portals */
+    e_P1023_LAW_TARGET_SRAM         = 0x0E, /**< SRAM scratchpad */
+    e_P1023_LAW_TARGET_DDR          = 0x0F, /**< DDR target interface */
+    e_P1023_LAW_TARGET_NONE         = 0xFF  /**< Invalid target interface */
+} e_P1023LawTargetId;
+
+
+/**************************************************************************//**
+ @Group         1023_init_grp P1023 Initialization Unit
+
+ @Description   P1023 initialization unit API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Part ID and revision number
+*//***************************************************************************/
+typedef enum e_P1023DeviceName
+{
+    e_P1023_REV_INVALID     = 0x00000000,       /**< Invalid revision */
+    e_SC1023_REV_1_0        = (int)0x80FC0010,  /**< SC1023 rev 1.0 */
+    e_SC1023_REV_1_1        = (int)0x80FC0011,  /**< SC1023 rev 1.1 */
+    e_P1023_REV_1_0         = (int)0x80FE0010,  /**< P1023 rev 1.0 with security */
+    e_P1023_REV_1_1         = (int)0x80FE0011,  /**< P1023 rev 1.1 with security */
+    e_P1017_REV_1_1         = (int)0x80FF0011,  /**< P1017 rev 1.1 with security */
+    e_P1023_REV_1_0_NO_SEC  = (int)0x80F60010,  /**< P1023 rev 1.0 without security */
+    e_P1023_REV_1_1_NO_SEC  = (int)0x80F60011,  /**< P1023 rev 1.1 without security */
+    e_P1017_REV_1_1_NO_SEC  = (int)0x80F70011   /**< P1017 rev 1.1 without security */
+} e_P1023DeviceName;
+
+/**************************************************************************//**
+ @Description   structure representing P1023 initialization parameters
+*//***************************************************************************/
+typedef struct t_P1023Params
+{
+    uintptr_t   ccsrBaseAddress;        /**< CCSR base address (virtual) */
+    uintptr_t   bmPortalsBaseAddress;   /**< Portals base address (virtual) */
+    uintptr_t   qmPortalsBaseAddress;   /**< Portals base address (virtual) */
+} t_P1023Params;
+
+/**************************************************************************//**
+ @Function      P1023_ConfigAndInit
+
+ @Description   General initiation of the chip registers.
+
+ @Param[in]     p_P1023Params  - A pointer to data structure of parameters
+
+ @Return        A handle to the P1023 data structure.
+*//***************************************************************************/
+t_Handle P1023_ConfigAndInit(t_P1023Params *p_P1023Params);
+
+/**************************************************************************//**
+ @Function      P1023_Free
+
+ @Description   Free all resources.
+
+ @Param         h_P1023 - (In) The handle of the initialized P1023 object.
+
+ @Return        E_OK on success; Other value otherwise.
+*//***************************************************************************/
+t_Error P1023_Free(t_Handle h_P1023);
+
+/**************************************************************************//**
+ @Function      P1023_GetRevInfo
+
+ @Description   This routine enables access to chip and revision information.
+
+ @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
+
+ @Return        Part ID and revision.
+*//***************************************************************************/
+e_P1023DeviceName P1023_GetRevInfo(uintptr_t gutilBase);
+
+/**************************************************************************//**
+ @Function      P1023_GetE500Factor
+
+ @Description   Returns E500 core clock multiplication factor.
+
+ @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
+ @Param[in]     coreId          - Id of the requested core.
+ @Param[out]    p_E500MulFactor - Returns E500 to CCB multification factor.
+ @Param[out]    p_E500DivFactor - Returns E500 to CCB division factor.
+
+ @Return        E_OK on success; Other value otherwise.
+*
+*//***************************************************************************/
+t_Error P1023_GetE500Factor(uintptr_t    gutilBase,
+                            uint32_t    coreId,
+                            uint32_t    *p_E500MulFactor,
+                            uint32_t    *p_E500DivFactor);
+
+/**************************************************************************//**
+ @Function      P1023_GetFmFactor
+
+ @Description   returns FM multiplication factors. (This value is returned using
+                two parameters to avoid using float parameter).
+
+ @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
+ @Param[out]    p_FmMulFactor   - returns E500 to CCB multification factor.
+ @Param[out]    p_FmDivFactor   - returns E500 to CCB division factor.
+
+ @Return        E_OK on success; Other value otherwise.
+*//***************************************************************************/
+t_Error  P1023_GetFmFactor(uintptr_t gutilBase, uint32_t *p_FmMulFactor, uint32_t *p_FmDivFactor);
+
+/**************************************************************************//**
+ @Function      P1023_GetCcbFactor
+
+ @Description   returns system multiplication factor.
+
+ @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
+
+ @Return        System multiplication factor.
+*//***************************************************************************/
+uint32_t P1023_GetCcbFactor(uintptr_t gutilBase);
+
+/**************************************************************************//**
+ @Function      P1023_GetDdrFactor
+
+ @Description   returns the multiplication factor of the clock in for the DDR clock .
+                Note: assumes the ddr_in_clk is identical to the sys_in_clk
+
+ @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
+ @Param         p_DdrMulFactor  - returns DDR in clk multification factor.
+ @Param         p_DdrDivFactor  - returns DDR division factor.
+
+ @Return        E_OK on success; Other value otherwise..
+*//***************************************************************************/
+t_Error P1023_GetDdrFactor( uintptr_t   gutilBase,
+                            uint32_t    *p_DdrMulFactor,
+                            uint32_t    *p_DdrDivFactor);
+
+
+
+/** @} */ /* end of 1023_init_grp group */
+/** @} */ /* end of 1023_grp group */
+
+#define CORE_E500V2
+
+
+/*****************************************************************************
+ LBC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+/**************************************************************************//**
+ @Group         lbc_exception_grp LBC Exception Unit
+
+ @Description   LBC Exception unit API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Anchor        lbc_exbm
+
+ @Collection    LBC Errors Bit Mask
+
+                These errors are reported through the exceptions callback..
+                The values can be or'ed in any combination in the errors mask
+                parameter of the errors report structure.
+
+                These errors can also be passed as a bit-mask to
+                LBC_EnableErrorChecking() or LBC_DisableErrorChecking(),
+                for enabling or disabling error checking.
+ @{
+*//***************************************************************************/
+#define LBC_ERR_BUS_MONITOR     0x80000000  /**< Bus monitor error */
+#define LBC_ERR_PARITY_ECC      0x20000000  /**< Parity error for GPCM/UPM */
+#define LBC_ERR_WRITE_PROTECT   0x04000000  /**< Write protection error */
+#define LBC_ERR_CHIP_SELECT     0x00080000  /**< Unrecognized chip select */
+
+#define LBC_ERR_ALL             (LBC_ERR_BUS_MONITOR | LBC_ERR_PARITY_ECC | \
+                                 LBC_ERR_WRITE_PROTECT | LBC_ERR_CHIP_SELECT)
+                                            /**< All possible errors */
+/* @} */
+/** @} */ /* end of lbc_exception_grp group */
+
+#define LBC_NUM_OF_BANKS            2
+#define LBC_MAX_CS_SIZE             0x0000000100000000LL
+#define LBC_ATOMIC_OPERATION_SUPPORT
+#define LBC_PARITY_SUPPORT
+#define LBC_ADDRESS_SHIFT_SUPPORT
+#define LBC_ADDRESS_HOLD_TIME_CTRL
+#define LBC_HIGH_CLK_DIVIDERS
+#define LBC_FCM_AVAILABLE
+
+
+/*****************************************************************************
+ LAW INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define LAW_ARCH_CCB
+#define LAW_NUM_OF_WINDOWS      12
+#define LAW_MIN_WINDOW_SIZE     0x0000000000001000LL    /**< 4KB */
+#define LAW_MAX_WINDOW_SIZE     0x0000001000000000LL    /**< 32GB */
+
+
+/*****************************************************************************
+ SPI INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define SPI_NUM_OF_CONTROLLERS      1
+
+/*****************************************************************************
+ PCI/PCIe INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+
+#define PCI_MAX_INBOUND_WINDOWS_NUM     4
+#define PCI_MAX_OUTBOUND_WINDOWS_NUM    5
+
+/**************************************************************************//**
+ @Description   Target interface of an inbound window
+*//***************************************************************************/
+typedef enum e_PciTargetInterface
+{
+    e_PCI_TARGET_PCIE_2         = 0x1,  /**<  PCI Express target interface 2 */
+    e_PCI_TARGET_PCIE_1         = 0x2,  /**<  PCI Express target interface 1 */
+    e_PCI_TARGET_PCIE_3         = 0x3,  /**<  PCI Express target interface 3 */
+    e_PCI_TARGET_LOCAL_MEMORY   = 0xF   /**<  Local Memory (DDR SDRAM, Local Bus, SRAM) target interface */
+
+} e_PciTargetInterface;
+
+/*****************************************************************************
+ DDR INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define DDR_NUM_OF_VALID_CS         2
+
+/*****************************************************************************
+ SEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define SEC_ERRATA_STAT_REGS_UNUSABLE
+
+/*****************************************************************************
+ DMA INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define DMA_NUM_OF_CONTROLLERS      2
+
+
+
+
+/*****************************************************************************
+ 1588 INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define PTP_V2
+
+/**************************************************************************//**
+ @Function      P1023_GetMuxControlReg
+
+ @Description   Returns the value of PMUXCR (Alternate Function Signal Multiplex
+                Control Register)
+
+ @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
+
+ @Return        Value of PMUXCR
+*//***************************************************************************/
+uint32_t P1023_GetMuxControlReg(uintptr_t gutilBase);
+
+/**************************************************************************//**
+ @Function      P1023_SetMuxControlReg
+
+ @Description   Sets the value of PMUXCR (Alternate Function Signal Multiplex
+                Control Register)
+
+ @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
+ @Param[in]     val         - the new value for PMUXCR.
+
+ @Return        None
+*//***************************************************************************/
+void P1023_SetMuxControlReg(uintptr_t gutilBase, uint32_t val);
+
+/**************************************************************************//**
+ @Function      P1023_GetDeviceDisableStatusRegister
+
+ @Description   Returns the value of DEVDISR (Device Disable Register)
+
+ @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
+
+ @Return        Value of DEVDISR
+*//***************************************************************************/
+uint32_t P1023_GetDeviceDisableStatusRegister(uintptr_t gutilBase);
+
+/**************************************************************************//**
+ @Function      P1023_GetPorDeviceStatusRegister
+
+ @Description   Returns the value of POR Device Status Register
+
+ @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
+
+ @Return        POR Device Status Register
+*//***************************************************************************/
+uint32_t P1023_GetPorDeviceStatusRegister(uintptr_t gutilBase);
+
+/**************************************************************************//**
+ @Function      P1023_GetPorBootModeStatusRegister
+
+ @Description   Returns the value of POR Boot Mode Status Register
+
+ @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
+
+ @Return        POR Boot Mode Status Register value
+*//***************************************************************************/
+uint32_t P1023_GetPorBootModeStatusRegister(uintptr_t gutilBase);
+
+
+#define PORDEVSR_SGMII1_DIS     0x10000000
+#define PORDEVSR_SGMII2_DIS     0x08000000
+#define PORDEVSR_ECP1           0x02000000
+#define PORDEVSR_IO_SEL         0x00780000
+#define PORDEVSR_IO_SEL_SHIFT   19
+#define PORBMSR_HA              0x00070000
+#define PORBMSR_HA_SHIFT        16
+
+#define DEVDISR_QM_BM           0x80000000
+#define DEVDISR_FM              0x40000000
+#define DEVDISR_PCIE1           0x20000000
+#define DEVDISR_MAC_SEC         0x10000000
+#define DEVDISR_ELBC            0x08000000
+#define DEVDISR_PCIE2           0x04000000
+#define DEVDISR_PCIE3           0x02000000
+#define DEVDISR_CAAM            0x01000000
+#define DEVDISR_USB0            0x00800000
+#define DEVDISR_1588            0x00020000
+#define DEVDISR_CORE0           0x00008000
+#define DEVDISR_TB0             0x00004000
+#define DEVDISR_CORE1           0x00002000
+#define DEVDISR_TB1             0x00001000
+#define DEVDISR_DMA1            0x00000400
+#define DEVDISR_DMA2            0x00000200
+#define DEVDISR_DDR             0x00000010
+#define DEVDISR_TSEC1           0x00000080
+#define DEVDISR_TSEC2           0x00000040
+#define DEVDISR_SPI             0x00000008
+#define DEVDISR_I2C             0x00000004
+#define DEVDISR_DUART           0x00000002
+
+#endif /* P1023 */
+
+#endif /* __PART_INTEGRATION_P1023_H */
--- fmlib-fslsdk-v1.7/include/fmd/integrations/part_P3_P4_P5.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/integrations/part_P3_P4_P5.h	2022-05-26 11:28:31.118971857 -0700
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          part_P3_P4_P5.h
+
+ @Description   Definitions for the part (integration) module.
+*//***************************************************************************/
+
+#ifndef __PART_P3_P4_P5_H
+#define __PART_P3_P4_P5_H
+
+/* P3/4/5 chip-specific defs. should go here. */
+
+#endif /* __PART_P3_P4_P5_H */
--- fmlib-fslsdk-v1.7/include/fmd/integrations/part_integration_P3_P4_P5.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/integrations/part_integration_P3_P4_P5.h	2022-05-26 11:28:31.118971857 -0700
@@ -0,0 +1,305 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          part_integration_P3_P4_P5.h
+
+ @Description   P4080/P5020/P3041 external definitions and structures.
+*//***************************************************************************/
+#ifndef __PART_INTEGRATION_P3_P4_P5_H
+#define __PART_INTEGRATION_P3_P4_P5_H
+
+#include "std_ext.h"
+#include "dpaa_integration_ext.h"
+
+#ifndef P1023
+
+/**************************************************************************//**
+ @Group         P3040/P4080/P5020_chip_id P5020 Application Programming Interface
+
+ @Description   P3040/P4080/P5020 Chip functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+#define CORE_E500MC
+
+#define INTG_MAX_NUM_OF_CORES   1
+#define CORE_GetId()            0
+#define CORE_IS_BIG_ENDIAN
+#define SYS_ANY_CORE    ((uint32_t)-1)  /**< Assignment to any valid core */
+#define SYS_IS_MASTER_CORE()    TRUE
+
+
+/**************************************************************************//**
+ @Description   Module types.
+*//***************************************************************************/
+typedef enum e_ModuleId
+{
+    e_MODULE_ID_DUART_1 = 0,
+    e_MODULE_ID_DUART_2,
+    e_MODULE_ID_DUART_3,
+    e_MODULE_ID_DUART_4,
+    e_MODULE_ID_LAW,
+    e_MODULE_ID_LBC,
+    e_MODULE_ID_PAMU,
+    e_MODULE_ID_QM,                 /**< Queue manager module */
+    e_MODULE_ID_BM,                 /**< Buffer manager module */
+    e_MODULE_ID_QM_CE_PORTAL_0,
+    e_MODULE_ID_QM_CI_PORTAL_0,
+    e_MODULE_ID_QM_CE_PORTAL_1,
+    e_MODULE_ID_QM_CI_PORTAL_1,
+    e_MODULE_ID_QM_CE_PORTAL_2,
+    e_MODULE_ID_QM_CI_PORTAL_2,
+    e_MODULE_ID_QM_CE_PORTAL_3,
+    e_MODULE_ID_QM_CI_PORTAL_3,
+    e_MODULE_ID_QM_CE_PORTAL_4,
+    e_MODULE_ID_QM_CI_PORTAL_4,
+    e_MODULE_ID_QM_CE_PORTAL_5,
+    e_MODULE_ID_QM_CI_PORTAL_5,
+    e_MODULE_ID_QM_CE_PORTAL_6,
+    e_MODULE_ID_QM_CI_PORTAL_6,
+    e_MODULE_ID_QM_CE_PORTAL_7,
+    e_MODULE_ID_QM_CI_PORTAL_7,
+    e_MODULE_ID_QM_CE_PORTAL_8,
+    e_MODULE_ID_QM_CI_PORTAL_8,
+    e_MODULE_ID_QM_CE_PORTAL_9,
+    e_MODULE_ID_QM_CI_PORTAL_9,
+    e_MODULE_ID_BM_CE_PORTAL_0,
+    e_MODULE_ID_BM_CI_PORTAL_0,
+    e_MODULE_ID_BM_CE_PORTAL_1,
+    e_MODULE_ID_BM_CI_PORTAL_1,
+    e_MODULE_ID_BM_CE_PORTAL_2,
+    e_MODULE_ID_BM_CI_PORTAL_2,
+    e_MODULE_ID_BM_CE_PORTAL_3,
+    e_MODULE_ID_BM_CI_PORTAL_3,
+    e_MODULE_ID_BM_CE_PORTAL_4,
+    e_MODULE_ID_BM_CI_PORTAL_4,
+    e_MODULE_ID_BM_CE_PORTAL_5,
+    e_MODULE_ID_BM_CI_PORTAL_5,
+    e_MODULE_ID_BM_CE_PORTAL_6,
+    e_MODULE_ID_BM_CI_PORTAL_6,
+    e_MODULE_ID_BM_CE_PORTAL_7,
+    e_MODULE_ID_BM_CI_PORTAL_7,
+    e_MODULE_ID_BM_CE_PORTAL_8,
+    e_MODULE_ID_BM_CI_PORTAL_8,
+    e_MODULE_ID_BM_CE_PORTAL_9,
+    e_MODULE_ID_BM_CI_PORTAL_9,
+    e_MODULE_ID_FM1,                /**< Frame manager #1 module */
+    e_MODULE_ID_FM1_RTC,            /**< FM Real-Time-Clock */
+    e_MODULE_ID_FM1_MURAM,          /**< FM Multi-User-RAM */
+    e_MODULE_ID_FM1_BMI,            /**< FM BMI block */
+    e_MODULE_ID_FM1_QMI,            /**< FM QMI block */
+    e_MODULE_ID_FM1_PRS,            /**< FM parser block */
+    e_MODULE_ID_FM1_PORT_HO0,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO1,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO2,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO3,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO4,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO5,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO6,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_1GRx0,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GRx1,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GRx2,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GRx3,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GRx4,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_10GRx0,    /**< FM Rx 10G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx0,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx1,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx2,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx3,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx4,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_10GTx0,    /**< FM Tx 10G MAC port block */
+    e_MODULE_ID_FM1_PLCR,           /**< FM Policer */
+    e_MODULE_ID_FM1_KG,             /**< FM Keygen */
+    e_MODULE_ID_FM1_DMA,            /**< FM DMA */
+    e_MODULE_ID_FM1_FPM,            /**< FM FPM */
+    e_MODULE_ID_FM1_IRAM,           /**< FM Instruction-RAM */
+    e_MODULE_ID_FM1_1GMDIO0,        /**< FM 1G MDIO MAC 0*/
+    e_MODULE_ID_FM1_1GMDIO1,        /**< FM 1G MDIO MAC 1*/
+    e_MODULE_ID_FM1_1GMDIO2,        /**< FM 1G MDIO MAC 2*/
+    e_MODULE_ID_FM1_1GMDIO3,        /**< FM 1G MDIO MAC 3*/
+    e_MODULE_ID_FM1_10GMDIO,        /**< FM 10G MDIO */
+    e_MODULE_ID_FM1_PRS_IRAM,       /**< FM SW-parser Instruction-RAM */
+    e_MODULE_ID_FM1_1GMAC0,         /**< FM 1G MAC #0 */
+    e_MODULE_ID_FM1_1GMAC1,         /**< FM 1G MAC #1 */
+    e_MODULE_ID_FM1_1GMAC2,         /**< FM 1G MAC #2 */
+    e_MODULE_ID_FM1_1GMAC3,         /**< FM 1G MAC #3 */
+    e_MODULE_ID_FM1_10GMAC0,        /**< FM 10G MAC #0 */
+
+    e_MODULE_ID_FM2,                /**< Frame manager #2 module */
+    e_MODULE_ID_FM2_RTC,            /**< FM Real-Time-Clock */
+    e_MODULE_ID_FM2_MURAM,          /**< FM Multi-User-RAM */
+    e_MODULE_ID_FM2_BMI,            /**< FM BMI block */
+    e_MODULE_ID_FM2_QMI,            /**< FM QMI block */
+    e_MODULE_ID_FM2_PRS,            /**< FM parser block */
+    e_MODULE_ID_FM2_PORT_HO0,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO1,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO2,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO3,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO4,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO5,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO6,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_1GRx0,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GRx1,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GRx2,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GRx3,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_10GRx0,    /**< FM Rx 10G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GTx0,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GTx1,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GTx2,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GTx3,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_10GTx0,    /**< FM Tx 10G MAC port block */
+    e_MODULE_ID_FM2_PLCR,           /**< FM Policer */
+    e_MODULE_ID_FM2_KG,             /**< FM Keygen */
+    e_MODULE_ID_FM2_DMA,            /**< FM DMA */
+    e_MODULE_ID_FM2_FPM,            /**< FM FPM */
+    e_MODULE_ID_FM2_IRAM,           /**< FM Instruction-RAM */
+    e_MODULE_ID_FM2_1GMDIO0,        /**< FM 1G MDIO MAC 0*/
+    e_MODULE_ID_FM2_1GMDIO1,        /**< FM 1G MDIO MAC 1*/
+    e_MODULE_ID_FM2_1GMDIO2,        /**< FM 1G MDIO MAC 2*/
+    e_MODULE_ID_FM2_1GMDIO3,        /**< FM 1G MDIO MAC 3*/
+    e_MODULE_ID_FM2_10GMDIO,        /**< FM 10G MDIO */
+    e_MODULE_ID_FM2_PRS_IRAM,       /**< FM SW-parser Instruction-RAM */
+    e_MODULE_ID_FM2_1GMAC0,         /**< FM 1G MAC #0 */
+    e_MODULE_ID_FM2_1GMAC1,         /**< FM 1G MAC #1 */
+    e_MODULE_ID_FM2_1GMAC2,         /**< FM 1G MAC #2 */
+    e_MODULE_ID_FM2_1GMAC3,         /**< FM 1G MAC #3 */
+    e_MODULE_ID_FM2_10GMAC0,        /**< FM 10G MAC #0 */
+
+    e_MODULE_ID_SEC_GEN,            /**< SEC 4.0 General registers      */
+    e_MODULE_ID_SEC_QI,             /**< SEC 4.0 QI registers           */
+    e_MODULE_ID_SEC_JQ0,            /**< SEC 4.0 JQ-0 registers         */
+    e_MODULE_ID_SEC_JQ1,            /**< SEC 4.0 JQ-1 registers         */
+    e_MODULE_ID_SEC_JQ2,            /**< SEC 4.0 JQ-2 registers         */
+    e_MODULE_ID_SEC_JQ3,            /**< SEC 4.0 JQ-3 registers         */
+    e_MODULE_ID_SEC_RTIC,           /**< SEC 4.0 RTIC registers         */
+    e_MODULE_ID_SEC_DECO0_CCB0,     /**< SEC 4.0 DECO-0/CCB-0 registers */
+    e_MODULE_ID_SEC_DECO1_CCB1,     /**< SEC 4.0 DECO-1/CCB-1 registers */
+    e_MODULE_ID_SEC_DECO2_CCB2,     /**< SEC 4.0 DECO-2/CCB-2 registers */
+    e_MODULE_ID_SEC_DECO3_CCB3,     /**< SEC 4.0 DECO-3/CCB-3 registers */
+    e_MODULE_ID_SEC_DECO4_CCB4,     /**< SEC 4.0 DECO-4/CCB-4 registers */
+
+    e_MODULE_ID_MPIC,               /**< MPIC */
+    e_MODULE_ID_GPIO,               /**< GPIO */
+    e_MODULE_ID_SERDES,             /**< SERDES */
+    e_MODULE_ID_CPC_1,              /**< CoreNet-Platform-Cache 1 */
+    e_MODULE_ID_CPC_2,              /**< CoreNet-Platform-Cache 2 */
+
+    e_MODULE_ID_SRIO_PORTS,     	/**< RapidIO controller */
+    e_MODULE_ID_SRIO_MU,        	/**< RapidIO messaging unit module */
+
+    e_MODULE_ID_DUMMY_LAST
+} e_ModuleId;
+
+#define NUM_OF_MODULES  e_MODULE_ID_DUMMY_LAST
+
+
+/*****************************************************************************
+ PAMU INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define PAMU_NUM_OF_PARTITIONS  5
+
+#define PAMU_PICS_AVICS_ERRATA_PAMU3
+
+/*****************************************************************************
+ LAW INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define LAW_NUM_OF_WINDOWS      32
+#define LAW_MIN_WINDOW_SIZE     0x0000000000001000LL    /**< 4KB */
+#define LAW_MAX_WINDOW_SIZE     0x0000002000000000LL    /**< 64GB */
+
+
+/*****************************************************************************
+ LBC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+/**************************************************************************//**
+ @Group         lbc_exception_grp LBC Exception Unit
+
+ @Description   LBC Exception unit API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Anchor        lbc_exbm
+
+ @Collection    LBC Errors Bit Mask
+
+                These errors are reported through the exceptions callback..
+                The values can be or'ed in any combination in the errors mask
+                parameter of the errors report structure.
+
+                These errors can also be passed as a bit-mask to
+                LBC_EnableErrorChecking() or LBC_DisableErrorChecking(),
+                for enabling or disabling error checking.
+ @{
+*//***************************************************************************/
+#define LBC_ERR_BUS_MONITOR     0x80000000  /**< Bus monitor error */
+#define LBC_ERR_PARITY_ECC      0x20000000  /**< Parity error for GPCM/UPM */
+#define LBC_ERR_WRITE_PROTECT   0x04000000  /**< Write protection error */
+#define LBC_ERR_ATOMIC_WRITE    0x00800000  /**< Atomic write error */
+#define LBC_ERR_ATOMIC_READ     0x00400000  /**< Atomic read error */
+#define LBC_ERR_CHIP_SELECT     0x00080000  /**< Unrecognized chip select */
+
+#define LBC_ERR_ALL             (LBC_ERR_BUS_MONITOR | LBC_ERR_PARITY_ECC | \
+                                 LBC_ERR_WRITE_PROTECT | LBC_ERR_ATOMIC_WRITE | \
+                                 LBC_ERR_ATOMIC_READ | LBC_ERR_CHIP_SELECT)
+                                            /**< All possible errors */
+/* @} */
+/** @} */ /* end of lbc_exception_grp group */
+
+#define LBC_INCORRECT_ERROR_REPORT_ERRATA
+
+#define LBC_NUM_OF_BANKS            8
+#define LBC_MAX_CS_SIZE             0x0000000100000000LL
+#define LBC_ATOMIC_OPERATION_SUPPORT
+#define LBC_PARITY_SUPPORT
+#define LBC_ADDRESS_HOLD_TIME_CTRL
+#define LBC_HIGH_CLK_DIVIDERS
+#define LBC_FCM_AVAILABLE
+
+/*****************************************************************************
+ GPIO INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define GPIO_NUM_OF_PORTS   1   /**< Number of ports in GPIO module;
+                                     Each port contains up to 32 i/O pins. */
+
+#define GPIO_VALID_PIN_MASKS  \
+    { /* Port A */ 0xFFFFFFFF }
+
+#define GPIO_VALID_INTR_MASKS \
+    { /* Port A */ 0xFFFFFFFF }
+
+#endif /* P1023 */
+
+#endif /* __PART_INTEGRATION_P3_P4_P5_H */
--- fmlib-fslsdk-v1.7/include/fmd/integrations/dpaa_integration_P1023.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/integrations/dpaa_integration_P1023.h	2022-05-26 11:28:31.110972185 -0700
@@ -0,0 +1,329 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          dpaa_integration_P1023.h
+
+ @Description   P1023 FM external definitions and structures.
+*//***************************************************************************/
+#ifndef __DPAA_INTEGRATION_P1023_H
+#define __DPAA_INTEGRATION_P1023_H
+
+#include "std_ext.h"
+
+#ifdef P1023
+
+#define CONFIG_FMAN_P1023
+#define DPAA_VERSION 10
+
+typedef enum e_DpaaSwPortal {
+    e_DPAA_SWPORTAL0 = 0,
+    e_DPAA_SWPORTAL1,
+    e_DPAA_SWPORTAL2,
+    e_DPAA_SWPORTAL_DUMMY_LAST
+} e_DpaaSwPortal;
+
+typedef enum {
+    e_DPAA_DCPORTAL0 = 0,
+    e_DPAA_DCPORTAL2,
+    e_DPAA_DCPORTAL_DUMMY_LAST
+} e_DpaaDcPortal;
+
+#define DPAA_MAX_NUM_OF_SW_PORTALS      e_DPAA_SWPORTAL_DUMMY_LAST
+#define DPAA_MAX_NUM_OF_DC_PORTALS      e_DPAA_DCPORTAL_DUMMY_LAST
+
+/*****************************************************************************
+ QMAN INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define QM_MAX_NUM_OF_POOL_CHANNELS 3
+#define QM_MAX_NUM_OF_WQ            8
+#define QM_MAX_NUM_OF_SWP_AS        2
+#define QM_MAX_NUM_OF_CGS           64
+#define QM_MAX_NUM_OF_FQIDS         (16*MEGABYTE)
+
+typedef enum {
+    e_QM_FQ_CHANNEL_SWPORTAL0 = 0,
+    e_QM_FQ_CHANNEL_SWPORTAL1,
+    e_QM_FQ_CHANNEL_SWPORTAL2,
+
+    e_QM_FQ_CHANNEL_POOL1 = 0x21,
+    e_QM_FQ_CHANNEL_POOL2,
+    e_QM_FQ_CHANNEL_POOL3,
+
+    e_QM_FQ_CHANNEL_FMAN0_SP0 = 0x40,
+    e_QM_FQ_CHANNEL_FMAN0_SP1,
+    e_QM_FQ_CHANNEL_FMAN0_SP2,
+    e_QM_FQ_CHANNEL_FMAN0_SP3,
+    e_QM_FQ_CHANNEL_FMAN0_SP4,
+    e_QM_FQ_CHANNEL_FMAN0_SP5,
+    e_QM_FQ_CHANNEL_FMAN0_SP6,
+
+
+    e_QM_FQ_CHANNEL_CAAM = 0x80
+} e_QmFQChannel;
+
+/*****************************************************************************
+ BMAN INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define BM_MAX_NUM_OF_POOLS         8
+
+/*****************************************************************************
+ SEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define SEC_NUM_OF_DECOS    2
+#define SEC_ALL_DECOS_MASK  0x00000003
+
+/*****************************************************************************
+ FM INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define INTG_MAX_NUM_OF_FM          1
+
+/* Ports defines */
+#define FM_MAX_NUM_OF_1G_RX_PORTS   2
+#define FM_MAX_NUM_OF_10G_RX_PORTS  0
+#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS+FM_MAX_NUM_OF_1G_RX_PORTS)
+#define FM_MAX_NUM_OF_1G_TX_PORTS   2
+#define FM_MAX_NUM_OF_10G_TX_PORTS  0
+#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS+FM_MAX_NUM_OF_1G_TX_PORTS)
+#define FM_MAX_NUM_OF_OH_PORTS      5
+#define FM_MAX_NUM_OF_1G_MACS       (FM_MAX_NUM_OF_1G_RX_PORTS)
+#define FM_MAX_NUM_OF_10G_MACS      (FM_MAX_NUM_OF_10G_RX_PORTS)
+#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS+FM_MAX_NUM_OF_10G_MACS)
+#define FM_MAX_NUM_OF_MACSECS       1
+
+#define FM_MACSEC_SUPPORT
+#define FM_DISABLE_SEC_ERRORS
+
+#define FM_LOW_END_RESTRICTION      /* prevents the use of TX port 1 with OP port 0 */
+
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS            4           /**< Number of external BM pools per Rx port */
+#define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   2           /**< Number of Offline parsing port external BM pools per Rx port */
+#define FM_PORT_NUM_OF_CONGESTION_GRPS          32          /**< Total number of congestion groups in QM */
+#define FM_MAX_NUM_OF_SUB_PORTALS               7
+
+/* Rams defines */
+#define FM_MURAM_SIZE               (64*KILOBYTE)
+#define FM_IRAM_SIZE                (32*KILOBYTE)
+
+/* PCD defines */
+#define FM_PCD_PLCR_NUM_ENTRIES         32                  /**< Total number of policer profiles */
+#define FM_PCD_KG_NUM_OF_SCHEMES        16                  /**< Total number of KG schemes */
+#define FM_PCD_MAX_NUM_OF_CLS_PLANS     128                 /**< Number of classification plan entries. */
+
+/* RTC defines */
+#define FM_RTC_NUM_OF_ALARMS            2
+#define FM_RTC_NUM_OF_PERIODIC_PULSES   2
+#define FM_RTC_NUM_OF_EXT_TRIGGERS      2
+
+/* QMI defines */
+#define QMI_MAX_NUM_OF_TNUMS            15
+
+/* FPM defines */
+#define FM_NUM_OF_FMAN_CTRL_EVENT_REGS  4
+
+/* DMA defines */
+#define DMA_THRESH_MAX_COMMQ            15
+#define DMA_THRESH_MAX_BUF              7
+
+/* BMI defines */
+#define BMI_MAX_NUM_OF_TASKS            64
+#define BMI_MAX_NUM_OF_DMAS             16
+#define BMI_MAX_FIFO_SIZE              (FM_MURAM_SIZE)
+#define PORT_MAX_WEIGHT                 4
+
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+typedef enum e_FmEventModules{
+    e_FM_MOD_PRS,                   /**< Parser event */
+    e_FM_MOD_KG,                    /**< Keygen event */
+    e_FM_MOD_PLCR,                  /**< Policer event */
+    e_FM_MOD_10G_MAC,               /**< 10G MAC  error event */
+    e_FM_MOD_1G_MAC,                /**< 1G MAC  error event */
+    e_FM_MOD_TMR,                   /**< Timer event */
+    e_FM_MOD_1G_MAC_TMR,            /**< 1G MAC  Timer event */
+    e_FM_MOD_FMAN_CTRL,             /**< FMAN Controller  Timer event */
+    e_FM_MOD_MACSEC,
+    e_FM_MOD_DUMMY_LAST
+} e_FmEventModules;
+
+/**************************************************************************//**
+ @Description   Enum for interrupts types
+*//***************************************************************************/
+typedef enum e_FmIntrType {
+    e_FM_INTR_TYPE_ERR,
+    e_FM_INTR_TYPE_NORMAL
+} e_FmIntrType;
+
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+typedef enum e_FmInterModuleEvent {
+    e_FM_EV_PRS,                    /**< Parser event */
+    e_FM_EV_ERR_PRS,                /**< Parser error event */
+    e_FM_EV_KG,                     /**< Keygen event */
+    e_FM_EV_ERR_KG,                 /**< Keygen error event */
+    e_FM_EV_PLCR,                   /**< Policer event */
+    e_FM_EV_ERR_PLCR,               /**< Policer error event */
+    e_FM_EV_ERR_10G_MAC0,           /**< 10G MAC 0 error event */
+    e_FM_EV_ERR_1G_MAC0,            /**< 1G MAC 0 error event */
+    e_FM_EV_ERR_1G_MAC1,            /**< 1G MAC 1 error event */
+    e_FM_EV_ERR_1G_MAC2,            /**< 1G MAC 2 error event */
+    e_FM_EV_ERR_1G_MAC3,            /**< 1G MAC 3 error event */
+    e_FM_EV_ERR_MACSEC_MAC0,        /**< MACSEC MAC 0 error event */
+    e_FM_EV_TMR,                    /**< Timer event */
+    e_FM_EV_1G_MAC0_TMR,            /**< 1G MAC 0 Timer event */
+    e_FM_EV_1G_MAC1_TMR,            /**< 1G MAC 1 Timer event */
+    e_FM_EV_1G_MAC2_TMR,            /**< 1G MAC 2 Timer event */
+    e_FM_EV_1G_MAC3_TMR,            /**< 1G MAC 3 Timer event */
+    e_FM_EV_MACSEC_MAC0,            /**< MACSEC MAC 0 event */
+    e_FM_EV_FMAN_CTRL_0,            /**< Fman controller event 0 */
+    e_FM_EV_FMAN_CTRL_1,            /**< Fman controller event 1 */
+    e_FM_EV_FMAN_CTRL_2,            /**< Fman controller event 2 */
+    e_FM_EV_FMAN_CTRL_3,            /**< Fman controller event 3 */
+    e_FM_EV_DUMMY_LAST
+} e_FmInterModuleEvent;
+
+#define GET_FM_MODULE_EVENT(mod, id, intrType, event)                                                  \
+    switch(mod){                                                                                    \
+        case e_FM_MOD_PRS:                                                                          \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PRS:e_FM_EV_PRS;            \
+            break;                                                                                  \
+        case e_FM_MOD_KG:                                                                           \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_KG:e_FM_EV_DUMMY_LAST;      \
+            break;                                                                                  \
+        case e_FM_MOD_PLCR:                                                                         \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PLCR:e_FM_EV_PLCR;          \
+            break;                                                                                  \
+        case e_FM_MOD_1G_MAC:                                                                       \
+            switch(id){                                                                             \
+                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC0:e_FM_EV_DUMMY_LAST; break; \
+                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC1:e_FM_EV_DUMMY_LAST; break;    \
+                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC2:e_FM_EV_DUMMY_LAST; break;    \
+                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC3:e_FM_EV_DUMMY_LAST; break;    \
+                 }                                                                                  \
+            break;                                                                                  \
+        case e_FM_MOD_TMR:                                                                          \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_TMR;         \
+            break;                                                                                  \
+        case e_FM_MOD_1G_MAC_TMR:                                                                   \
+            switch(id){                                                                             \
+                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC0_TMR; break; \
+                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC1_TMR; break; \
+                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC2_TMR; break; \
+                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC3_TMR; break; \
+                 }                                                                                  \
+            break;                                                                                  \
+        case e_FM_MOD_MACSEC:                                                                   \
+            switch(id){                                                                             \
+                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_MACSEC_MAC0:e_FM_EV_MACSEC_MAC0; break; \
+                 }                                                                                  \
+            break;                                                                                  \
+        case e_FM_MOD_FMAN_CTRL:                                                                    \
+            if (intrType == e_FM_INTR_TYPE_ERR) event = e_FM_EV_DUMMY_LAST;                         \
+            else switch(id){                                                                        \
+                 case(0): event = e_FM_EV_FMAN_CTRL_0; break;                                       \
+                 case(1): event = e_FM_EV_FMAN_CTRL_1; break;                                       \
+                 case(2): event = e_FM_EV_FMAN_CTRL_2; break;                                       \
+                 case(3): event = e_FM_EV_FMAN_CTRL_3; break;                                       \
+                 }                                                                                  \
+            break;                                                                                  \
+        default:event = e_FM_EV_DUMMY_LAST;                                                         \
+        break;}
+
+/*****************************************************************************
+ FM MACSEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define NUM_OF_RX_SC                16
+#define NUM_OF_TX_SC                16
+
+#define NUM_OF_SA_PER_RX_SC         2
+#define NUM_OF_SA_PER_TX_SC         2
+
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+
+typedef enum e_FmMacsecEventModules{
+    e_FM_MACSEC_MOD_SC_TX,
+    e_FM_MACSEC_MOD_DUMMY_LAST
+} e_FmMacsecEventModules;
+
+typedef enum e_FmMacsecInterModuleEvent {
+    e_FM_MACSEC_EV_SC_TX,
+    e_FM_MACSEC_EV_ERR_SC_TX,
+    e_FM_MACSEC_EV_DUMMY_LAST
+} e_FmMacsecInterModuleEvent;
+
+#define NUM_OF_INTER_MODULE_EVENTS (NUM_OF_TX_SC * 2)
+
+#define GET_MACSEC_MODULE_EVENT(mod, id, intrType, event) \
+    switch(mod){                                          \
+        case e_FM_MACSEC_MOD_SC_TX:                       \
+             event = (intrType == e_FM_INTR_TYPE_ERR) ?   \
+                        e_FM_MACSEC_EV_ERR_SC_TX:         \
+                        e_FM_MACSEC_EV_SC_TX;             \
+             event += (uint8_t)(2 * id);break;            \
+            break;                                        \
+        default:event = e_FM_MACSEC_EV_DUMMY_LAST;        \
+        break;}
+
+
+/* 1023 unique features */
+#define FM_QMI_NO_ECC_EXCEPTIONS
+#define FM_CSI_CFED_LIMIT
+#define FM_PEDANTIC_DMA
+#define FM_QMI_NO_DEQ_OPTIONS_SUPPORT
+#define FM_FIFO_ALLOCATION_ALG
+#define FM_DEQ_PIPELINE_PARAMS_FOR_OP
+#define FM_HAS_TOTAL_DMAS
+#define FM_KG_NO_IPPID_SUPPORT
+#define FM_NO_GUARANTEED_RESET_VALUES
+#define FM_MAC_RESET
+
+/* FM erratas */
+#define FM_RX_PREAM_4_ERRATA_DTSEC_A001
+#define FM_MAGIC_PACKET_UNRECOGNIZED_ERRATA_DTSEC2      /* No implementation */
+
+#define FM_DEBUG_TRACE_FMAN_A004                        /* No implementation */
+#define FM_INT_BUF_LEAK_FMAN_A005                       /* No implementation. App must avoid S/G */
+
+
+#define FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
+
+#endif /* P1023 */
+
+#endif /* __FM_INTEGRATION_P1023_H */
--- fmlib-fslsdk-v1.7/include/fmd/net_ext.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/net_ext.h	2022-05-26 11:28:31.134971204 -0700
@@ -0,0 +1,429 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          net_ext.h
+
+ @Description   This file contains common and general netcomm headers definitions.
+*//***************************************************************************/
+#ifndef __NET_EXT_H
+#define __NET_EXT_H
+
+#include "std_ext.h"
+
+
+typedef uint8_t headerFieldPpp_t;
+
+#define NET_HEADER_FIELD_PPP_PID                        (1)
+#define NET_HEADER_FIELD_PPP_COMPRESSED                 (NET_HEADER_FIELD_PPP_PID << 1)
+#define NET_HEADER_FIELD_PPP_ALL_FIELDS                 ((NET_HEADER_FIELD_PPP_PID << 2) - 1)
+
+
+typedef uint8_t headerFieldPppoe_t;
+
+#define NET_HEADER_FIELD_PPPoE_VER                      (1)
+#define NET_HEADER_FIELD_PPPoE_TYPE                     (NET_HEADER_FIELD_PPPoE_VER << 1)
+#define NET_HEADER_FIELD_PPPoE_CODE                     (NET_HEADER_FIELD_PPPoE_VER << 2)
+#define NET_HEADER_FIELD_PPPoE_SID                      (NET_HEADER_FIELD_PPPoE_VER << 3)
+#define NET_HEADER_FIELD_PPPoE_LEN                      (NET_HEADER_FIELD_PPPoE_VER << 4)
+#define NET_HEADER_FIELD_PPPoE_SESSION                  (NET_HEADER_FIELD_PPPoE_VER << 5)
+#define NET_HEADER_FIELD_PPPoE_PID                      (NET_HEADER_FIELD_PPPoE_VER << 6)
+#define NET_HEADER_FIELD_PPPoE_ALL_FIELDS               ((NET_HEADER_FIELD_PPPoE_VER << 7) - 1)
+
+#define NET_HEADER_FIELD_PPPMUX_PID                     (1)
+#define NET_HEADER_FIELD_PPPMUX_CKSUM                   (NET_HEADER_FIELD_PPPMUX_PID << 1)
+#define NET_HEADER_FIELD_PPPMUX_COMPRESSED              (NET_HEADER_FIELD_PPPMUX_PID << 2)
+#define NET_HEADER_FIELD_PPPMUX_ALL_FIELDS              ((NET_HEADER_FIELD_PPPMUX_PID << 3) - 1)
+
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF            (1)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_LXT            (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 1)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_LEN            (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 2)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_PID            (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 3)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_USE_PID        (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 4)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_ALL_FIELDS     ((NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 5) - 1)
+
+
+typedef uint8_t headerFieldEth_t;
+
+#define NET_HEADER_FIELD_ETH_DA                         (1)
+#define NET_HEADER_FIELD_ETH_SA                         (NET_HEADER_FIELD_ETH_DA << 1)
+#define NET_HEADER_FIELD_ETH_LENGTH                     (NET_HEADER_FIELD_ETH_DA << 2)
+#define NET_HEADER_FIELD_ETH_TYPE                       (NET_HEADER_FIELD_ETH_DA << 3)
+#define NET_HEADER_FIELD_ETH_FINAL_CKSUM                (NET_HEADER_FIELD_ETH_DA << 4)
+#define NET_HEADER_FIELD_ETH_PADDING                    (NET_HEADER_FIELD_ETH_DA << 5)
+#define NET_HEADER_FIELD_ETH_ALL_FIELDS                 ((NET_HEADER_FIELD_ETH_DA << 6) - 1)
+
+#define NET_HEADER_FIELD_ETH_ADDR_SIZE                 6
+
+typedef uint16_t headerFieldIp_t;
+
+#define NET_HEADER_FIELD_IP_VER                         (1)
+#define NET_HEADER_FIELD_IP_DSCP                        (NET_HEADER_FIELD_IP_VER << 2)
+#define NET_HEADER_FIELD_IP_ECN                         (NET_HEADER_FIELD_IP_VER << 3)
+#define NET_HEADER_FIELD_IP_PROTO                       (NET_HEADER_FIELD_IP_VER << 4)
+
+#define NET_HEADER_FIELD_IP_PROTO_SIZE                  1
+
+typedef uint16_t headerFieldIpv4_t;
+
+#define NET_HEADER_FIELD_IPv4_VER                       (1)
+#define NET_HEADER_FIELD_IPv4_HDR_LEN                   (NET_HEADER_FIELD_IPv4_VER << 1)
+#define NET_HEADER_FIELD_IPv4_TOS                       (NET_HEADER_FIELD_IPv4_VER << 2)
+#define NET_HEADER_FIELD_IPv4_TOTAL_LEN                 (NET_HEADER_FIELD_IPv4_VER << 3)
+#define NET_HEADER_FIELD_IPv4_ID                        (NET_HEADER_FIELD_IPv4_VER << 4)
+#define NET_HEADER_FIELD_IPv4_FLAG_D                    (NET_HEADER_FIELD_IPv4_VER << 5)
+#define NET_HEADER_FIELD_IPv4_FLAG_M                    (NET_HEADER_FIELD_IPv4_VER << 6)
+#define NET_HEADER_FIELD_IPv4_OFFSET                    (NET_HEADER_FIELD_IPv4_VER << 7)
+#define NET_HEADER_FIELD_IPv4_TTL                       (NET_HEADER_FIELD_IPv4_VER << 8)
+#define NET_HEADER_FIELD_IPv4_PROTO                     (NET_HEADER_FIELD_IPv4_VER << 9)
+#define NET_HEADER_FIELD_IPv4_CKSUM                     (NET_HEADER_FIELD_IPv4_VER << 10)
+#define NET_HEADER_FIELD_IPv4_SRC_IP                    (NET_HEADER_FIELD_IPv4_VER << 11)
+#define NET_HEADER_FIELD_IPv4_DST_IP                    (NET_HEADER_FIELD_IPv4_VER << 12)
+#define NET_HEADER_FIELD_IPv4_OPTS                      (NET_HEADER_FIELD_IPv4_VER << 13)
+#define NET_HEADER_FIELD_IPv4_OPTS_COUNT                (NET_HEADER_FIELD_IPv4_VER << 14)
+#define NET_HEADER_FIELD_IPv4_ALL_FIELDS                ((NET_HEADER_FIELD_IPv4_VER << 15) - 1)
+
+#define NET_HEADER_FIELD_IPv4_ADDR_SIZE                 4
+#define NET_HEADER_FIELD_IPv4_PROTO_SIZE                1
+
+
+typedef uint8_t headerFieldIpv6_t;
+
+#define NET_HEADER_FIELD_IPv6_VER                       (1)
+#define NET_HEADER_FIELD_IPv6_TC                        (NET_HEADER_FIELD_IPv6_VER << 1)
+#define NET_HEADER_FIELD_IPv6_SRC_IP                    (NET_HEADER_FIELD_IPv6_VER << 2)
+#define NET_HEADER_FIELD_IPv6_DST_IP                    (NET_HEADER_FIELD_IPv6_VER << 3)
+#define NET_HEADER_FIELD_IPv6_NEXT_HDR                  (NET_HEADER_FIELD_IPv6_VER << 4)
+#define NET_HEADER_FIELD_IPv6_FL                        (NET_HEADER_FIELD_IPv6_VER << 5)
+#define NET_HEADER_FIELD_IPv6_HOP_LIMIT                 (NET_HEADER_FIELD_IPv6_VER << 6)
+#define NET_HEADER_FIELD_IPv6_ALL_FIELDS                ((NET_HEADER_FIELD_IPv6_VER << 7) - 1)
+
+#define NET_HEADER_FIELD_IPv6_ADDR_SIZE                 16
+#define NET_HEADER_FIELD_IPv6_NEXT_HDR_SIZE             1
+
+#define NET_HEADER_FIELD_ICMP_TYPE                      (1)
+#define NET_HEADER_FIELD_ICMP_CODE                      (NET_HEADER_FIELD_ICMP_TYPE << 1)
+#define NET_HEADER_FIELD_ICMP_CKSUM                     (NET_HEADER_FIELD_ICMP_TYPE << 2)
+#define NET_HEADER_FIELD_ICMP_ID                        (NET_HEADER_FIELD_ICMP_TYPE << 3)
+#define NET_HEADER_FIELD_ICMP_SQ_NUM                    (NET_HEADER_FIELD_ICMP_TYPE << 4)
+#define NET_HEADER_FIELD_ICMP_ALL_FIELDS                ((NET_HEADER_FIELD_ICMP_TYPE << 5) - 1)
+
+#define NET_HEADER_FIELD_ICMP_CODE_SIZE                 1
+#define NET_HEADER_FIELD_ICMP_TYPE_SIZE                 1
+
+#define NET_HEADER_FIELD_IGMP_VERSION                   (1)
+#define NET_HEADER_FIELD_IGMP_TYPE                      (NET_HEADER_FIELD_IGMP_VERSION << 1)
+#define NET_HEADER_FIELD_IGMP_CKSUM                     (NET_HEADER_FIELD_IGMP_VERSION << 2)
+#define NET_HEADER_FIELD_IGMP_DATA                      (NET_HEADER_FIELD_IGMP_VERSION << 3)
+#define NET_HEADER_FIELD_IGMP_ALL_FIELDS                ((NET_HEADER_FIELD_IGMP_VERSION << 4) - 1)
+
+
+typedef uint16_t headerFieldTcp_t;
+
+#define NET_HEADER_FIELD_TCP_PORT_SRC                   (1)
+#define NET_HEADER_FIELD_TCP_PORT_DST                   (NET_HEADER_FIELD_TCP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_TCP_SEQ                        (NET_HEADER_FIELD_TCP_PORT_SRC << 2)
+#define NET_HEADER_FIELD_TCP_ACK                        (NET_HEADER_FIELD_TCP_PORT_SRC << 3)
+#define NET_HEADER_FIELD_TCP_OFFSET                     (NET_HEADER_FIELD_TCP_PORT_SRC << 4)
+#define NET_HEADER_FIELD_TCP_FLAGS                      (NET_HEADER_FIELD_TCP_PORT_SRC << 5)
+#define NET_HEADER_FIELD_TCP_WINDOW                     (NET_HEADER_FIELD_TCP_PORT_SRC << 6)
+#define NET_HEADER_FIELD_TCP_CKSUM                      (NET_HEADER_FIELD_TCP_PORT_SRC << 7)
+#define NET_HEADER_FIELD_TCP_URGPTR                     (NET_HEADER_FIELD_TCP_PORT_SRC << 8)
+#define NET_HEADER_FIELD_TCP_OPTS                       (NET_HEADER_FIELD_TCP_PORT_SRC << 9)
+#define NET_HEADER_FIELD_TCP_OPTS_COUNT                 (NET_HEADER_FIELD_TCP_PORT_SRC << 10)
+#define NET_HEADER_FIELD_TCP_ALL_FIELDS                 ((NET_HEADER_FIELD_TCP_PORT_SRC << 11) - 1)
+
+#define NET_HEADER_FIELD_TCP_PORT_SIZE                  2
+
+
+typedef uint8_t headerFieldSctp_t;
+
+#define NET_HEADER_FIELD_SCTP_PORT_SRC                  (1)
+#define NET_HEADER_FIELD_SCTP_PORT_DST                  (NET_HEADER_FIELD_SCTP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_SCTP_VER_TAG                   (NET_HEADER_FIELD_SCTP_PORT_SRC << 2)
+#define NET_HEADER_FIELD_SCTP_CKSUM                     (NET_HEADER_FIELD_SCTP_PORT_SRC << 3)
+#define NET_HEADER_FIELD_SCTP_ALL_FIELDS                ((NET_HEADER_FIELD_SCTP_PORT_SRC << 4) - 1)
+
+#define NET_HEADER_FIELD_SCTP_PORT_SIZE                 2
+
+typedef uint8_t headerFieldDccp_t;
+
+#define NET_HEADER_FIELD_DCCP_PORT_SRC                  (1)
+#define NET_HEADER_FIELD_DCCP_PORT_DST                  (NET_HEADER_FIELD_DCCP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_DCCP_ALL_FIELDS                ((NET_HEADER_FIELD_DCCP_PORT_SRC << 2) - 1)
+
+#define NET_HEADER_FIELD_DCCP_PORT_SIZE                 2
+
+
+typedef uint8_t headerFieldUdp_t;
+
+#define NET_HEADER_FIELD_UDP_PORT_SRC                   (1)
+#define NET_HEADER_FIELD_UDP_PORT_DST                   (NET_HEADER_FIELD_UDP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_UDP_LEN                        (NET_HEADER_FIELD_UDP_PORT_SRC << 2)
+#define NET_HEADER_FIELD_UDP_CKSUM                      (NET_HEADER_FIELD_UDP_PORT_SRC << 3)
+#define NET_HEADER_FIELD_UDP_ALL_FIELDS                 ((NET_HEADER_FIELD_UDP_PORT_SRC << 4) - 1)
+
+#define NET_HEADER_FIELD_UDP_PORT_SIZE                  2
+
+typedef uint8_t headerFieldUdpLite_t;
+
+#define NET_HEADER_FIELD_UDP_LITE_PORT_SRC              (1)
+#define NET_HEADER_FIELD_UDP_LITE_PORT_DST              (NET_HEADER_FIELD_UDP_LITE_PORT_SRC << 1)
+#define NET_HEADER_FIELD_UDP_LITE_ALL_FIELDS            ((NET_HEADER_FIELD_UDP_LITE_PORT_SRC << 2) - 1)
+
+#define NET_HEADER_FIELD_UDP_LITE_PORT_SIZE             2
+
+typedef uint8_t headerFieldUdpEncapEsp_t;
+
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC         (1)
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST         (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN              (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 2)
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM            (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 3)
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI              (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 4)
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM     (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 5)
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_ALL_FIELDS       ((NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 6) - 1)
+
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SIZE        2
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI_SIZE         4
+
+#define NET_HEADER_FIELD_IPHC_CID                       (1)
+#define NET_HEADER_FIELD_IPHC_CID_TYPE                  (NET_HEADER_FIELD_IPHC_CID << 1)
+#define NET_HEADER_FIELD_IPHC_HCINDEX                   (NET_HEADER_FIELD_IPHC_CID << 2)
+#define NET_HEADER_FIELD_IPHC_GEN                       (NET_HEADER_FIELD_IPHC_CID << 3)
+#define NET_HEADER_FIELD_IPHC_D_BIT                     (NET_HEADER_FIELD_IPHC_CID << 4)
+#define NET_HEADER_FIELD_IPHC_ALL_FIELDS                ((NET_HEADER_FIELD_IPHC_CID << 5) - 1)
+
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE           (1)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_FLAGS          (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 1)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_LENGTH         (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 2)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_TSN            (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 3)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_ID      (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 4)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_SQN     (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 5)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_PAYLOAD_PID    (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 6)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_UNORDERED      (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 7)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_BEGGINING      (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 8)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_END            (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 9)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_ALL_FIELDS     ((NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 10) - 1)
+
+#define NET_HEADER_FIELD_L2TPv2_TYPE_BIT                (1)
+#define NET_HEADER_FIELD_L2TPv2_LENGTH_BIT              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 1)
+#define NET_HEADER_FIELD_L2TPv2_SEQUENCE_BIT            (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 2)
+#define NET_HEADER_FIELD_L2TPv2_OFFSET_BIT              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 3)
+#define NET_HEADER_FIELD_L2TPv2_PRIORITY_BIT            (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 4)
+#define NET_HEADER_FIELD_L2TPv2_VERSION                 (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 5)
+#define NET_HEADER_FIELD_L2TPv2_LEN                     (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 6)
+#define NET_HEADER_FIELD_L2TPv2_TUNNEL_ID               (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 7)
+#define NET_HEADER_FIELD_L2TPv2_SESSION_ID              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 8)
+#define NET_HEADER_FIELD_L2TPv2_NS                      (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 9)
+#define NET_HEADER_FIELD_L2TPv2_NR                      (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 10)
+#define NET_HEADER_FIELD_L2TPv2_OFFSET_SIZE             (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 11)
+#define NET_HEADER_FIELD_L2TPv2_FIRST_BYTE              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 12)
+#define NET_HEADER_FIELD_L2TPv2_ALL_FIELDS              ((NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 13) - 1)
+
+#define NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT           (1)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH_BIT         (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 1)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_SEQUENCE_BIT       (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 2)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_VERSION            (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 3)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH             (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 4)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_CONTROL            (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 5)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_SENT               (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 6)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_RECV               (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 7)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_FIRST_BYTE         (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 8)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_ALL_FIELDS         ((NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 9) - 1)
+
+#define NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT           (1)
+#define NET_HEADER_FIELD_L2TPv3_SESS_VERSION            (NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 1)
+#define NET_HEADER_FIELD_L2TPv3_SESS_ID                 (NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 2)
+#define NET_HEADER_FIELD_L2TPv3_SESS_COOKIE             (NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 3)
+#define NET_HEADER_FIELD_L2TPv3_SESS_ALL_FIELDS         ((NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 4) - 1)
+
+
+typedef uint8_t headerFieldVlan_t;
+
+#define NET_HEADER_FIELD_VLAN_VPRI                      (1)
+#define NET_HEADER_FIELD_VLAN_CFI                       (NET_HEADER_FIELD_VLAN_VPRI << 1)
+#define NET_HEADER_FIELD_VLAN_VID                       (NET_HEADER_FIELD_VLAN_VPRI << 2)
+#define NET_HEADER_FIELD_VLAN_LENGTH                    (NET_HEADER_FIELD_VLAN_VPRI << 3)
+#define NET_HEADER_FIELD_VLAN_TYPE                      (NET_HEADER_FIELD_VLAN_VPRI << 4)
+#define NET_HEADER_FIELD_VLAN_ALL_FIELDS                ((NET_HEADER_FIELD_VLAN_VPRI << 5) - 1)
+
+#define NET_HEADER_FIELD_VLAN_TCI                       (NET_HEADER_FIELD_VLAN_VPRI | \
+                                                         NET_HEADER_FIELD_VLAN_CFI | \
+                                                         NET_HEADER_FIELD_VLAN_VID)
+
+
+typedef uint8_t headerFieldLlc_t;
+
+#define NET_HEADER_FIELD_LLC_DSAP                       (1)
+#define NET_HEADER_FIELD_LLC_SSAP                       (NET_HEADER_FIELD_LLC_DSAP << 1)
+#define NET_HEADER_FIELD_LLC_CTRL                       (NET_HEADER_FIELD_LLC_DSAP << 2)
+#define NET_HEADER_FIELD_LLC_ALL_FIELDS                 ((NET_HEADER_FIELD_LLC_DSAP << 3) - 1)
+
+#define NET_HEADER_FIELD_NLPID_NLPID                    (1)
+#define NET_HEADER_FIELD_NLPID_ALL_FIELDS               ((NET_HEADER_FIELD_NLPID_NLPID << 1) - 1)
+
+
+typedef uint8_t headerFieldSnap_t;
+
+#define NET_HEADER_FIELD_SNAP_OUI                       (1)
+#define NET_HEADER_FIELD_SNAP_PID                       (NET_HEADER_FIELD_SNAP_OUI << 1)
+#define NET_HEADER_FIELD_SNAP_ALL_FIELDS                ((NET_HEADER_FIELD_SNAP_OUI << 2) - 1)
+
+
+typedef uint8_t headerFieldLlcSnap_t;
+
+#define NET_HEADER_FIELD_LLC_SNAP_TYPE                  (1)
+#define NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS            ((NET_HEADER_FIELD_LLC_SNAP_TYPE << 1) - 1)
+
+#define NET_HEADER_FIELD_ARP_HTYPE                      (1)
+#define NET_HEADER_FIELD_ARP_PTYPE                      (NET_HEADER_FIELD_ARP_HTYPE << 1)
+#define NET_HEADER_FIELD_ARP_HLEN                       (NET_HEADER_FIELD_ARP_HTYPE << 2)
+#define NET_HEADER_FIELD_ARP_PLEN                       (NET_HEADER_FIELD_ARP_HTYPE << 3)
+#define NET_HEADER_FIELD_ARP_OPER                       (NET_HEADER_FIELD_ARP_HTYPE << 4)
+#define NET_HEADER_FIELD_ARP_SHA                        (NET_HEADER_FIELD_ARP_HTYPE << 5)
+#define NET_HEADER_FIELD_ARP_SPA                        (NET_HEADER_FIELD_ARP_HTYPE << 6)
+#define NET_HEADER_FIELD_ARP_THA                        (NET_HEADER_FIELD_ARP_HTYPE << 7)
+#define NET_HEADER_FIELD_ARP_TPA                        (NET_HEADER_FIELD_ARP_HTYPE << 8)
+#define NET_HEADER_FIELD_ARP_ALL_FIELDS                 ((NET_HEADER_FIELD_ARP_HTYPE << 9) - 1)
+
+#define NET_HEADER_FIELD_RFC2684_LLC                    (1)
+#define NET_HEADER_FIELD_RFC2684_NLPID                  (NET_HEADER_FIELD_RFC2684_LLC << 1)
+#define NET_HEADER_FIELD_RFC2684_OUI                    (NET_HEADER_FIELD_RFC2684_LLC << 2)
+#define NET_HEADER_FIELD_RFC2684_PID                    (NET_HEADER_FIELD_RFC2684_LLC << 3)
+#define NET_HEADER_FIELD_RFC2684_VPN_OUI                (NET_HEADER_FIELD_RFC2684_LLC << 4)
+#define NET_HEADER_FIELD_RFC2684_VPN_IDX                (NET_HEADER_FIELD_RFC2684_LLC << 5)
+#define NET_HEADER_FIELD_RFC2684_ALL_FIELDS             ((NET_HEADER_FIELD_RFC2684_LLC << 6) - 1)
+
+#define NET_HEADER_FIELD_USER_DEFINED_SRCPORT           (1)
+#define NET_HEADER_FIELD_USER_DEFINED_PCDID             (NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 1)
+#define NET_HEADER_FIELD_USER_DEFINED_ALL_FIELDS        ((NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 2) - 1)
+
+#define NET_HEADER_FIELD_PAYLOAD_BUFFER                 (1)
+#define NET_HEADER_FIELD_PAYLOAD_SIZE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 1)
+#define NET_HEADER_FIELD_MAX_FRM_SIZE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 2)
+#define NET_HEADER_FIELD_MIN_FRM_SIZE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 3)
+#define NET_HEADER_FIELD_PAYLOAD_TYPE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 4)
+#define NET_HEADER_FIELD_FRAME_SIZE                     (NET_HEADER_FIELD_PAYLOAD_BUFFER << 5)
+#define NET_HEADER_FIELD_PAYLOAD_ALL_FIELDS             ((NET_HEADER_FIELD_PAYLOAD_BUFFER << 6) - 1)
+
+
+typedef uint8_t headerFieldGre_t;
+
+#define NET_HEADER_FIELD_GRE_TYPE                       (1)
+#define NET_HEADER_FIELD_GRE_ALL_FIELDS                 ((NET_HEADER_FIELD_GRE_TYPE << 1) - 1)
+
+
+typedef uint8_t headerFieldMinencap_t;
+
+#define NET_HEADER_FIELD_MINENCAP_SRC_IP                (1)
+#define NET_HEADER_FIELD_MINENCAP_DST_IP                (NET_HEADER_FIELD_MINENCAP_SRC_IP << 1)
+#define NET_HEADER_FIELD_MINENCAP_TYPE                  (NET_HEADER_FIELD_MINENCAP_SRC_IP << 2)
+#define NET_HEADER_FIELD_MINENCAP_ALL_FIELDS            ((NET_HEADER_FIELD_MINENCAP_SRC_IP << 3) - 1)
+
+
+typedef uint8_t headerFieldIpsecAh_t;
+
+#define NET_HEADER_FIELD_IPSEC_AH_SPI                   (1)
+#define NET_HEADER_FIELD_IPSEC_AH_NH                    (NET_HEADER_FIELD_IPSEC_AH_SPI << 1)
+#define NET_HEADER_FIELD_IPSEC_AH_ALL_FIELDS            ((NET_HEADER_FIELD_IPSEC_AH_SPI << 2) - 1)
+
+
+typedef uint8_t headerFieldIpsecEsp_t;
+
+#define NET_HEADER_FIELD_IPSEC_ESP_SPI                  (1)
+#define NET_HEADER_FIELD_IPSEC_ESP_SEQUENCE_NUM         (NET_HEADER_FIELD_IPSEC_ESP_SPI << 1)
+#define NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS           ((NET_HEADER_FIELD_IPSEC_ESP_SPI << 2) - 1)
+
+#define NET_HEADER_FIELD_IPSEC_ESP_SPI_SIZE             4
+
+
+typedef uint8_t headerFieldMpls_t;
+
+#define NET_HEADER_FIELD_MPLS_LABEL_STACK               (1)
+#define NET_HEADER_FIELD_MPLS_LABEL_STACK_ALL_FIELDS    ((NET_HEADER_FIELD_MPLS_LABEL_STACK << 1) - 1)
+
+
+typedef uint8_t headerFieldMacsec_t;
+
+#define NET_HEADER_FIELD_MACSEC_SECTAG                  (1)
+#define NET_HEADER_FIELD_MACSEC_ALL_FIELDS              ((NET_HEADER_FIELD_MACSEC_SECTAG << 1) - 1)
+
+
+typedef enum {
+    HEADER_TYPE_NONE = 0,
+    HEADER_TYPE_PAYLOAD,
+    HEADER_TYPE_ETH,
+    HEADER_TYPE_VLAN,
+    HEADER_TYPE_IPv4,
+    HEADER_TYPE_IPv6,
+    HEADER_TYPE_IP,
+    HEADER_TYPE_TCP,
+    HEADER_TYPE_UDP,
+    HEADER_TYPE_UDP_LITE,
+    HEADER_TYPE_IPHC,
+    HEADER_TYPE_SCTP,
+    HEADER_TYPE_SCTP_CHUNK_DATA,
+    HEADER_TYPE_PPPoE,
+    HEADER_TYPE_PPP,
+    HEADER_TYPE_PPPMUX,
+    HEADER_TYPE_PPPMUX_SUBFRAME,
+    HEADER_TYPE_L2TPv2,
+    HEADER_TYPE_L2TPv3_CTRL,
+    HEADER_TYPE_L2TPv3_SESS,
+    HEADER_TYPE_LLC,
+    HEADER_TYPE_LLC_SNAP,
+    HEADER_TYPE_NLPID,
+    HEADER_TYPE_SNAP,
+    HEADER_TYPE_MPLS,
+    HEADER_TYPE_IPSEC_AH,
+    HEADER_TYPE_IPSEC_ESP,
+    HEADER_TYPE_UDP_ENCAP_ESP, /* RFC 3948 */
+    HEADER_TYPE_MACSEC,
+    HEADER_TYPE_GRE,
+    HEADER_TYPE_MINENCAP,
+    HEADER_TYPE_DCCP,
+    HEADER_TYPE_ICMP,
+    HEADER_TYPE_IGMP,
+    HEADER_TYPE_ARP,
+    HEADER_TYPE_CAPWAP,
+    HEADER_TYPE_CAPWAP_DTLS,
+    HEADER_TYPE_RFC2684,
+    HEADER_TYPE_USER_DEFINED_L2,
+    HEADER_TYPE_USER_DEFINED_L3,
+    HEADER_TYPE_USER_DEFINED_L4,
+    HEADER_TYPE_USER_DEFINED_SHIM1,
+    HEADER_TYPE_USER_DEFINED_SHIM2,
+    MAX_HEADER_TYPE_COUNT
+} e_NetHeaderType;
+
+
+#endif /* __NET_EXT_H */
--- fmlib-fslsdk-v1.7/include/fmd/ncsw_ext.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/ncsw_ext.h	2022-05-26 11:28:31.130971367 -0700
@@ -0,0 +1,437 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          ncsw_ext.h
+
+ @Description   General NetCommSw Standard Definitions
+*//***************************************************************************/
+
+#ifndef __NCSW_EXT_H
+#define __NCSW_EXT_H
+
+#include <types_ext.h>
+
+#define WRITE_BLOCK                 IOMemSet32
+#define COPY_BLOCK                  Mem2IOCpy32
+
+#define PTR_TO_UINT(_ptr)           ((uintptr_t)(_ptr))
+#define UINT_TO_PTR(_val)           ((void*)(uintptr_t)(_val))
+
+#define PTR_MOVE(_ptr, _offset)     (void*)((uint8_t*)(_ptr) + (_offset))
+
+
+#define WRITE_UINT8_UINT24(arg, data08, data24) WRITE_UINT32(arg,((uint32_t)(data08)<<24)|((uint32_t)(data24)&0x00FFFFFF))
+#define WRITE_UINT24_UINT8(arg, data24, data08) WRITE_UINT32(arg,((uint32_t)(data24)<< 8)|((uint32_t)(data08)&0x000000FF))
+
+/* Little-Endian access macros */
+
+#define WRITE_UINT16_LE(arg, data) \
+        WRITE_UINT16((arg), SwapUint16(data))
+
+#define WRITE_UINT32_LE(arg, data) \
+        WRITE_UINT32((arg), SwapUint32(data))
+
+#define WRITE_UINT64_LE(arg, data) \
+        WRITE_UINT64((arg), SwapUint64(data))
+
+#define GET_UINT16_LE(arg) \
+        SwapUint16(GET_UINT16(arg))
+
+#define GET_UINT32_LE(arg) \
+        SwapUint32(GET_UINT32(arg))
+
+#define GET_UINT64_LE(arg) \
+        SwapUint64(GET_UINT64(arg))
+
+/* Write and Read again macros */
+#define WRITE_UINT_SYNC(size, arg, data)    \
+    do {                                    \
+        WRITE_UINT##size((arg), (data));    \
+        CORE_MemoryBarrier();               \
+    } while (0)
+
+#define WRITE_UINT8_SYNC(arg, data)     WRITE_UINT_SYNC(8, (arg), (data))
+
+#define WRITE_UINT16_SYNC(arg, data)    WRITE_UINT_SYNC(16, (arg), (data))
+#define WRITE_UINT32_SYNC(arg, data)    WRITE_UINT_SYNC(32, (arg), (data))
+
+#define MAKE_UINT64(high32, low32)      (((uint64_t)high32 << 32) | (low32))
+
+
+/*----------------------*/
+/* Miscellaneous macros */
+/*----------------------*/
+
+#define UNUSED(X) (X=X)
+
+#define KILOBYTE            0x400UL                 /* 1024 */
+#define MEGABYTE            (KILOBYTE * KILOBYTE)   /* 1024*1024 */
+#define GIGABYTE            ((uint64_t)(KILOBYTE * MEGABYTE))   /* 1024*1024*1024 */
+#define TERABYTE            ((uint64_t)(KILOBYTE * GIGABYTE))   /* 1024*1024*1024*1024 */
+
+#undef  NO_IRQ
+#define NO_IRQ              (-1)
+#define NCSW_MASTER_ID      (0)
+
+/* Macro for checking if a number is a power of 2 */
+#define POWER_OF_2(n)   (!((n) & ((n)-1)))
+
+/* Macro for calculating log of base 2 */
+#define LOG2(num, log2Num)      \
+    do                          \
+    {                           \
+        uint64_t tmp = (num);   \
+        log2Num = 0;            \
+        while (tmp > 1)         \
+        {                       \
+            log2Num++;          \
+            tmp >>= 1;          \
+        }                       \
+    } while (0)
+
+#define NEXT_POWER_OF_2(_num, _nextPow) \
+do                                      \
+{                                       \
+    if (POWER_OF_2(_num))               \
+        _nextPow = (_num);              \
+    else                                \
+    {                                   \
+        uint64_t tmp = (_num);          \
+        _nextPow = 1;                   \
+        while (tmp)                     \
+        {                               \
+            _nextPow <<= 1;             \
+            tmp >>= 1;                  \
+        }                               \
+    }                                   \
+} while (0)
+
+/* Ceiling division - not the fastest way, but safer in terms of overflow */
+#define DIV_CEIL(x,y)   (((x)/(y)) + ((((((x)/(y)))*(y)) == (x)) ? 0 : 1))
+
+/* Round up a number to be a multiple of a second number */
+#define ROUND_UP(x,y)   ((((x) + (y) - 1) / (y)) * (y))
+
+/* Timing macro for converting usec units to number of ticks.   */
+/* (number of usec *  clock_Hz) / 1,000,000) - since            */
+/* clk is in MHz units, no division needed.                     */
+#define USEC_TO_CLK(usec,clk)       ((usec) * (clk))
+#define CYCLES_TO_USEC(cycles,clk)  ((cycles) / (clk))
+
+/* Timing macros for converting between nsec units and number of clocks. */
+#define NSEC_TO_CLK(nsec,clk)       DIV_CEIL(((nsec) * (clk)), 1000)
+#define CYCLES_TO_NSEC(cycles,clk)  (((cycles) * 1000) / (clk))
+
+/* Timing macros for converting between psec units and number of clocks. */
+#define PSEC_TO_CLK(psec,clk)       DIV_CEIL(((psec) * (clk)), 1000000)
+#define CYCLES_TO_PSEC(cycles,clk)  (((cycles) * 1000000) / (clk))
+
+/* Min, Max macros */
+#define MIN(a,b)    ((a) < (b) ? (a) : (b))
+#define MAX(a,b)    ((a) > (b) ? (a) : (b))
+#define IN_RANGE(min,val,max) ((min)<=(val) && (val)<=(max))
+
+#define ABS(a)  ((a<0)?(a*-1):a)
+
+#if !(defined(ARRAY_SIZE))
+#define ARRAY_SIZE(arr)   (sizeof(arr) / sizeof((arr)[0]))
+#endif /* !defined(ARRAY_SIZE) */
+
+
+/* possible alignments */
+#define HALF_WORD_ALIGNMENT     2
+#define WORD_ALIGNMENT          4
+#define DOUBLE_WORD_ALIGNMENT   8
+#define BURST_ALIGNMENT         32
+
+#define HALF_WORD_ALIGNED       0x00000001
+#define WORD_ALIGNED            0x00000003
+#define DOUBLE_WORD_ALIGNED     0x00000007
+#define BURST_ALIGNED           0x0000001f
+#ifndef IS_ALIGNED
+#define IS_ALIGNED(n,align)     (!((uint32_t)(n) & (align - 1)))
+#endif /* IS_ALIGNED */
+
+
+#define LAST_BUF        1
+#define FIRST_BUF       2
+#define SINGLE_BUF      (LAST_BUF | FIRST_BUF)
+#define MIDDLE_BUF      4
+
+#define ARRAY_END       -1
+
+#define ILLEGAL_BASE    (~0)
+
+#define BUF_POSITION(first, last)   state[(!!(last))<<1 | !!(first)]
+#define DECLARE_POSITION static uint8_t state[4] = { (uint8_t)MIDDLE_BUF, (uint8_t)FIRST_BUF, (uint8_t)LAST_BUF, (uint8_t)SINGLE_BUF };
+
+
+/**************************************************************************//**
+ @Description   Timers operation mode
+*//***************************************************************************/
+typedef enum e_TimerMode
+{
+    e_TIMER_MODE_INVALID = 0,
+    e_TIMER_MODE_FREE_RUN,    /**< Free run - counter continues to increase
+                                   after reaching the reference value. */
+    e_TIMER_MODE_PERIODIC,    /**< Periodic - counter restarts counting from 0
+                                   after reaching the reference value. */
+    e_TIMER_MODE_SINGLE       /**< Single (one-shot) - counter stops counting
+                                   after reaching the reference value. */
+} e_TimerMode;
+
+
+/**************************************************************************//**
+ @Description   Enumeration (bit flags) of communication modes (Transmit,
+                receive or both).
+*//***************************************************************************/
+typedef enum e_CommMode
+{
+    e_COMM_MODE_NONE        = 0,    /**< No transmit/receive communication */
+    e_COMM_MODE_RX          = 1,    /**< Only receive communication */
+    e_COMM_MODE_TX          = 2,    /**< Only transmit communication */
+    e_COMM_MODE_RX_AND_TX   = 3     /**< Both transmit and receive communication */
+} e_CommMode;
+
+/**************************************************************************//**
+ @Description   General Diagnostic Mode
+*//***************************************************************************/
+typedef enum e_DiagMode
+{
+    e_DIAG_MODE_NONE = 0,       /**< Normal operation; no diagnostic mode */
+    e_DIAG_MODE_CTRL_LOOPBACK,  /**< Loopback in the controller */
+    e_DIAG_MODE_CHIP_LOOPBACK,  /**< Loopback in the chip but not in the
+                                     controller; e.g. IO-pins, SerDes, etc. */
+    e_DIAG_MODE_PHY_LOOPBACK,   /**< Loopback in the external PHY */
+    e_DIAG_MODE_EXT_LOOPBACK,   /**< Loopback in the external line (beyond the PHY) */
+    e_DIAG_MODE_CTRL_ECHO,      /**< Echo incoming data by the controller */
+    e_DIAG_MODE_PHY_ECHO        /**< Echo incoming data by the PHY */
+} e_DiagMode;
+
+/**************************************************************************//**
+ @Description   Possible RxStore callback responses.
+*//***************************************************************************/
+typedef enum e_RxStoreResponse
+{
+      e_RX_STORE_RESPONSE_PAUSE     /**< Pause invoking callback with received data;
+                                         in polling mode, start again invoking callback
+                                         only next time user invokes the receive routine;
+                                         in interrupt mode, start again invoking callback
+                                         only next time a receive event triggers an interrupt;
+                                         in all cases, received data that are pending are not
+                                         lost, rather, their processing is temporarily deferred;
+                                         in all cases, received data are processed in the order
+                                         in which they were received. */
+    , e_RX_STORE_RESPONSE_CONTINUE  /**< Continue invoking callback with received data. */
+} e_RxStoreResponse;
+
+
+/**************************************************************************//**
+ @Description   General Handle
+*//***************************************************************************/
+typedef void *      t_Handle;   /**< handle, used as object's descriptor */
+
+/**************************************************************************//**
+ @Description   MUTEX type
+*//***************************************************************************/
+typedef uint32_t    t_Mutex;
+
+/**************************************************************************//**
+ @Description   Error Code.
+
+                The high word of the error code is the code of the software
+                module (driver). The low word is the error type (e_ErrorType).
+                To get the values from the error code, use GET_ERROR_TYPE()
+                and GET_ERROR_MODULE().
+*//***************************************************************************/
+typedef uint32_t    t_Error;
+
+/**************************************************************************//**
+ @Description   General prototype of interrupt service routine (ISR).
+
+ @Param[in]     handle - Optional handle of the module handling the interrupt.
+
+ @Return        None
+ *//***************************************************************************/
+typedef void (t_Isr)(t_Handle handle);
+
+/**************************************************************************//**
+ @Anchor        mem_attr
+
+ @Collection    Memory Attributes
+
+                Various attributes of memory partitions. These values may be
+                or'ed together to create a mask of all memory attributes.
+ @{
+*//***************************************************************************/
+#define MEMORY_ATTR_CACHEABLE           0x00000001
+                                        /**< Memory is cacheable */
+#define MEMORY_ATTR_QE_2ND_BUS_ACCESS   0x00000002
+                                        /**< Memory can be accessed by QUICC Engine
+                                             through its secondary bus interface */
+
+/* @} */
+
+
+/**************************************************************************//**
+ @Function      t_GetBufFunction
+
+ @Description   User callback function called by driver to get data buffer.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_BufferPool        - A handle to buffer pool manager
+ @Param[out]    p_BufContextHandle  - Returns the user's private context that
+                                      should be associated with the buffer
+
+ @Return        Pointer to data buffer, NULL if error
+ *//***************************************************************************/
+typedef uint8_t * (t_GetBufFunction)(t_Handle   h_BufferPool,
+                                     t_Handle   *p_BufContextHandle);
+
+/**************************************************************************//**
+ @Function      t_PutBufFunction
+
+ @Description   User callback function called by driver to return data buffer.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_BufferPool    - A handle to buffer pool manager
+ @Param[in]     p_Buffer        - A pointer to buffer to return
+ @Param[in]     h_BufContext    - The user's private context associated with
+                                  the returned buffer
+
+ @Return        E_OK on success; Error code otherwise
+ *//***************************************************************************/
+typedef t_Error (t_PutBufFunction)(t_Handle h_BufferPool,
+                                   uint8_t  *p_Buffer,
+                                   t_Handle h_BufContext);
+
+/**************************************************************************//**
+ @Function      t_PhysToVirt
+
+ @Description   Translates a physical address to the matching virtual address.
+
+ @Param[in]     addr - The physical address to translate.
+
+ @Return        Virtual address.
+*//***************************************************************************/
+typedef void * t_PhysToVirt(physAddress_t addr);
+
+/**************************************************************************//**
+ @Function      t_VirtToPhys
+
+ @Description   Translates a virtual address to the matching physical address.
+
+ @Param[in]     addr - The virtual address to translate.
+
+ @Return        Physical address.
+*//***************************************************************************/
+typedef physAddress_t t_VirtToPhys(void *addr);
+
+/**************************************************************************//**
+ @Description   Buffer Pool Information Structure.
+*//***************************************************************************/
+typedef struct t_BufferPoolInfo
+{
+    t_Handle            h_BufferPool;   /**< A handle to the buffer pool manager */
+    t_GetBufFunction    *f_GetBuf;      /**< User callback to get a free buffer */
+    t_PutBufFunction    *f_PutBuf;      /**< User callback to return a buffer */
+    uint16_t            bufferSize;     /**< Buffer size (in bytes) */
+
+    t_PhysToVirt        *f_PhysToVirt;  /**< User callback to translate pool buffers
+                                             physical addresses to virtual addresses  */
+    t_VirtToPhys        *f_VirtToPhys;  /**< User callback to translate pool buffers
+                                             virtual addresses to physical addresses */
+} t_BufferPoolInfo;
+
+
+/**************************************************************************//**
+ @Description   User callback function called by driver when transmit completed.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_App           - Application's handle, as was provided to the
+                                  driver by the user
+ @Param[in]     queueId         - Transmit queue ID
+ @Param[in]     p_Data          - Pointer to the data buffer
+ @Param[in]     h_BufContext    - The user's private context associated with
+                                  the given data buffer
+ @Param[in]     status          - Transmit status and errors
+ @Param[in]     flags           - Driver-dependent information
+ *//***************************************************************************/
+typedef void (t_TxConfFunction)(t_Handle    h_App,
+                                uint32_t    queueId,
+                                uint8_t     *p_Data,
+                                t_Handle    h_BufContext,
+                                uint16_t    status,
+                                uint32_t    flags);
+
+/**************************************************************************//**
+ @Description   User callback function called by driver with receive data.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_App           - Application's handle, as was provided to the
+                                  driver by the user
+ @Param[in]     queueId         - Receive queue ID
+ @Param[in]     p_Data          - Pointer to the buffer with received data
+ @Param[in]     h_BufContext    - The user's private context associated with
+                                  the given data buffer
+ @Param[in]     length          - Length of received data
+ @Param[in]     status          - Receive status and errors
+ @Param[in]     position        - Position of buffer in frame
+ @Param[in]     flags           - Driver-dependent information
+
+ @Retval        e_RX_STORE_RESPONSE_CONTINUE - order the driver to continue Rx
+                                               operation for all ready data.
+ @Retval        e_RX_STORE_RESPONSE_PAUSE    - order the driver to stop Rx operation.
+ *//***************************************************************************/
+typedef e_RxStoreResponse (t_RxStoreFunction)(t_Handle  h_App,
+                                              uint32_t  queueId,
+                                              uint8_t   *p_Data,
+                                              t_Handle  h_BufContext,
+                                              uint32_t  length,
+                                              uint16_t  status,
+                                              uint8_t   position,
+                                              uint32_t  flags);
+
+
+typedef struct t_Device {
+    uintptr_t   id;         /**< the device id */
+    int         fd;         /**< the device file descriptor */
+    t_Handle    h_UserPriv;
+    uint32_t    owners;
+} t_Device;
+
+#endif /* __NCSW_EXT_H */
--- fmlib-fslsdk-v1.7/include/fmd/enet_ext.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/enet_ext.h	2022-05-26 11:28:31.090973003 -0700
@@ -0,0 +1,202 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          enet_ext.h
+
+ @Description   Ethernet generic definitions and enums.
+*//***************************************************************************/
+
+#ifndef __ENET_EXT_H
+#define __ENET_EXT_H
+
+#include "fsl_enet.h"
+
+#define ENET_NUM_OCTETS_PER_ADDRESS 6     /**< Number of octets (8-bit bytes) in an ethernet address */
+#define ENET_GROUP_ADDR             0x01  /**< Group address mask for ethernet addresses */
+
+
+/**************************************************************************//**
+ @Description   Ethernet Address
+*//***************************************************************************/
+typedef uint8_t t_EnetAddr[ENET_NUM_OCTETS_PER_ADDRESS];
+
+/**************************************************************************//**
+ @Description   Ethernet Address Type.
+*//***************************************************************************/
+typedef enum e_EnetAddrType
+{
+    e_ENET_ADDR_TYPE_INDIVIDUAL,    /**< Individual (unicast) address */
+    e_ENET_ADDR_TYPE_GROUP,         /**< Group (multicast) address */
+    e_ENET_ADDR_TYPE_BROADCAST      /**< Broadcast address */
+} e_EnetAddrType;
+
+/**************************************************************************//**
+ @Description   Ethernet MAC-PHY Interface
+*//***************************************************************************/
+typedef enum e_EnetInterface
+{
+    e_ENET_IF_MII   = E_ENET_IF_MII,     /**< MII interface */
+    e_ENET_IF_RMII  = E_ENET_IF_RMII,    /**< RMII interface */
+    e_ENET_IF_SMII  = E_ENET_IF_SMII,    /**< SMII interface */
+    e_ENET_IF_GMII  = E_ENET_IF_GMII,    /**< GMII interface */
+    e_ENET_IF_RGMII = E_ENET_IF_RGMII,   /**< RGMII interface */
+    e_ENET_IF_TBI   = E_ENET_IF_TBI,     /**< TBI interface */
+    e_ENET_IF_RTBI  = E_ENET_IF_RTBI,    /**< RTBI interface */
+    e_ENET_IF_SGMII = E_ENET_IF_SGMII,   /**< SGMII interface */
+    e_ENET_IF_XGMII = E_ENET_IF_XGMII,   /**< XGMII interface */
+    e_ENET_IF_QSGMII= E_ENET_IF_QSGMII,  /**< QSGMII interface */
+    e_ENET_IF_XFI   = E_ENET_IF_XFI      /**< XFI interface */
+} e_EnetInterface;
+
+#define ENET_IF_SGMII_BASEX       0x80000000   /**< SGMII/QSGII interface with 1000BaseX
+                                                    auto-negotiation between MAC and phy
+                                                    or backplane;
+                                                    Note: 1000BaseX auto-negotiation relates
+                                                    only to interface between MAC and phy/backplane,
+                                                    SGMII phy can still synchronize with far-end phy
+                                                    at 10Mbps, 100Mbps or 1000Mbps */
+
+/**************************************************************************//**
+ @Description   Ethernet Duplex Mode
+*//***************************************************************************/
+typedef enum e_EnetDuplexMode
+{
+    e_ENET_HALF_DUPLEX,             /**< Half-Duplex mode */
+    e_ENET_FULL_DUPLEX              /**< Full-Duplex mode */
+} e_EnetDuplexMode;
+
+/**************************************************************************//**
+ @Description   Ethernet Speed (nominal data rate)
+*//***************************************************************************/
+typedef enum e_EnetSpeed
+{
+    e_ENET_SPEED_10     = E_ENET_SPEED_10,       /**< 10 Mbps */
+    e_ENET_SPEED_100    = E_ENET_SPEED_100,      /**< 100 Mbps */
+    e_ENET_SPEED_1000   = E_ENET_SPEED_1000,     /**< 1000 Mbps = 1 Gbps */
+    e_ENET_SPEED_10000  = E_ENET_SPEED_10000     /**< 10000 Mbps = 10 Gbps */
+} e_EnetSpeed;
+
+/**************************************************************************//**
+ @Description   Ethernet mode (combination of MAC-PHY interface and speed)
+*//***************************************************************************/
+typedef enum e_EnetMode
+{
+    e_ENET_MODE_INVALID           = 0,                                        /**< Invalid Ethernet mode */
+    e_ENET_MODE_MII_10            = (e_ENET_IF_MII   | e_ENET_SPEED_10),      /**<    10 Mbps MII   */
+    e_ENET_MODE_MII_100           = (e_ENET_IF_MII   | e_ENET_SPEED_100),     /**<   100 Mbps MII   */
+    e_ENET_MODE_RMII_10           = (e_ENET_IF_RMII  | e_ENET_SPEED_10),      /**<    10 Mbps RMII  */
+    e_ENET_MODE_RMII_100          = (e_ENET_IF_RMII  | e_ENET_SPEED_100),     /**<   100 Mbps RMII  */
+    e_ENET_MODE_SMII_10           = (e_ENET_IF_SMII  | e_ENET_SPEED_10),      /**<    10 Mbps SMII  */
+    e_ENET_MODE_SMII_100          = (e_ENET_IF_SMII  | e_ENET_SPEED_100),     /**<   100 Mbps SMII  */
+    e_ENET_MODE_GMII_1000         = (e_ENET_IF_GMII  | e_ENET_SPEED_1000),    /**<  1000 Mbps GMII  */
+    e_ENET_MODE_RGMII_10          = (e_ENET_IF_RGMII | e_ENET_SPEED_10),      /**<    10 Mbps RGMII */
+    e_ENET_MODE_RGMII_100         = (e_ENET_IF_RGMII | e_ENET_SPEED_100),     /**<   100 Mbps RGMII */
+    e_ENET_MODE_RGMII_1000        = (e_ENET_IF_RGMII | e_ENET_SPEED_1000),    /**<  1000 Mbps RGMII */
+    e_ENET_MODE_TBI_1000          = (e_ENET_IF_TBI   | e_ENET_SPEED_1000),    /**<  1000 Mbps TBI   */
+    e_ENET_MODE_RTBI_1000         = (e_ENET_IF_RTBI  | e_ENET_SPEED_1000),    /**<  1000 Mbps RTBI  */
+    e_ENET_MODE_SGMII_10          = (e_ENET_IF_SGMII | e_ENET_SPEED_10),
+                                        /**< 10 Mbps SGMII with auto-negotiation between MAC and
+                                             SGMII phy according to Cisco SGMII specification */
+    e_ENET_MODE_SGMII_100         = (e_ENET_IF_SGMII | e_ENET_SPEED_100),
+                                        /**< 100 Mbps SGMII with auto-negotiation between MAC and
+                                             SGMII phy according to Cisco SGMII specification */
+    e_ENET_MODE_SGMII_1000        = (e_ENET_IF_SGMII | e_ENET_SPEED_1000),
+                                        /**< 1000 Mbps SGMII with auto-negotiation between MAC and
+                                             SGMII phy according to Cisco SGMII specification */
+    e_ENET_MODE_SGMII_BASEX_10    = (ENET_IF_SGMII_BASEX | e_ENET_IF_SGMII | e_ENET_SPEED_10),
+                                        /**< 10 Mbps SGMII with 1000BaseX auto-negotiation between
+                                             MAC and SGMII phy or backplane */
+    e_ENET_MODE_SGMII_BASEX_100   = (ENET_IF_SGMII_BASEX | e_ENET_IF_SGMII | e_ENET_SPEED_100),
+                                        /**< 100 Mbps SGMII with 1000BaseX auto-negotiation between
+                                             MAC and SGMII phy or backplane */
+    e_ENET_MODE_SGMII_BASEX_1000  = (ENET_IF_SGMII_BASEX | e_ENET_IF_SGMII | e_ENET_SPEED_1000),
+                                        /**< 1000 Mbps SGMII with 1000BaseX auto-negotiation between
+                                             MAC and SGMII phy or backplane */
+    e_ENET_MODE_QSGMII_1000       = (e_ENET_IF_QSGMII| e_ENET_SPEED_1000),
+                                        /**< 1000 Mbps QSGMII with auto-negotiation between MAC and
+                                             QSGMII phy according to Cisco QSGMII specification */
+    e_ENET_MODE_QSGMII_BASEX_1000 = (ENET_IF_SGMII_BASEX | e_ENET_IF_QSGMII| e_ENET_SPEED_1000),
+                                        /**< 1000 Mbps QSGMII with 1000BaseX auto-negotiation between
+                                             MAC and QSGMII phy or backplane */
+    e_ENET_MODE_XGMII_10000       = (e_ENET_IF_XGMII | e_ENET_SPEED_10000),   /**< 10000 Mbps XGMII */
+    e_ENET_MODE_XFI_10000         = (e_ENET_IF_XFI   | e_ENET_SPEED_10000)    /**< 10000 Mbps XFI */
+} e_EnetMode;
+
+
+#define IS_ENET_MODE_VALID(mode) \
+        (((mode) == e_ENET_MODE_MII_10     ) || \
+         ((mode) == e_ENET_MODE_MII_100    ) || \
+         ((mode) == e_ENET_MODE_RMII_10    ) || \
+         ((mode) == e_ENET_MODE_RMII_100   ) || \
+         ((mode) == e_ENET_MODE_SMII_10    ) || \
+         ((mode) == e_ENET_MODE_SMII_100   ) || \
+         ((mode) == e_ENET_MODE_GMII_1000  ) || \
+         ((mode) == e_ENET_MODE_RGMII_10   ) || \
+         ((mode) == e_ENET_MODE_RGMII_100  ) || \
+         ((mode) == e_ENET_MODE_RGMII_1000 ) || \
+         ((mode) == e_ENET_MODE_TBI_1000   ) || \
+         ((mode) == e_ENET_MODE_RTBI_1000  ) || \
+         ((mode) == e_ENET_MODE_SGMII_10   ) || \
+         ((mode) == e_ENET_MODE_SGMII_100  ) || \
+         ((mode) == e_ENET_MODE_SGMII_1000 ) || \
+         ((mode) == e_ENET_MODE_SGMII_BASEX_10   ) || \
+         ((mode) == e_ENET_MODE_SGMII_BASEX_100  ) || \
+         ((mode) == e_ENET_MODE_SGMII_BASEX_1000 ) || \
+         ((mode) == e_ENET_MODE_XGMII_10000) || \
+         ((mode) == e_ENET_MODE_QSGMII_1000) || \
+         ((mode) == e_ENET_MODE_QSGMII_BASEX_1000) || \
+         ((mode) == e_ENET_MODE_XFI_10000))
+
+
+#define MAKE_ENET_MODE(_interface, _speed)     (e_EnetMode)((_interface) | (_speed))
+
+#define ENET_INTERFACE_FROM_MODE(mode)          (e_EnetInterface)((mode) & 0x0FFF0000)
+#define ENET_SPEED_FROM_MODE(mode)              (e_EnetSpeed)((mode) & 0x0000FFFF)
+
+#define ENET_ADDR_TO_UINT64(_enetAddr)                  \
+        (uint64_t)(((uint64_t)(_enetAddr)[0] << 40) |   \
+                   ((uint64_t)(_enetAddr)[1] << 32) |   \
+                   ((uint64_t)(_enetAddr)[2] << 24) |   \
+                   ((uint64_t)(_enetAddr)[3] << 16) |   \
+                   ((uint64_t)(_enetAddr)[4] << 8) |    \
+                   ((uint64_t)(_enetAddr)[5]))
+
+#define MAKE_ENET_ADDR_FROM_UINT64(_addr64, _enetAddr)              \
+        do {                                                        \
+            int i;                                                  \
+            for (i=0; i < ENET_NUM_OCTETS_PER_ADDRESS; i++)         \
+                (_enetAddr)[i] = (uint8_t)((_addr64) >> ((5-i)*8)); \
+        } while (0)
+
+
+#endif /* __ENET_EXT_H */
--- fmlib-fslsdk-v1.7/include/fmd/std_ext.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/std_ext.h	2022-05-26 11:28:31.134971204 -0700
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          std_ext.h
+
+ @Description   General Standard Definitions
+*//***************************************************************************/
+
+#ifndef __STD_EXT_H
+#define __STD_EXT_H
+
+
+#include "types_ext.h"
+#include "ncsw_ext.h"
+
+
+#endif /* __STD_EXT_H */
--- fmlib-fslsdk-v1.7/include/fmd/error_ext.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/error_ext.h	2022-05-26 11:28:31.098972675 -0700
@@ -0,0 +1,529 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          error_ext.h
+
+ @Description   Error definitions.
+*//***************************************************************************/
+
+#ifndef __ERROR_EXT_H
+#define __ERROR_EXT_H
+
+#include <errno.h>
+
+#include "std_ext.h"
+#include "xx_ext.h"
+
+
+
+/**************************************************************************//**
+ @Group         gen_id  General Drivers Utilities
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         gen_error_id  Errors, Events and Debug
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/******************************************************************************
+The scheme below provides the bits description for error codes:
+
+ 0    1    2    3    4    5    6    7    8    9    10   11   12   13   14   15
+|       Reserved (should be zero)      |              Module ID               |
+
+ 16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31
+|                               Error Type                                    |
+******************************************************************************/
+
+#define ERROR_CODE(_err)            ((((uint32_t)_err) & 0x0000FFFF) | __ERR_MODULE__)
+
+#define GET_ERROR_TYPE(_errcode)    ((_errcode) & 0x0000FFFF)
+                                /**< Extract module code from error code (#t_Error) */
+
+#define GET_ERROR_MODULE(_errcode)  ((_errcode) & 0x00FF0000)
+                                /**< Extract error type (#e_ErrorType) from
+                                     error code (#t_Error) */
+
+
+/**************************************************************************//**
+ @Description    Error Type Enumeration
+*//***************************************************************************/
+typedef enum e_ErrorType    /*   Comments / Associated Message Strings                      */
+{                           /* ------------------------------------------------------------ */
+    E_OK = 0                /*   Never use "RETURN_ERROR" with E_OK; Use "return E_OK;"     */
+    ,E_WRITE_FAILED = EIO   /**< Write access failed on memory/device.                      */
+                            /*   String: none, or device name.                              */
+    ,E_NO_DEVICE = ENXIO    /**< The associated device is not initialized.                  */
+                            /*   String: none.                                              */
+    ,E_NOT_AVAILABLE = EAGAIN
+                            /**< Resource is unavailable.                                   */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_NO_MEMORY = ENOMEM   /**< External memory allocation failed.                         */
+                            /*   String: description of item for which allocation failed.   */
+    ,E_INVALID_ADDRESS = EFAULT
+                            /**< Invalid address.                                           */
+                            /*   String: description of the specific violation.             */
+    ,E_BUSY = EBUSY         /**< Resource or module is busy.                                */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_ALREADY_EXISTS = EEXIST
+                            /**< Requested resource or item already exists.                 */
+                            /*   Use when resource duplication or sharing are not allowed.
+                                 String: none, unless the operation is not the main goal
+                                 of the function (in this case add item description).       */
+    ,E_INVALID_OPERATION = ENODEV
+                            /**< The operation/command is invalid (unrecognized).           */
+                            /*   String: none.                                              */
+    ,E_INVALID_VALUE = EDOM /**< Invalid value.                                             */
+                            /*   Use for non-enumeration parameters, and
+                                 only when other error types are not suitable.
+                                 String: parameter description + "(should be <attribute>)",
+                                 e.g: "Maximum Rx buffer length (should be divisible by 8)",
+                                      "Channel number (should be even)".                    */
+    ,E_NOT_IN_RANGE = ERANGE/**< Parameter value is out of range.                           */
+                            /*   Don't use this error for enumeration parameters.
+                                 String: parameter description + "(should be %d-%d)",
+                                 e.g: "Number of pad characters (should be 0-15)".          */
+    ,E_NOT_SUPPORTED = ENOSYS
+                            /**< The function is not supported or not implemented.          */
+                            /*   String: none.                                              */
+    ,E_INVALID_STATE        /**< The operation is not allowed in current module state.      */
+                            /*   String: none.                                              */
+    ,E_INVALID_HANDLE       /**< Invalid handle of module or object.                        */
+                            /*   String: none, unless the function takes in more than one
+                                 handle (in this case add the handle description)           */
+    ,E_INVALID_ID           /**< Invalid module ID (usually enumeration or index).          */
+                            /*   String: none, unless the function takes in more than one
+                                 ID (in this case add the ID description)                   */
+    ,E_NULL_POINTER         /**< Unexpected NULL pointer.                                   */
+                            /*   String: pointer description.                               */
+    ,E_INVALID_SELECTION    /**< Invalid selection or mode.                                 */
+                            /*   Use for enumeration values, only when other error types
+                                 are not suitable.
+                                 String: parameter description.                             */
+    ,E_INVALID_COMM_MODE    /**< Invalid communication mode.                                */
+                            /*   String: none, unless the function takes in more than one
+                                 communication mode indications (in this case add
+                                 parameter description).                                    */
+    ,E_INVALID_MEMORY_TYPE  /**< Invalid memory type.                                       */
+                            /*   String: none, unless the function takes in more than one
+                                 memory types (in this case add memory description,
+                                 e.g: "Data memory", "Buffer descriptors memory").          */
+    ,E_INVALID_CLOCK        /**< Invalid clock.                                             */
+                            /*   String: none, unless the function takes in more than one
+                                 clocks (in this case add clock description,
+                                 e.g: "Rx clock", "Tx clock").                              */
+    ,E_CONFLICT             /**< Some setting conflicts with another setting.               */
+                            /*   String: description of the conflicting settings.           */
+    ,E_NOT_ALIGNED          /**< Non-aligned address.                                       */
+                            /*   String: parameter description + "(should be %d-bytes aligned)",
+                                 e.g: "Rx data buffer (should be 32-bytes aligned)".        */
+    ,E_NOT_FOUND            /**< Requested resource or item was not found.                  */
+                            /*   Use only when the resource/item is uniquely identified.
+                                 String: none, unless the operation is not the main goal
+                                 of the function (in this case add item description).       */
+    ,E_FULL                 /**< Resource is full.                                          */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_EMPTY                /**< Resource is empty.                                         */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_ALREADY_FREE         /**< Specified resource or item is already free or deleted.     */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add item description).       */
+    ,E_READ_FAILED          /**< Read access failed on memory/device.                       */
+                            /*   String: none, or device name.                              */
+    ,E_INVALID_FRAME        /**< Invalid frame object (NULL handle or missing buffers).     */
+                            /*   String: none.                                              */
+    ,E_SEND_FAILED          /**< Send operation failed on device.                           */
+                            /*   String: none, or device name.                              */
+    ,E_RECEIVE_FAILED       /**< Receive operation failed on device.                        */
+                            /*   String: none, or device name.                              */
+    ,E_TIMEOUT/* = ETIMEDOUT*/  /**< The operation timed out.                                   */
+                            /*   String: none.                                              */
+
+    ,E_DUMMY_LAST           /* NEVER USED */
+
+} e_ErrorType;
+
+
+/**************************************************************************//**
+ @Description    Event Type Enumeration
+*//***************************************************************************/
+typedef enum e_Event        /*   Comments / Associated Flags and Message Strings            */
+{                           /* ------------------------------------------------------------ */
+    EV_NO_EVENT = 0         /**< No event; Never used.                                      */
+
+    ,EV_RX_DISCARD          /**< Received packet discarded (by the driver, and only for
+                                 complete packets);
+                                 Flags: error flags in case of error, zero otherwise.       */
+                            /*   String: reason for discard, e.g: "Error in frame",
+                                 "Disordered frame", "Incomplete frame", "No frame object". */
+    ,EV_RX_ERROR            /**< Receive error (by hardware/firmware);
+                                 Flags: usually status flags from the buffer descriptor.    */
+                            /*   String: none.                                              */
+    ,EV_TX_ERROR            /**< Transmit error (by hardware/firmware);
+                                 Flags: usually status flags from the buffer descriptor.    */
+                            /*   String: none.                                              */
+    ,EV_NO_BUFFERS          /**< System ran out of buffer objects;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_NO_MB_FRAMES        /**< System ran out of multi-buffer frame objects;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_NO_SB_FRAMES        /**< System ran out of single-buffer frame objects;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_TX_QUEUE_FULL       /**< Transmit queue is full;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_RX_QUEUE_FULL       /**< Receive queue is full;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_INTR_QUEUE_FULL     /**< Interrupt queue overflow;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_NO_DATA_BUFFER      /**< Data buffer allocation (from higher layer) failed;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_OBJ_POOL_EMPTY      /**< Objects pool is empty;
+                                 Flags: zero.                                               */
+                            /*   String: object description (name).                         */
+    ,EV_BUS_ERROR           /**< Illegal access on bus;
+                                 Flags: the address (if available) or bus identifier        */
+                            /*   String: bus/address/module description.                    */
+    ,EV_PTP_TXTS_QUEUE_FULL /**< PTP Tx timestamps queue is full;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_PTP_RXTS_QUEUE_FULL /**< PTP Rx timestamps queue is full;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_DUMMY_LAST
+
+} e_Event;
+
+
+/**************************************************************************//**
+ @Collection    Debug Levels for Errors and Events
+
+                The level description refers to errors only.
+                For events, classification is done by the user.
+
+                The TRACE, INFO and WARNING levels are allowed only when using
+                the DBG macro, and are not allowed when using the error macros
+                (RETURN_ERROR or REPORT_ERROR).
+ @{
+*//***************************************************************************/
+#define REPORT_LEVEL_CRITICAL   1       /**< Crasher: Incorrect flow, NULL pointers/handles. */
+#define REPORT_LEVEL_MAJOR      2       /**< Cannot proceed: Invalid operation, parameters or
+                                             configuration. */
+#define REPORT_LEVEL_MINOR      3       /**< Recoverable problem: a repeating call with the same
+                                             parameters may be successful. */
+#define REPORT_LEVEL_WARNING    4       /**< Something is not exactly right, yet it is not an error. */
+#define REPORT_LEVEL_INFO       5       /**< Messages which may be of interest to user/programmer. */
+#define REPORT_LEVEL_TRACE      6       /**< Program flow messages. */
+
+#define EVENT_DISABLED          0xFF    /**< Disabled event (not reported at all) */
+
+/* @} */
+
+
+
+#define NO_MSG      ("")
+
+#ifndef DEBUG_GLOBAL_LEVEL
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_WARNING
+#endif /* DEBUG_GLOBAL_LEVEL */
+
+#ifndef ERROR_GLOBAL_LEVEL
+#define ERROR_GLOBAL_LEVEL  DEBUG_GLOBAL_LEVEL
+#endif /* ERROR_GLOBAL_LEVEL */
+
+#ifndef EVENT_GLOBAL_LEVEL
+#define EVENT_GLOBAL_LEVEL  REPORT_LEVEL_MINOR
+#endif /* EVENT_GLOBAL_LEVEL */
+
+#ifdef EVENT_LOCAL_LEVEL
+#define EVENT_DYNAMIC_LEVEL EVENT_LOCAL_LEVEL
+#else
+#define EVENT_DYNAMIC_LEVEL EVENT_GLOBAL_LEVEL
+#endif /* EVENT_LOCAL_LEVEL */
+
+
+#ifndef DEBUG_DYNAMIC_LEVEL
+#define DEBUG_USING_STATIC_LEVEL
+
+#ifdef DEBUG_STATIC_LEVEL
+#define DEBUG_DYNAMIC_LEVEL DEBUG_STATIC_LEVEL
+#else
+#define DEBUG_DYNAMIC_LEVEL DEBUG_GLOBAL_LEVEL
+#endif /* DEBUG_STATIC_LEVEL */
+
+#else /* DEBUG_DYNAMIC_LEVEL */
+#ifdef DEBUG_STATIC_LEVEL
+#error "Please use either DEBUG_STATIC_LEVEL or DEBUG_DYNAMIC_LEVEL (not both)"
+#else
+int DEBUG_DYNAMIC_LEVEL = DEBUG_GLOBAL_LEVEL;
+#endif /* DEBUG_STATIC_LEVEL */
+#endif /* !DEBUG_DYNAMIC_LEVEL */
+
+
+#ifndef ERROR_DYNAMIC_LEVEL
+
+#ifdef ERROR_STATIC_LEVEL
+#define ERROR_DYNAMIC_LEVEL ERROR_STATIC_LEVEL
+#else
+#define ERROR_DYNAMIC_LEVEL ERROR_GLOBAL_LEVEL
+#endif /* ERROR_STATIC_LEVEL */
+
+#else /* ERROR_DYNAMIC_LEVEL */
+#ifdef ERROR_STATIC_LEVEL
+#error "Please use either ERROR_STATIC_LEVEL or ERROR_DYNAMIC_LEVEL (not both)"
+#else
+int ERROR_DYNAMIC_LEVEL = ERROR_GLOBAL_LEVEL;
+#endif /* ERROR_STATIC_LEVEL */
+#endif /* !ERROR_DYNAMIC_LEVEL */
+
+#define PRINT_FORMAT        "[CPU%02d, %s:%d %s]"
+#define PRINT_FMT_PARAMS    CORE_GetId(), __FILE__, __LINE__, __FUNCTION__
+
+#if (!(defined(DEBUG_ERRORS)) || (DEBUG_ERRORS == 0))
+/* No debug/error/event messages at all */
+#define DBG(_level, _vmsg)
+
+#define REPORT_ERROR(_level, _err, _vmsg)
+
+#define RETURN_ERROR(_level, _err, _vmsg) \
+        return ERROR_CODE(_err)
+
+#ifndef REPORT_EVENTS
+#define REPORT_EVENTS 1
+#endif
+
+#if (REPORT_EVENTS > 0)
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg) \
+    do { \
+        if (_ev##_LEVEL <= EVENT_DYNAMIC_LEVEL) { \
+            XX_EventById((uint32_t)(_ev), (t_Handle)(_appId), (uint16_t)(_flg), NO_MSG); \
+        } \
+    } while (0)
+
+#else
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg)
+
+#endif /* (REPORT_EVENTS > 0) */
+
+
+#else /* DEBUG_ERRORS > 0 */
+
+extern const char *dbgLevelStrings[];
+extern const char *moduleStrings[];
+#if (REPORT_EVENTS > 0)
+extern const char *eventStrings[];
+#endif /* (REPORT_EVENTS > 0) */
+
+char * ErrTypeStrings (e_ErrorType err);
+
+
+#if ((defined(DEBUG_USING_STATIC_LEVEL)) && (DEBUG_DYNAMIC_LEVEL < REPORT_LEVEL_WARNING))
+/* No need for DBG macro - debug level is higher anyway */
+#define DBG(_level, _vmsg)
+#else
+#define DBG(_level, _vmsg) \
+    do { \
+        if (REPORT_LEVEL_##_level <= DEBUG_DYNAMIC_LEVEL) { \
+            XX_Print("> %s (%s) " PRINT_FORMAT ": ", \
+                     dbgLevelStrings[REPORT_LEVEL_##_level - 1], \
+                     moduleStrings[__ERR_MODULE__ >> 16], \
+                     PRINT_FMT_PARAMS); \
+            XX_Print _vmsg; \
+            XX_Print("\r\n"); \
+        } \
+    } while (0)
+#endif /* (defined(DEBUG_USING_STATIC_LEVEL) && (DEBUG_DYNAMIC_LEVEL < WARNING)) */
+
+
+#define REPORT_ERROR(_level, _err, _vmsg) \
+    do { \
+        if (REPORT_LEVEL_##_level <= ERROR_DYNAMIC_LEVEL) { \
+            XX_Print("! %s %s Error " PRINT_FORMAT ": %s; ", \
+                     dbgLevelStrings[REPORT_LEVEL_##_level - 1], \
+                     moduleStrings[__ERR_MODULE__ >> 16], \
+                     PRINT_FMT_PARAMS, \
+                     ErrTypeStrings((e_ErrorType)GET_ERROR_TYPE(_err))); \
+            XX_Print _vmsg; \
+            XX_Print("\r\n"); \
+        } \
+    } while (0)
+
+
+#define RETURN_ERROR(_level, _err, _vmsg) \
+    do { \
+        REPORT_ERROR(_level, (_err), _vmsg); \
+        return ERROR_CODE(_err); \
+    } while (0)
+
+
+#if (REPORT_EVENTS > 0)
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg) \
+    do { \
+        if (_ev##_LEVEL <= EVENT_DYNAMIC_LEVEL) { \
+            XX_Print("~ %s %s Event " PRINT_FORMAT ": %s (flags: 0x%04x); ", \
+                     dbgLevelStrings[_ev##_LEVEL - 1], \
+                     moduleStrings[__ERR_MODULE__ >> 16], \
+                     PRINT_FMT_PARAMS, \
+                     eventStrings[((_ev) - EV_NO_EVENT - 1)], \
+                     (uint16_t)(_flg)); \
+            XX_Print _vmsg; \
+            XX_Print("\r\n"); \
+            XX_EventById((uint32_t)(_ev), (t_Handle)(_appId), (uint16_t)(_flg), NO_MSG); \
+        } \
+    } while (0)
+
+#else /* not REPORT_EVENTS */
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg)
+
+#endif /* (REPORT_EVENTS > 0) */
+
+#endif /* (DEBUG_ERRORS > 0) */
+
+
+/**************************************************************************//**
+ @Function      ASSERT_COND
+
+ @Description   Assertion macro.
+
+ @Param[in]     _cond - The condition being checked, in positive form;
+                        Failure of the condition triggers the assert.
+*//***************************************************************************/
+#ifdef DISABLE_ASSERTIONS
+#define ASSERT_COND(_cond)
+#else
+#define ASSERT_COND(_cond) \
+    do { \
+        if (!(_cond)) { \
+            XX_Print("*** ASSERT_COND failed " PRINT_FORMAT "\r\n", \
+                    PRINT_FMT_PARAMS); \
+            XX_Exit(1); \
+        } \
+    } while (0)
+#endif /* DISABLE_ASSERTIONS */
+
+
+#ifdef DISABLE_INIT_PARAMETERS_CHECK
+
+#define CHECK_INIT_PARAMETERS(handle, f_check)
+#define CHECK_INIT_PARAMETERS_RETURN_VALUE(handle, f_check, retval)
+
+#else
+
+#define CHECK_INIT_PARAMETERS(handle, f_check) \
+    do { \
+        t_Error err = f_check(handle); \
+        if (err != E_OK) { \
+            RETURN_ERROR(MAJOR, err, NO_MSG); \
+        } \
+    } while (0)
+
+#define CHECK_INIT_PARAMETERS_RETURN_VALUE(handle, f_check, retval) \
+    do { \
+        t_Error err = f_check(handle); \
+        if (err != E_OK) { \
+            REPORT_ERROR(MAJOR, err, NO_MSG); \
+            return (retval); \
+        } \
+    } while (0)
+
+#endif /* DISABLE_INIT_PARAMETERS_CHECK */
+
+#ifdef DISABLE_SANITY_CHECKS
+
+#define SANITY_CHECK_RETURN_ERROR(_cond, _err)
+#define SANITY_CHECK_RETURN_VALUE(_cond, _err, retval)
+#define SANITY_CHECK_RETURN(_cond, _err)
+#define SANITY_CHECK_EXIT(_cond, _err)
+
+#else /* DISABLE_SANITY_CHECKS */
+
+#define SANITY_CHECK_RETURN_ERROR(_cond, _err) \
+    do { \
+        if (!(_cond)) { \
+            RETURN_ERROR(CRITICAL, (_err), NO_MSG); \
+        } \
+    } while (0)
+
+#define SANITY_CHECK_RETURN_VALUE(_cond, _err, retval) \
+    do { \
+        if (!(_cond)) { \
+            REPORT_ERROR(CRITICAL, (_err), NO_MSG); \
+            return (retval); \
+        } \
+    } while (0)
+
+#define SANITY_CHECK_RETURN(_cond, _err) \
+    do { \
+        if (!(_cond)) { \
+            REPORT_ERROR(CRITICAL, (_err), NO_MSG); \
+            return; \
+        } \
+    } while (0)
+
+#define SANITY_CHECK_EXIT(_cond, _err) \
+    do { \
+        if (!(_cond)) { \
+            REPORT_ERROR(CRITICAL, (_err), NO_MSG); \
+            XX_Exit(1); \
+        } \
+    } while (0)
+
+#endif /* DISABLE_SANITY_CHECKS */
+
+/** @} */ /* end of Debug/error Utils group */
+
+/** @} */ /* end of General Utils group */
+
+#endif /* __ERROR_EXT_H */
+
+
--- fmlib-fslsdk-v1.7/include/fmd/types_ext.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/types_ext.h	2022-05-26 11:28:31.134971204 -0700
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          types_ext.h
+
+ @Description   General types Standard Definitions
+*//***************************************************************************/
+
+#ifndef __TYPES_EXT_H
+#define __TYPES_EXT_H
+
+#if defined(NCSW_LINUX)
+#include "types_linux.h"
+
+#elif defined(NCSW_LINUX_USD)
+#include "types_linux_usd.h"
+
+#elif defined(NCSW_VXWORKS)
+#include "types_vxworks.h"
+
+#elif defined(__GNUC__) && defined(__cplusplus)
+#include "types_bb_gpp.h"
+
+#elif defined(__GNUC__)
+#include "types_bb_gcc.h"
+
+#elif defined(__ghs__)
+#include "types_ghs.h"
+
+#else
+#include "types_dflt.h"
+#endif /* defined (__ROCOO__) */
+
+static __inline__ void TypesChecker(void)
+{
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+     _Packed struct strct {
+        __volatile__ int vi;
+    } _PackedType;
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+    size_t          size = 0;
+    bool            tr = TRUE, fls = FALSE;
+    struct strct    *p_Struct = NULL;
+    physAddress_t   addr = 0x100;
+
+    tr          = fls;
+    p_Struct    = p_Struct;
+    size++;
+    if (tr) size++;
+
+    WRITE_UINT8(*((uint8_t*)((size_t)(addr))),
+                 GET_UINT8(*((uint8_t*)((size_t)(addr)))));
+
+    WRITE_UINT8(*((uint8_t*)((size_t)(UINT8_MAX))),
+                 GET_UINT8(*((uint8_t*)((size_t)(UINT8_MAX)))));
+    WRITE_UINT16(*((uint16_t*)((size_t)(UINT16_MAX))),
+                 GET_UINT16(*((uint16_t*)((size_t)(UINT16_MAX)))));
+    WRITE_UINT32(*((uint32_t*)((size_t)(UINT32_MAX))),
+                 GET_UINT32(*((uint32_t*)((size_t)(UINT32_MAX)))));
+    WRITE_UINT64(*((uint64_t*)((size_t)(UINT64_MAX))),
+                 GET_UINT64(*((uint64_t*)((size_t)(UINT64_MAX)))));
+    WRITE_UINT8(*((uint8_t*)((size_t)(INT8_MAX))),
+                 GET_UINT8(*((uint8_t*)((size_t)(INT8_MIN)))));
+    WRITE_UINT16(*((uint16_t*)((size_t)(INT16_MAX))),
+                 GET_UINT16(*((uint16_t*)((size_t)(INT16_MIN)))));
+    WRITE_UINT32(*((uint32_t*)((size_t)(INT32_MAX))),
+                 GET_UINT32(*((uint32_t*)((size_t)(INT32_MIN)))));
+    WRITE_UINT64(*((uint64_t*)((size_t)(INT64_MAX))),
+                 GET_UINT64(*((uint64_t*)((size_t)(INT64_MIN)))));
+}
+
+#endif /* __TYPES_EXT_H */
--- fmlib-fslsdk-v1.7/include/fmd/Peripherals/fm_vsp_ext.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/Peripherals/fm_vsp_ext.h	2022-05-26 11:28:31.086973166 -0700
@@ -0,0 +1,409 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+
+/**************************************************************************//**
+ @File          fm_vsp_ext.h
+
+ @Description   FM Virtual Storage-Profile ...
+*//***************************************************************************/
+#ifndef __FM_VSP_EXT_H
+#define __FM_VSP_EXT_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+
+#include "fm_ext.h"
+
+
+/**************************************************************************//**
+
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_VSP_grp FM Virtual-Storage-Profile
+
+ @Description   FM Virtual-Storage-Profile API
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_VSP_init_grp FM VSP Initialization Unit
+
+ @Description   FM VSP initialization API.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Virtual Storage Profile
+*//***************************************************************************/
+typedef struct t_FmVspParams {
+    t_Handle            h_Fm;               /**< A handle to the FM object this VSP related to */
+    t_FmExtPools        extBufPools;        /**< Which external buffer pools are used
+                                                 (up to FM_PORT_MAX_NUM_OF_EXT_POOLS), and their sizes.
+                                                 parameter associated with Rx / OP port */
+    uint16_t            liodnOffset;        /**< VSP's LIODN offset */
+    struct {
+        e_FmPortType    portType;           /**< Port type */
+        uint8_t         portId;             /**< Port Id - relative to type */
+    } portParams;
+    uint8_t             relativeProfileId;  /**< VSP Id - relative to VSP's range
+                                                 defined in relevant FM object */
+} t_FmVspParams;
+
+
+/**************************************************************************//**
+ @Function      FM_VSP_Config
+
+ @Description   Creates descriptor for the FM VSP module.
+
+                The routine returns a handle (descriptor) to the FM VSP object.
+                This descriptor must be passed as first parameter to all other
+                FM VSP function calls.
+
+                No actual initialization or configuration of FM hardware is
+                done by this routine.
+
+@Param[in]      p_FmVspParams   Pointer to data structure of parameters
+
+ @Retval        Handle to FM VSP object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_VSP_Config(t_FmVspParams *p_FmVspParams);
+
+/**************************************************************************//**
+ @Function      FM_VSP_Init
+
+ @Description   Initializes the FM VSP module
+
+ @Param[in]     h_FmVsp - FM VSP module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_VSP_Init(t_Handle h_FmVsp);
+
+/**************************************************************************//**
+ @Function      FM_VSP_Free
+
+ @Description   Frees all resources that were assigned to FM VSP module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmVsp - FM VSP module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_VSP_Free(t_Handle h_FmVsp);
+
+
+/**************************************************************************//**
+ @Group         FM_VSP_adv_config_grp  FM VSP Advanced Configuration Unit
+
+ @Description   FM VSP advanced configuration functions.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigBufferPrefixContent
+
+ @Description   Defines the structure, size and content of the application buffer.
+
+                The prefix will
+                In VSPs defined for Tx ports, if 'passPrsResult', the application
+                should set a value to their offsets in the prefix of
+                the FM will save the first 'privDataSize', than,
+                depending on 'passPrsResult' and 'passTimeStamp', copy parse result
+                and timeStamp, and the packet itself (in this order), to the
+                application buffer, and to offset.
+
+                Calling this routine changes the buffer margins definitions
+                in the internal driver data base from its default
+                configuration: Data size:  [DEFAULT_FM_SP_bufferPrefixContent_privDataSize]
+                               Pass Parser result: [DEFAULT_FM_SP_bufferPrefixContent_passPrsResult].
+                               Pass timestamp: [DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp].
+
+ @Param[in]     h_FmVsp                         A handle to a FM VSP module.
+ @Param[in,out] p_FmBufferPrefixContent         A structure of parameters describing the
+                                                structure of the buffer.
+                                                Out parameter: Start margin - offset
+                                                of data from start of external buffer.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigBufferPrefixContent(t_Handle                   h_FmVsp,
+                                         t_FmBufferPrefixContent    *p_FmBufferPrefixContent);
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigDmaSwapData
+
+ @Description   Calling this routine changes the DMA swap data parameter
+                in the internal driver data base from its default
+                configuration  [DEFAULT_FM_SP_dmaSwapData]
+
+ @Param[in]     h_FmVsp     A handle to a FM VSP module.
+ @Param[in]     swapData    New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigDmaSwapData(t_Handle h_FmVsp, e_FmDmaSwapOption swapData);
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigDmaIcCacheAttr
+
+ @Description   Calling this routine changes the internal context cache
+                attribute parameter in the internal driver data base
+                from its default configuration  [DEFAULT_FM_SP_dmaIntContextCacheAttr]
+
+ @Param[in]     h_FmVsp                 A handle to a FM VSP module.
+ @Param[in]     intContextCacheAttr     New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigDmaIcCacheAttr(t_Handle            h_FmVsp,
+                                    e_FmDmaCacheOption  intContextCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigDmaHdrAttr
+
+ @Description   Calling this routine changes the header cache
+                attribute parameter in the internal driver data base
+                from its default configuration  [DEFAULT_FM_SP_dmaHeaderCacheAttr]
+
+ @Param[in]     h_FmVsp                     A handle to a FM VSP module.
+ @Param[in]     headerCacheAttr             New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigDmaHdrAttr(t_Handle h_FmVsp, e_FmDmaCacheOption headerCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigDmaScatterGatherAttr
+
+ @Description   Calling this routine changes the scatter gather cache
+                attribute parameter in the internal driver data base
+                from its default configuration [DEFAULT_FM_SP_dmaScatterGatherCacheAttr]
+
+ @Param[in]     h_FmVsp                     A handle to a FM VSP module.
+ @Param[in]     scatterGatherCacheAttr      New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigDmaScatterGatherAttr(t_Handle              h_FmVsp,
+                                          e_FmDmaCacheOption    scatterGatherCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigDmaWriteOptimize
+
+ @Description   Calling this routine changes the write optimization
+                parameter in the internal driver data base
+                from its default configuration: optimize = [DEFAULT_FM_SP_dmaWriteOptimize]
+
+ @Param[in]     h_FmVsp     A handle to a FM VSP module.
+ @Param[in]     optimize    TRUE to enable optimization, FALSE for normal operation
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigDmaWriteOptimize(t_Handle h_FmVsp, bool optimize);
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigNoScatherGather
+
+ @Description   Calling this routine changes the possibility to receive S/G frame
+                in the internal driver data base
+                from its default configuration: optimize = [DEFAULT_FM_SP_noScatherGather]
+
+ @Param[in]     h_FmVsp             A handle to a FM VSP module.
+ @Param[in]     noScatherGather     TRUE to operate without scatter/gather capability.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigNoScatherGather(t_Handle h_FmVsp, bool noScatherGather);
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigPoolDepletion
+
+ @Description   Calling this routine enables pause frame generation depending on the
+                depletion status of BM pools. It also defines the conditions to activate
+                this functionality. By default, this functionality is disabled.
+
+ @Param[in]     h_FmVsp                 A handle to a FM VSP module.
+ @Param[in]     p_BufPoolDepletion      A structure of pool depletion parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigPoolDepletion(t_Handle h_FmVsp, t_FmBufPoolDepletion *p_BufPoolDepletion);
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigBackupPools
+
+ @Description   Calling this routine allows the configuration of some of the BM pools
+                defined for this port as backup pools.
+                A pool configured to be a backup pool will be used only if all other
+                enabled non-backup pools are depleted.
+
+ @Param[in]     h_FmVsp                 A handle to a FM VSP module.
+ @Param[in]     p_BackupBmPools         An array of pool id's. All pools specified here will
+                                        be defined as backup pools.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigBackupPools(t_Handle h_FmVsp, t_FmBackupBmPools *p_BackupBmPools);
+
+/** @} */ /* end of FM_VSP_adv_config_grp group */
+/** @} */ /* end of FM_VSP_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_VSP_control_grp FM VSP Control Unit
+
+ @Description   FM VSP runtime control API.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_VSP_GetBufferDataOffset
+
+ @Description   Relevant for Rx ports.
+                Returns the data offset from the beginning of the data buffer
+
+ @Param[in]     h_FmVsp - FM PORT module descriptor
+
+ @Return        data offset.
+
+ @Cautions      Allowed only following FM_VSP_Init().
+*//***************************************************************************/
+uint32_t FM_VSP_GetBufferDataOffset(t_Handle h_FmVsp);
+
+/**************************************************************************//**
+ @Function      FM_VSP_GetBufferICInfo
+
+ @Description   Returns the Internal Context offset from the beginning of the data buffer
+
+ @Param[in]     h_FmVsp - FM PORT module descriptor
+ @Param[in]     p_Data   - A pointer to the data buffer.
+
+ @Return        Internal context info pointer on success, NULL if 'allOtherInfo' was not
+                configured for this port.
+
+ @Cautions      Allowed only following FM_VSP_Init().
+*//***************************************************************************/
+uint8_t * FM_VSP_GetBufferICInfo(t_Handle h_FmVsp, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_VSP_GetBufferPrsResult
+
+ @Description   Returns the pointer to the parse result in the data buffer.
+                In Rx ports this is relevant after reception, if parse
+                result is configured to be part of the data passed to the
+                application. For non Rx ports it may be used to get the pointer
+                of the area in the buffer where parse result should be
+                initialized - if so configured.
+                See FM_VSP_ConfigBufferPrefixContent for data buffer prefix
+                configuration.
+
+ @Param[in]     h_FmVsp    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        Parse result pointer on success, NULL if parse result was not
+                configured for this port.
+
+ @Cautions      Allowed only following FM_VSP_Init().
+*//***************************************************************************/
+t_FmPrsResult * FM_VSP_GetBufferPrsResult(t_Handle h_FmVsp, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_VSP_GetBufferTimeStamp
+
+ @Description   Returns the time stamp in the data buffer.
+                Relevant for Rx ports for getting the buffer time stamp.
+                See FM_VSP_ConfigBufferPrefixContent for data buffer prefix
+                configuration.
+
+ @Param[in]     h_FmVsp    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        A pointer to the hash result on success, NULL otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Init().
+*//***************************************************************************/
+uint64_t * FM_VSP_GetBufferTimeStamp(t_Handle h_FmVsp, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_VSP_GetBufferHashResult
+
+ @Description   Given a data buffer, on the condition that hash result was defined
+                as a part of the buffer content (see FM_VSP_ConfigBufferPrefixContent)
+                this routine will return the pointer to the hash result location in the
+                buffer prefix.
+
+ @Param[in]     h_FmVsp    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        A pointer to the hash result on success, NULL otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Init().
+*//***************************************************************************/
+uint8_t * FM_VSP_GetBufferHashResult(t_Handle h_FmVsp, char *p_Data);
+
+
+/** @} */ /* end of FM_VSP_control_grp group */
+/** @} */ /* end of FM_VSP_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+#endif /* __FM_VSP_EXT_H */
--- fmlib-fslsdk-v1.7/include/fmd/Peripherals/fsl_fman_kg.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/Peripherals/fsl_fman_kg.h	2022-05-26 11:28:31.086973166 -0700
@@ -0,0 +1,514 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FSL_FMAN_KG_H
+#define __FSL_FMAN_KG_H
+
+#include "common/general.h"
+
+#define FM_KG_NUM_OF_GENERIC_REGS	8 /**< Num of generic KeyGen regs */
+#define FMAN_MAX_NUM_OF_HW_PORTS	64
+/**< Total num of masks allowed on KG extractions */
+#define FM_KG_EXTRACT_MASKS_NUM		4
+#define FM_KG_NUM_CLS_PLAN_ENTR		8 /**< Num of class. plan regs */
+#define FM_KG_CLS_PLAN_GRPS_NUM		32 /**< Max num of class. groups */
+
+struct fman_kg_regs {
+	uint32_t fmkg_gcr;
+	uint32_t res004;
+	uint32_t res008;
+	uint32_t fmkg_eer;
+	uint32_t fmkg_eeer;
+	uint32_t res014;
+	uint32_t res018;
+	uint32_t fmkg_seer;
+	uint32_t fmkg_seeer;
+	uint32_t fmkg_gsr;
+	uint32_t fmkg_tpc;
+	uint32_t fmkg_serc;
+	uint32_t res030[4];
+	uint32_t fmkg_fdor;
+	uint32_t fmkg_gdv0r;
+	uint32_t fmkg_gdv1r;
+	uint32_t res04c[6];
+	uint32_t fmkg_feer;
+	uint32_t res068[38];
+	uint32_t fmkg_indirect[63];
+	uint32_t fmkg_ar;
+};
+
+struct fman_kg_scheme_regs {
+	uint32_t kgse_mode; /**< MODE */
+	uint32_t kgse_ekfc; /**< Extract Known Fields Command */
+	uint32_t kgse_ekdv; /**< Extract Known Default Value */
+	uint32_t kgse_bmch; /**< Bit Mask Command High */
+	uint32_t kgse_bmcl; /**< Bit Mask Command Low */
+	uint32_t kgse_fqb; /**< Frame Queue Base */
+	uint32_t kgse_hc; /**< Hash Command */
+	uint32_t kgse_ppc; /**< Policer Profile Command */
+	uint32_t kgse_gec[FM_KG_NUM_OF_GENERIC_REGS];
+				/**< Generic Extract Command */
+	uint32_t kgse_spc; /**< KeyGen Scheme Entry Statistic Packet Counter */
+	uint32_t kgse_dv0; /**< KeyGen Scheme Entry Default Value 0 */
+	uint32_t kgse_dv1; /**< KeyGen Scheme Entry Default Value 1 */
+	uint32_t kgse_ccbs; /**< KeyGen Scheme Entry Coarse Classification Bit*/
+	uint32_t kgse_mv; /**< KeyGen Scheme Entry Match vector */
+	uint32_t kgse_om; /**< KeyGen Scheme Entry Operation Mode bits */
+	uint32_t kgse_vsp; /**< KeyGen Scheme Entry Virtual Storage Profile */
+};
+
+struct fman_kg_pe_regs{
+	uint32_t fmkg_pe_sp;
+	uint32_t fmkg_pe_cpp;
+};
+
+struct fman_kg_cp_regs {
+	uint32_t kgcpe[FM_KG_NUM_CLS_PLAN_ENTR];
+};
+
+
+#define FM_KG_KGAR_GO				0x80000000
+#define FM_KG_KGAR_READ				0x40000000
+#define FM_KG_KGAR_WRITE			0x00000000
+#define FM_KG_KGAR_SEL_SCHEME_ENTRY		0x00000000
+#define FM_KG_KGAR_SCM_WSEL_UPDATE_CNT		0x00008000
+
+#define KG_SCH_PP_SHIFT_HIGH			0x80000000
+#define KG_SCH_PP_NO_GEN			0x10000000
+#define KG_SCH_PP_SHIFT_LOW			0x0000F000
+#define KG_SCH_MODE_NIA_PLCR			0x40000000
+#define KG_SCH_GEN_EXTRACT_TYPE			0x00008000
+#define KG_SCH_BITMASK_MASK			0x000000FF
+#define KG_SCH_GEN_VALID			0x80000000
+#define KG_SCH_GEN_MASK				0x00FF0000
+#define FM_PCD_KG_KGAR_ERR			0x20000000
+#define FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY	0x01000000
+#define FM_PCD_KG_KGAR_SEL_PORT_ENTRY		0x02000000
+#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP		0x00008000
+#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP	0x00004000
+#define FM_PCD_KG_KGAR_WSEL_MASK		0x0000FF00
+#define KG_SCH_HASH_CONFIG_NO_FQID		0x80000000
+#define KG_SCH_HASH_CONFIG_SYM			0x40000000
+
+#define FM_EX_KG_DOUBLE_ECC			0x80000000
+#define FM_EX_KG_KEYSIZE_OVERFLOW		0x40000000
+
+/* ECC capture register */
+#define KG_FMKG_SERC_CAP			0x80000000
+#define KG_FMKG_SERC_CET			0x40000000
+#define KG_FMKG_SERC_CNT_MSK			0x00FF0000
+#define KG_FMKG_SERC_CNT_SHIFT			16
+#define KG_FMKG_SERC_ADDR_MSK			0x000003FF
+
+/* Masks */
+#define FM_KG_KGGCR_EN				0x80000000
+#define KG_SCH_GEN_VALID			0x80000000
+#define KG_SCH_GEN_EXTRACT_TYPE			0x00008000
+#define KG_ERR_TYPE_DOUBLE			0x40000000
+#define KG_ERR_ADDR_MASK			0x00000FFF
+#define KG_SCH_MODE_EN				0x80000000
+
+/* shifts */
+#define FM_KG_KGAR_NUM_SHIFT			16
+#define FM_KG_PE_CPP_MASK_SHIFT			16
+#define FM_KG_KGAR_WSEL_SHIFT			8
+
+#define FM_KG_SCH_GEN_HT_INVALID		0
+
+#define FM_KG_MASK_SEL_GEN_BASE			0x20
+
+#define KG_GET_MASK_SEL_SHIFT(shift, i)	\
+switch (i)				\
+{					\
+	case 0: (shift) = 26; break;	\
+	case 1: (shift) = 20; break;	\
+	case 2: (shift) = 10; break;	\
+	case 3: (shift) = 4; break;	\
+	default: (shift) = 0;		\
+}
+
+#define KG_GET_MASK_OFFSET_SHIFT(shift, i)	\
+switch (i)				\
+{					\
+	case 0: (shift) = 16; break;	\
+	case 1: (shift) = 0; break;	\
+	case 2: (shift) = 28; break;	\
+	case 3: (shift) = 24; break;	\
+	default: (shift) = 0;		\
+}
+
+#define KG_GET_MASK_SHIFT(shift, i)	\
+switch (i)				\
+{					\
+	case 0: shift = 24; break;	\
+	case 1: shift = 16; break;	\
+	case 2: shift = 8;  break;	\
+	case 3: shift = 0;  break;	\
+	default: shift = 0;		\
+}
+
+/* Port entry CPP register */
+#define FMAN_KG_PE_CPP_MASK_SHIFT	16
+
+/* Scheme registers */
+#define FMAN_KG_SCH_MODE_EN		0x80000000
+#define FMAN_KG_SCH_MODE_NIA_PLCR	0x40000000
+#define FMAN_KG_SCH_MODE_CCOBASE_SHIFT	24
+
+#define FMAN_KG_SCH_DEF_MAC_ADDR_SHIFT	30
+#define FMAN_KG_SCH_DEF_VLAN_TCI_SHIFT	28
+#define FMAN_KG_SCH_DEF_ETYPE_SHIFT	26
+#define FMAN_KG_SCH_DEF_PPP_SID_SHIFT	24
+#define FMAN_KG_SCH_DEF_PPP_PID_SHIFT	22
+#define FMAN_KG_SCH_DEF_MPLS_SHIFT	20
+#define FMAN_KG_SCH_DEF_IP_ADDR_SHIFT	18
+#define FMAN_KG_SCH_DEF_PTYPE_SHIFT	16
+#define FMAN_KG_SCH_DEF_IP_TOS_TC_SHIFT	14
+#define FMAN_KG_SCH_DEF_IPv6_FL_SHIFT	12
+#define FMAN_KG_SCH_DEF_IPSEC_SPI_SHIFT	10
+#define FMAN_KG_SCH_DEF_L4_PORT_SHIFT	8
+#define FMAN_KG_SCH_DEF_TCP_FLG_SHIFT	6
+
+#define FMAN_KG_SCH_GEN_VALID		0x80000000
+#define FMAN_KG_SCH_GEN_SIZE_MAX	16
+#define FMAN_KG_SCH_GEN_OR		0x00008000
+
+#define FMAN_KG_SCH_GEN_DEF_SHIFT	29
+#define FMAN_KG_SCH_GEN_SIZE_SHIFT	24
+#define FMAN_KG_SCH_GEN_MASK_SHIFT	16
+#define FMAN_KG_SCH_GEN_HT_SHIFT	8
+
+#define FMAN_KG_SCH_HASH_HSHIFT_SHIFT	24
+#define FMAN_KG_SCH_HASH_HSHIFT_MAX	0x28
+#define FMAN_KG_SCH_HASH_SYM		0x40000000
+#define FMAN_KG_SCH_HASH_NO_FQID_GEN	0x80000000
+
+#define FMAN_KG_SCH_PP_SH_SHIFT		27
+#define FMAN_KG_SCH_PP_SL_SHIFT		12
+#define FMAN_KG_SCH_PP_SH_MASK		0x80000000
+#define FMAN_KG_SCH_PP_SL_MASK		0x0000F000
+#define FMAN_KG_SCH_PP_SHIFT_MAX	0x17
+#define FMAN_KG_SCH_PP_MASK_SHIFT	16
+#define FMAN_KG_SCH_PP_NO_GEN		0x10000000
+
+enum fman_kg_gen_extract_src {
+	E_FMAN_KG_GEN_EXTRACT_ETH,
+	E_FMAN_KG_GEN_EXTRACT_ETYPE,
+	E_FMAN_KG_GEN_EXTRACT_SNAP,
+	E_FMAN_KG_GEN_EXTRACT_VLAN_TCI_1,
+	E_FMAN_KG_GEN_EXTRACT_VLAN_TCI_N,
+	E_FMAN_KG_GEN_EXTRACT_PPPoE,
+	E_FMAN_KG_GEN_EXTRACT_MPLS_1,
+	E_FMAN_KG_GEN_EXTRACT_MPLS_2,
+	E_FMAN_KG_GEN_EXTRACT_MPLS_3,
+	E_FMAN_KG_GEN_EXTRACT_MPLS_N,
+	E_FMAN_KG_GEN_EXTRACT_IPv4_1,
+	E_FMAN_KG_GEN_EXTRACT_IPv6_1,
+	E_FMAN_KG_GEN_EXTRACT_IPv4_2,
+	E_FMAN_KG_GEN_EXTRACT_IPv6_2,
+	E_FMAN_KG_GEN_EXTRACT_MINENCAP,
+	E_FMAN_KG_GEN_EXTRACT_IP_PID,
+	E_FMAN_KG_GEN_EXTRACT_GRE,
+	E_FMAN_KG_GEN_EXTRACT_TCP,
+	E_FMAN_KG_GEN_EXTRACT_UDP,
+	E_FMAN_KG_GEN_EXTRACT_SCTP,
+	E_FMAN_KG_GEN_EXTRACT_DCCP,
+	E_FMAN_KG_GEN_EXTRACT_IPSEC_AH,
+	E_FMAN_KG_GEN_EXTRACT_IPSEC_ESP,
+	E_FMAN_KG_GEN_EXTRACT_SHIM_1,
+	E_FMAN_KG_GEN_EXTRACT_SHIM_2,
+	E_FMAN_KG_GEN_EXTRACT_FROM_DFLT,
+	E_FMAN_KG_GEN_EXTRACT_FROM_FRAME_START,
+	E_FMAN_KG_GEN_EXTRACT_FROM_PARSE_RESULT,
+	E_FMAN_KG_GEN_EXTRACT_FROM_END_OF_PARSE,
+	E_FMAN_KG_GEN_EXTRACT_FROM_FQID
+};
+
+struct fman_kg_ex_ecc_attr
+{
+	bool		valid;
+	bool		double_ecc;
+	uint16_t	addr;
+	uint8_t		single_ecc_count;
+};
+
+enum fman_kg_def_select
+{
+	E_FMAN_KG_DEF_GLOBAL_0,
+	E_FMAN_KG_DEF_GLOBAL_1,
+	E_FMAN_KG_DEF_SCHEME_0,
+	E_FMAN_KG_DEF_SCHEME_1
+};
+
+struct fman_kg_extract_def
+{
+	enum fman_kg_def_select	mac_addr;
+	enum fman_kg_def_select	vlan_tci;
+	enum fman_kg_def_select	etype;
+	enum fman_kg_def_select	ppp_sid;
+	enum fman_kg_def_select	ppp_pid;
+	enum fman_kg_def_select	mpls;
+	enum fman_kg_def_select	ip_addr;
+	enum fman_kg_def_select	ptype;
+	enum fman_kg_def_select	ip_tos_tc;
+	enum fman_kg_def_select	ipv6_fl;
+	enum fman_kg_def_select	ipsec_spi;
+	enum fman_kg_def_select	l4_port;
+	enum fman_kg_def_select	tcp_flg;
+};
+
+enum fman_kg_gen_extract_type
+{
+	E_FMAN_KG_HASH_EXTRACT,
+	E_FMAN_KG_OR_EXTRACT
+};
+
+struct fman_kg_gen_extract_params
+{
+	/* Hash or Or-ed extract */
+	enum fman_kg_gen_extract_type	type;
+	enum fman_kg_gen_extract_src	src;
+	bool				no_validation;
+	/* Extraction offset from the header location specified above */
+	uint8_t				offset;
+	/* Size of extraction for FMAN_KG_HASH_EXTRACT,
+	 * hash result shift for FMAN_KG_OR_EXTRACT */
+	uint8_t				extract;
+	uint8_t				mask;
+	/* Default value to use when header specified
+	 * by fman_kg_gen_extract_src doesn't present */
+	enum fman_kg_def_select		def_val;
+};
+
+struct fman_kg_extract_mask
+{
+	/**< Indication if mask is on known field extraction or
+	 * on general extraction; TRUE for known field */
+	bool		is_known;
+	/**< One of FMAN_KG_EXTRACT_xxx defines for known fields mask and
+	 * generic register index for generic extracts mask */
+	uint32_t	field_or_gen_idx;
+	/**< Byte offset from start of the extracted data specified
+	 * by field_or_gen_idx */
+	uint8_t		offset;
+	/**< Byte mask (selected bits will be used) */
+	uint8_t		mask;
+};
+
+struct fman_kg_extract_params
+{
+	/* Or-ed mask of FMAN_KG_EXTRACT_xxx defines */
+	uint32_t				known_fields;
+	struct fman_kg_extract_def		known_fields_def;
+	/* Number of entries in gen_extract */
+	uint8_t					gen_extract_num;
+	struct fman_kg_gen_extract_params	gen_extract[FM_KG_NUM_OF_GENERIC_REGS];
+	/* Number of entries in masks */
+	uint8_t					masks_num;
+	struct fman_kg_extract_mask		masks[FM_KG_EXTRACT_MASKS_NUM];
+	uint32_t				def_scheme_0;
+	uint32_t				def_scheme_1;
+};
+
+struct fman_kg_hash_params
+{
+	bool		use_hash;
+	uint8_t		shift_r;
+	uint32_t	mask; /**< 24-bit mask */
+	bool		sym; /**< Symmetric hash for src and dest pairs */
+};
+
+struct fman_kg_pp_params
+{
+	uint8_t		base;
+	uint8_t		shift;
+	uint8_t		mask;
+	bool		bypass_pp_gen;
+};
+
+struct fman_kg_cc_params
+{
+	uint8_t		base_offset;
+	uint32_t	qlcv_bits_sel;
+};
+
+enum fman_pcd_engine
+{
+	E_FMAN_PCD_INVALID = 0,	/**< Invalid PCD engine indicated*/
+	E_FMAN_PCD_DONE,	/**< No PCD Engine indicated */
+	E_FMAN_PCD_KG,		/**< Keygen indicated */
+	E_FMAN_PCD_CC,		/**< Coarse classification indicated */
+	E_FMAN_PCD_PLCR,	/**< Policer indicated */
+	E_FMAN_PCD_PRS		/**< Parser indicated */
+};
+
+struct fman_kg_cls_plan_params
+{
+	uint8_t entries_mask;
+	uint32_t mask_vector[FM_KG_NUM_CLS_PLAN_ENTR];
+};
+
+struct fman_kg_scheme_params
+{
+	uint32_t			match_vector;
+	struct fman_kg_extract_params	extract_params;
+	struct fman_kg_hash_params	hash_params;
+	uint32_t			base_fqid;
+	/* What we do w/features supported per FM version ?? */
+	bool				bypass_fqid_gen;
+	struct fman_kg_pp_params	policer_params;
+	struct fman_kg_cc_params	cc_params;
+	bool				update_counter;
+	/**< counter_value: Set scheme counter to the specified value;
+	 * relevant only when update_counter = TRUE. */
+	uint32_t			counter_value;
+	enum fman_pcd_engine		next_engine;
+	/**< Next engine action code */
+	uint32_t			next_engine_action;
+};
+
+
+
+int fman_kg_write_ar_wait(struct fman_kg_regs *regs, uint32_t fmkg_ar);
+void fman_kg_write_sp(struct fman_kg_regs *regs, uint32_t sp, bool add);
+void fman_kg_write_cpp(struct fman_kg_regs *regs, uint32_t cpp);
+void fman_kg_get_event(struct fman_kg_regs *regs,
+			uint32_t *event,
+			uint32_t *scheme_idx);
+void fman_kg_init(struct fman_kg_regs *regs,
+			uint32_t exceptions,
+			uint32_t dflt_nia);
+void fman_kg_enable_scheme_interrupts(struct fman_kg_regs *regs);
+void fman_kg_enable(struct fman_kg_regs *regs);
+void fman_kg_disable(struct fman_kg_regs *regs);
+int fman_kg_write_bind_cls_plans(struct fman_kg_regs *regs,
+					uint8_t hwport_id,
+					uint32_t bind_cls_plans);
+int fman_kg_build_bind_cls_plans(uint8_t grp_base,
+					uint8_t grp_mask,
+					uint32_t *bind_cls_plans);
+int fman_kg_write_bind_schemes(struct fman_kg_regs *regs,
+				uint8_t hwport_id,
+				uint32_t schemes);
+int fman_kg_write_cls_plan(struct fman_kg_regs *regs,
+				uint8_t grp_id,
+				uint8_t entries_mask,
+				uint8_t hwport_id,
+				struct fman_kg_cp_regs *cls_plan_regs);
+int fman_kg_build_cls_plan(struct fman_kg_cls_plan_params *params,
+				struct fman_kg_cp_regs *cls_plan_regs);
+uint32_t fman_kg_get_schemes_total_counter(struct fman_kg_regs *regs);
+int fman_kg_set_scheme_counter(struct fman_kg_regs *regs,
+				uint8_t scheme_id,
+				uint8_t hwport_id,
+				uint32_t counter);
+int fman_kg_get_scheme_counter(struct fman_kg_regs *regs,
+				uint8_t scheme_id,
+				uint8_t hwport_id,
+				uint32_t *counter);
+int fman_kg_delete_scheme(struct fman_kg_regs *regs,
+				uint8_t scheme_id,
+				uint8_t hwport_id);
+int fman_kg_write_scheme(struct fman_kg_regs *regs,
+				uint8_t scheme_id,
+				uint8_t hwport_id,
+				struct fman_kg_scheme_regs *scheme_regs,
+				bool update_counter);
+int fman_kg_build_scheme(struct fman_kg_scheme_params *params,
+				struct fman_kg_scheme_regs *scheme_regs);
+void fman_kg_get_capture(struct fman_kg_regs *regs,
+				struct fman_kg_ex_ecc_attr *ecc_attr,
+				bool clear);
+void fman_kg_get_exception(struct fman_kg_regs *regs,
+				uint32_t *events,
+				uint32_t *scheme_ids,
+				bool clear);
+void fman_kg_set_exception(struct fman_kg_regs *regs,
+				uint32_t exception,
+				bool enable);
+void fman_kg_set_dflt_val(struct fman_kg_regs *regs,
+				uint8_t def_id,
+				uint32_t val);
+void fman_kg_set_data_after_prs(struct fman_kg_regs *regs, uint8_t offset);
+
+
+	
+/**************************************************************************//**
+  @Description       NIA Description
+*//***************************************************************************/
+#define KG_NIA_ORDER_RESTOR	0x00800000
+#define KG_NIA_ENG_FM_CTL	0x00000000
+#define KG_NIA_ENG_PRS		0x00440000
+#define KG_NIA_ENG_KG		0x00480000
+#define KG_NIA_ENG_PLCR		0x004C0000
+#define KG_NIA_ENG_BMI		0x00500000
+#define KG_NIA_ENG_QMI_ENQ	0x00540000
+#define KG_NIA_ENG_QMI_DEQ	0x00580000
+#define KG_NIA_ENG_MASK		0x007C0000
+
+#define KG_NIA_AC_MASK		0x0003FFFF
+
+#define KG_NIA_INVALID		0xFFFFFFFF
+
+static __inline__ uint32_t fm_kg_build_nia(enum fman_pcd_engine next_engine,
+					uint32_t next_engine_action)
+{
+	uint32_t nia;
+
+	if (next_engine_action & ~KG_NIA_AC_MASK)
+		return KG_NIA_INVALID;
+
+	switch (next_engine) {
+	case E_FMAN_PCD_DONE:
+		nia = KG_NIA_ENG_BMI | next_engine_action;
+		break;
+
+	case E_FMAN_PCD_KG:
+		nia = KG_NIA_ENG_KG | next_engine_action;
+		break;
+
+	case E_FMAN_PCD_CC:
+		nia = KG_NIA_ENG_FM_CTL | next_engine_action;
+		break;
+
+	case E_FMAN_PCD_PLCR:
+		nia = KG_NIA_ENG_PLCR | next_engine_action;
+		break;
+
+	default:
+		nia = KG_NIA_INVALID;
+	}
+
+	return nia;
+}
+
+#endif /* __FSL_FMAN_KG_H */
--- fmlib-fslsdk-v1.7/include/fmd/Peripherals/fsl_enet.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/Peripherals/fsl_enet.h	2022-05-26 11:28:31.086973166 -0700
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FSL_ENET_H
+#define __FSL_ENET_H
+
+/**
+ @Description  Ethernet MAC-PHY Interface
+*/
+
+enum enet_interface {
+	E_ENET_IF_MII		= 0x00010000, /**< MII interface */
+	E_ENET_IF_RMII		= 0x00020000, /**< RMII interface */
+	E_ENET_IF_SMII		= 0x00030000, /**< SMII interface */
+	E_ENET_IF_GMII		= 0x00040000, /**< GMII interface */
+	E_ENET_IF_RGMII		= 0x00050000, /**< RGMII interface */
+	E_ENET_IF_TBI		= 0x00060000, /**< TBI interface */
+	E_ENET_IF_RTBI		= 0x00070000, /**< RTBI interface */
+	E_ENET_IF_SGMII		= 0x00080000, /**< SGMII interface */
+	E_ENET_IF_XGMII		= 0x00090000, /**< XGMII interface */
+	E_ENET_IF_QSGMII	= 0x000a0000, /**< QSGMII interface */
+	E_ENET_IF_XFI		= 0x000b0000  /**< XFI interface */
+};
+
+/**
+ @Description  Ethernet Speed (nominal data rate)
+*/
+enum enet_speed {
+	E_ENET_SPEED_10		= 10,	/**< 10 Mbps */
+	E_ENET_SPEED_100	= 100,	/**< 100 Mbps */
+	E_ENET_SPEED_1000	= 1000,	/**< 1000 Mbps = 1 Gbps */
+	E_ENET_SPEED_10000	= 10000	/**< 10000 Mbps = 10 Gbps */
+};
+
+enum mac_stat_level {
+	/* No statistics */
+	E_MAC_STAT_NONE = 0,
+	/* Only RMON MIB group 1 (ether stats). Optimized for performance */
+	E_MAC_STAT_MIB_GRP1,
+	/* Only error counters are available. Optimized for performance */
+	E_MAC_STAT_PARTIAL,
+	/* All counters available. Not optimized for performance */
+	E_MAC_STAT_FULL
+};
+
+
+#endif /* __FSL_ENET_H */
--- fmlib-fslsdk-v1.7/include/fmd/Peripherals/fm_port_ext.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/Peripherals/fm_port_ext.h	2022-05-26 11:28:31.086973166 -0700
@@ -0,0 +1,2576 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/**************************************************************************//**
+ @File          fm_port_ext.h
+
+ @Description   FM-Port Application Programming Interface.
+*//***************************************************************************/
+#ifndef __FM_PORT_EXT
+#define __FM_PORT_EXT
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_ext.h"
+#include "net_ext.h"
+
+
+/**************************************************************************//**
+
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_PORT_grp FM Port
+
+ @Description   FM Port API
+
+                The FM uses a general module called "port" to represent a Tx port
+                (MAC), an Rx port (MAC) or Offline Parsing port.
+                The number of ports in an FM varies between SOCs.
+                The SW driver manages these ports as sub-modules of the FM, i.e.
+                after an FM is initialized, its ports may be initialized and
+                operated upon.
+
+                The port is initialized aware of its type, but other functions on
+                a port may be indifferent to its type. When necessary, the driver
+                verifies coherence and returns error if applicable.
+
+                On initialization, user specifies the port type and it's index
+                (relative to the port's type) - always starting at 0.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   An enum for defining port PCD modes.
+                This enum defines the superset of PCD engines support - i.e. not
+                all engines have to be used, but all have to be enabled. The real
+                flow of a specific frame depends on the PCD configuration and the
+                frame headers and payload.
+                Note: the first engine and the first engine after the parser (if
+                exists) should be in order, the order is important as it will
+                define the flow of the port. However, as for the rest engines
+                (the ones that follows), the order is not important anymore as
+                it is defined by the PCD graph itself.
+*//***************************************************************************/
+typedef enum e_FmPortPcdSupport {
+      e_FM_PORT_PCD_SUPPORT_NONE = 0                /**< BMI to BMI, PCD is not used */
+    , e_FM_PORT_PCD_SUPPORT_PRS_ONLY                /**< Use only Parser */
+    , e_FM_PORT_PCD_SUPPORT_PLCR_ONLY               /**< Use only Policer */
+    , e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR            /**< Use Parser and Policer */
+    , e_FM_PORT_PCD_SUPPORT_PRS_AND_KG              /**< Use Parser and Keygen */
+    , e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC       /**< Use Parser, Keygen and Coarse Classification */
+    , e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR
+                                                    /**< Use all PCD engines */
+    , e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR     /**< Use Parser, Keygen and Policer */
+    , e_FM_PORT_PCD_SUPPORT_PRS_AND_CC              /**< Use Parser and Coarse Classification */
+    , e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR     /**< Use Parser and Coarse Classification and Policer */
+    , e_FM_PORT_PCD_SUPPORT_CC_ONLY                 /**< Use only Coarse Classification */
+#ifdef FM_CAPWAP_SUPPORT
+    , e_FM_PORT_PCD_SUPPORT_CC_AND_KG               /**< Use Coarse Classification,and Keygen */
+    , e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR      /**< Use Coarse Classification, Keygen and Policer */
+#endif /* FM_CAPWAP_SUPPORT */
+} e_FmPortPcdSupport;
+
+/**************************************************************************//**
+ @Description   Port interrupts
+*//***************************************************************************/
+typedef enum e_FmPortExceptions {
+    e_FM_PORT_EXCEPTION_IM_BUSY                 /**< Independent-Mode Rx-BUSY */
+} e_FmPortExceptions;
+
+
+/**************************************************************************//**
+ @Collection    General FM Port defines
+*//***************************************************************************/
+#define FM_PORT_PRS_RESULT_NUM_OF_WORDS     8   /**< Number of 4 bytes words in parser result */
+/* @} */
+
+/**************************************************************************//**
+ @Collection   FM Frame error
+*//***************************************************************************/
+typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef for defining Frame Descriptor errors */
+
+#define FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT      FM_FD_ERR_UNSUPPORTED_FORMAT    /**< Not for Rx-Port! Unsupported Format */
+#define FM_PORT_FRM_ERR_LENGTH                  FM_FD_ERR_LENGTH                /**< Not for Rx-Port! Length Error */
+#define FM_PORT_FRM_ERR_DMA                     FM_FD_ERR_DMA                   /**< DMA Data error */
+#define FM_PORT_FRM_ERR_NON_FM                  FM_FD_RX_STATUS_ERR_NON_FM      /**< non Frame-Manager error; probably come from SEC that
+                                                                                     was chained to FM */
+
+#define FM_PORT_FRM_ERR_IPRE                    (FM_FD_ERR_IPR & ~FM_FD_IPR)        /**< IPR error */
+#define FM_PORT_FRM_ERR_IPR_NCSP                (FM_FD_ERR_IPR_NCSP & ~FM_FD_IPR)   /**< IPR non-consistent-sp */
+
+#define FM_PORT_FRM_ERR_IPFE                    0                                   /**< Obsolete; will be removed in the future */
+
+#ifdef FM_CAPWAP_SUPPORT
+#define FM_PORT_FRM_ERR_CRE                     FM_FD_ERR_CRE
+#define FM_PORT_FRM_ERR_CHE                     FM_FD_ERR_CHE
+#endif /* FM_CAPWAP_SUPPORT */
+
+#define FM_PORT_FRM_ERR_PHYSICAL                FM_FD_ERR_PHYSICAL              /**< Rx FIFO overflow, FCS error, code error, running disparity
+                                                                                     error (SGMII and TBI modes), FIFO parity error. PHY
+                                                                                     Sequence error, PHY error control character detected. */
+#define FM_PORT_FRM_ERR_SIZE                    FM_FD_ERR_SIZE                  /**< Frame too long OR Frame size exceeds max_length_frame  */
+#define FM_PORT_FRM_ERR_CLS_DISCARD             FM_FD_ERR_CLS_DISCARD           /**< indicates a classifier "drop" operation */
+#define FM_PORT_FRM_ERR_EXTRACTION              FM_FD_ERR_EXTRACTION            /**< Extract Out of Frame */
+#define FM_PORT_FRM_ERR_NO_SCHEME               FM_FD_ERR_NO_SCHEME             /**< No Scheme Selected */
+#define FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW        FM_FD_ERR_KEYSIZE_OVERFLOW      /**< Keysize Overflow */
+#define FM_PORT_FRM_ERR_COLOR_RED               FM_FD_ERR_COLOR_RED             /**< Frame color is red */
+#define FM_PORT_FRM_ERR_COLOR_YELLOW            FM_FD_ERR_COLOR_YELLOW          /**< Frame color is yellow */
+#define FM_PORT_FRM_ERR_ILL_PLCR                FM_FD_ERR_ILL_PLCR              /**< Illegal Policer Profile selected */
+#define FM_PORT_FRM_ERR_PLCR_FRAME_LEN          FM_FD_ERR_PLCR_FRAME_LEN        /**< Policer frame length error */
+#define FM_PORT_FRM_ERR_PRS_TIMEOUT             FM_FD_ERR_PRS_TIMEOUT           /**< Parser Time out Exceed */
+#define FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT        FM_FD_ERR_PRS_ILL_INSTRUCT      /**< Invalid Soft Parser instruction */
+#define FM_PORT_FRM_ERR_PRS_HDR_ERR             FM_FD_ERR_PRS_HDR_ERR           /**< Header error was identified during parsing */
+#define FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED    FM_FD_ERR_BLOCK_LIMIT_EXCEEDED  /**< Frame parsed beyind 256 first bytes */
+#define FM_PORT_FRM_ERR_PROCESS_TIMEOUT         0x00000001                      /**< FPM Frame Processing Timeout Exceeded */
+/* @} */
+
+
+
+/**************************************************************************//**
+ @Group         FM_PORT_init_grp FM Port Initialization Unit
+
+ @Description   FM Port Initialization Unit
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+
+ @Param[in]     h_App      - User's application descriptor.
+ @Param[in]     exception  - The exception.
+  *//***************************************************************************/
+typedef void (t_FmPortExceptionCallback) (t_Handle h_App, e_FmPortExceptions exception);
+
+/**************************************************************************//**
+ @Description   User callback function called by driver with received data.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_App           Application's handle originally specified to
+                                the API Config function
+ @Param[in]     p_Data          A pointer to data received
+ @Param[in]     length          length of received data
+ @Param[in]     status          receive status and errors
+ @Param[in]     position        position of buffer in frame
+ @Param[in]     h_BufContext    A handle of the user acossiated with this buffer
+
+ @Retval        e_RX_STORE_RESPONSE_CONTINUE - order the driver to continue Rx
+                                               operation for all ready data.
+ @Retval        e_RX_STORE_RESPONSE_PAUSE    - order the driver to stop Rx operation.
+*//***************************************************************************/
+typedef e_RxStoreResponse (t_FmPortImRxStoreCallback) (t_Handle h_App,
+                                                       uint8_t  *p_Data,
+                                                       uint16_t length,
+                                                       uint16_t status,
+                                                       uint8_t  position,
+                                                       t_Handle h_BufContext);
+
+/**************************************************************************//**
+ @Description   User callback function called by driver when transmit completed.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_App           Application's handle originally specified to
+                                the API Config function
+ @Param[in]     p_Data          A pointer to data received
+ @Param[in]     status          transmit status and errors
+ @Param[in]     lastBuffer      is last buffer in frame
+ @Param[in]     h_BufContext    A handle of the user acossiated with this buffer
+ *//***************************************************************************/
+typedef void (t_FmPortImTxConfCallback) (t_Handle   h_App,
+                                         uint8_t    *p_Data,
+                                         uint16_t   status,
+                                         t_Handle   h_BufContext);
+
+/**************************************************************************//**
+ @Description   A structure for additional Rx port parameters
+*//***************************************************************************/
+typedef struct t_FmPortRxParams {
+    uint32_t                errFqid;            /**< Error Queue Id. */
+    uint32_t                dfltFqid;           /**< Default Queue Id.  */
+    uint16_t                liodnOffset;        /**< Port's LIODN offset. */
+    t_FmExtPools            extBufPools;        /**< Which external buffer pools are used
+                                                     (up to FM_PORT_MAX_NUM_OF_EXT_POOLS), and their sizes. */
+} t_FmPortRxParams;
+
+/**************************************************************************//**
+ @Description   A structure for additional non-Rx port parameters
+*//***************************************************************************/
+typedef struct t_FmPortNonRxParams {
+    uint32_t                errFqid;            /**< Error Queue Id. */
+    uint32_t                dfltFqid;           /**< For Tx - Default Confirmation queue,
+                                                     0 means no Tx confirmation for processed
+                                                     frames. For OP port - default Rx queue. */
+    uint32_t                qmChannel;          /**< QM-channel dedicated to this port; will be used
+                                                     by the FM for dequeue. */
+} t_FmPortNonRxParams;
+
+/**************************************************************************//**
+ @Description   A structure for additional Rx port parameters
+*//***************************************************************************/
+typedef struct t_FmPortImRxTxParams {
+    t_Handle                    h_FmMuram;          /**< A handle of the FM-MURAM partition */
+    uint16_t                    liodnOffset;        /**< For Rx ports only. Port's LIODN Offset. */
+    uint8_t                     dataMemId;          /**< Memory partition ID for data buffers */
+    uint32_t                    dataMemAttributes;  /**< Memory attributes for data buffers */
+    t_BufferPoolInfo            rxPoolParams;       /**< For Rx ports only. */
+    t_FmPortImRxStoreCallback   *f_RxStore;         /**< For Rx ports only. */
+    t_FmPortImTxConfCallback    *f_TxConf;          /**< For Tx ports only. */
+} t_FmPortImRxTxParams;
+
+/**************************************************************************//**
+ @Description   A union for additional parameters depending on port type
+*//***************************************************************************/
+typedef union u_FmPortSpecificParams {
+    t_FmPortImRxTxParams        imRxTxParams;       /**< Rx/Tx Independent-Mode port parameter structure */
+    t_FmPortRxParams            rxParams;           /**< Rx port parameters structure */
+    t_FmPortNonRxParams         nonRxParams;        /**< Non-Rx port parameters structure */
+} u_FmPortSpecificParams;
+
+/**************************************************************************//**
+ @Description   A structure representing FM initialization parameters
+*//***************************************************************************/
+typedef struct t_FmPortParams {
+    uintptr_t                   baseAddr;           /**< Virtual Address of memory mapped FM Port registers.*/
+    t_Handle                    h_Fm;               /**< A handle to the FM object this port related to */
+    e_FmPortType                portType;           /**< Port type */
+    uint8_t                     portId;             /**< Port Id - relative to type;
+                                                         NOTE: When configuring Offline Parsing port for
+                                                         FMANv3 devices (DPAA_VERSION 11 and higher),
+                                                         it is highly recommended NOT to use portId=0 due to lack
+                                                         of HW resources on portId=0. */
+    bool                        independentModeEnable;
+                                                    /**< This port is Independent-Mode - Used for Rx/Tx ports only! */
+    uint16_t                    liodnBase;          /**< Irrelevant for P4080 rev 1. LIODN base for this port, to be
+                                                         used together with LIODN offset. */
+    u_FmPortSpecificParams      specificParams;     /**< Additional parameters depending on port
+                                                         type. */
+
+    t_FmPortExceptionCallback   *f_Exception;       /**< Relevant for IM only Callback routine to be called on BUSY exception */
+    t_Handle                    h_App;              /**< A handle to an application layer object; This handle will
+                                                         be passed by the driver upon calling the above callbacks */
+} t_FmPortParams;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_Config
+
+ @Description   Creates a descriptor for the FM PORT module.
+
+                The routine returns a handle (descriptor) to the FM PORT object.
+                This descriptor must be passed as first parameter to all other
+                FM PORT function calls.
+
+                No actual initialization or configuration of FM hardware is
+                done by this routine.
+
+ @Param[in]     p_FmPortParams   - Pointer to data structure of parameters
+
+ @Retval        Handle to FM object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams);
+
+/**************************************************************************//**
+ @Function      FM_PORT_Init
+
+ @Description   Initializes the FM PORT module by defining the software structure
+                and configuring the hardware registers.
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PORT_Init(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_Free
+
+ @Description   Frees all resources that were assigned to FM PORT module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PORT_Free(t_Handle h_FmPort);
+
+t_Handle FM_PORT_Open(t_FmPortParams *p_FmPortParams);
+void FM_PORT_Close(t_Handle h_FmPort);
+
+
+
+/**************************************************************************//**
+ @Group         FM_PORT_advanced_init_grp    FM Port Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for defining QM frame dequeue
+*//***************************************************************************/
+typedef enum e_FmPortDeqType {
+   e_FM_PORT_DEQ_TYPE1,             /**< Dequeue from the SP channel - with priority precedence,
+                                         and Intra-Class Scheduling respected. */
+   e_FM_PORT_DEQ_TYPE2,             /**< Dequeue from the SP channel - with active FQ precedence,
+                                         and Intra-Class Scheduling respected. */
+   e_FM_PORT_DEQ_TYPE3              /**< Dequeue from the SP channel - with active FQ precedence,
+                                         and override Intra-Class Scheduling */
+} e_FmPortDeqType;
+
+/**************************************************************************//**
+ @Description   enum for defining QM frame dequeue
+*//***************************************************************************/
+typedef enum e_FmPortDeqPrefetchOption {
+   e_FM_PORT_DEQ_NO_PREFETCH,       /**< QMI preforms a dequeue action for a single frame
+                                         only when a dedicated portID Tnum is waiting. */
+   e_FM_PORT_DEQ_PARTIAL_PREFETCH,  /**< QMI preforms a dequeue action for 3 frames when
+                                         one dedicated portId tnum is waiting. */
+   e_FM_PORT_DEQ_FULL_PREFETCH      /**< QMI preforms a dequeue action for 3 frames when
+                                         no dedicated portId tnums are waiting. */
+
+} e_FmPortDeqPrefetchOption;
+
+/**************************************************************************//**
+ @Description   enum for defining port default color
+*//***************************************************************************/
+typedef enum e_FmPortColor {
+    e_FM_PORT_COLOR_GREEN,          /**< Default port color is green */
+    e_FM_PORT_COLOR_YELLOW,         /**< Default port color is yellow */
+    e_FM_PORT_COLOR_RED,            /**< Default port color is red */
+    e_FM_PORT_COLOR_OVERRIDE        /**< Ignore color */
+} e_FmPortColor;
+
+/**************************************************************************//**
+ @Description   A structure for defining Dual Tx rate limiting scale
+*//***************************************************************************/
+typedef enum e_FmPortDualRateLimiterScaleDown {
+    e_FM_PORT_DUAL_RATE_LIMITER_NONE = 0,           /**< Use only single rate limiter  */
+    e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2,    /**< Divide high rate limiter by 2 */
+    e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4,    /**< Divide high rate limiter by 4 */
+    e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8     /**< Divide high rate limiter by 8 */
+} e_FmPortDualRateLimiterScaleDown;
+
+
+/**************************************************************************//**
+ @Description   A structure for defining FM port resources
+*//***************************************************************************/
+typedef struct t_FmPortRsrc {
+    uint32_t    num;                /**< Committed required resource */
+    uint32_t    extra;              /**< Extra (not committed) required resource */
+} t_FmPortRsrc;
+
+/**************************************************************************//**
+ @Description   A structure for defining observed pool depletion
+*//***************************************************************************/
+typedef struct t_FmPortObservedBufPoolDepletion {
+    t_FmBufPoolDepletion    poolDepletionParams;/**< parameters to define pool depletion */
+    t_FmExtPools            poolsParams;        /**< Which external buffer pools are observed
+                                                     (up to FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS),
+                                                     and their sizes. */
+} t_FmPortObservedBufPoolDepletion;
+
+/**************************************************************************//**
+ @Description   A structure for defining Tx rate limiting
+*//***************************************************************************/
+typedef struct t_FmPortRateLimit {
+    uint16_t                            maxBurstSize;           /**< in KBytes for Tx ports, in frames
+                                                                     for OP ports. (note that
+                                                                     for early chips burst size is
+                                                                     rounded up to a multiply of 1000 frames).*/
+    uint32_t                            rateLimit;              /**< in Kb/sec for Tx ports, in frame/sec for
+                                                                     OP ports. Rate limit refers to
+                                                                     data rate (rather than line rate). */
+    e_FmPortDualRateLimiterScaleDown    rateLimitDivider;       /**< For OP ports only. Not-valid
+                                                                     for some earlier chip revisions */
+} t_FmPortRateLimit;
+
+/**************************************************************************//**
+ @Description   A structure for defining the parameters of
+                the Rx port performance counters
+*//***************************************************************************/
+typedef struct t_FmPortPerformanceCnt {
+    uint8_t     taskCompVal;            /**< Task compare value */
+    uint8_t     queueCompVal;           /**< Rx queue/Tx confirm queue compare
+                                             value (unused for H/O) */
+    uint8_t     dmaCompVal;             /**< Dma compare value */
+    uint32_t    fifoCompVal;            /**< Fifo compare value (in bytes) */
+} t_FmPortPerformanceCnt;
+
+
+/**************************************************************************//**
+ @Description   A structure for defining the sizes of the Deep Sleep
+                the Auto Response tables
+*//***************************************************************************/
+typedef struct t_FmPortDsarTablesSizes
+{
+    uint16_t   maxNumOfArpEntries;
+    uint16_t   maxNumOfEchoIpv4Entries;
+    uint16_t   maxNumOfNdpEntries;
+    uint16_t   maxNumOfEchoIpv6Entries;
+    uint16_t   maxNumOfSnmpIPV4Entries;
+    uint16_t   maxNumOfSnmpIPV6Entries;
+    uint16_t   maxNumOfSnmpOidEntries;
+    uint16_t   maxNumOfSnmpOidChar; /* total amount of character needed for the snmp table */
+
+    uint16_t   maxNumOfIpProtFiltering;
+    uint16_t   maxNumOfTcpPortFiltering;
+    uint16_t   maxNumOfUdpPortFiltering;
+} t_FmPortDsarTablesSizes;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDsarSupport
+
+ @Description   This function will allocate the amount of MURAM needed for
+                this max number of entries for Deep Sleep Auto Response.
+                it will calculate all needed MURAM for autoresponse including
+                necesary common stuff.
+
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     params      A pointer to a structure containing the maximum
+                            sizes of the auto response tables
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDsarSupport(t_Handle h_FmPortRx, t_FmPortDsarTablesSizes *params);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigNumOfOpenDmas
+
+ @Description   Calling this routine changes the max number of open DMA's
+                available for this port. It changes this parameter in the
+                internal driver data base from its default configuration
+                [OP: 1]
+                [1G-RX, 1G-TX: 1 (+1)]
+                [10G-RX, 10G-TX: 8 (+8)]
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     p_OpenDmas  A pointer to a structure of parameters defining
+                            the open DMA allocation.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_OpenDmas);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigNumOfTasks
+
+ @Description   Calling this routine changes the max number of tasks
+                available for this port. It changes this parameter in the
+                internal driver data base from its default configuration
+                [OP: 1]
+                [1G-RX, 1G-TX: 3 (+2)]
+                [10G-RX, 10G-TX: 16 (+8)]
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_NumOfTasks    A pointer to a structure of parameters defining
+                                the tasks allocation.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigSizeOfFifo
+
+ @Description   Calling this routine changes the max FIFO size configured for this port.
+
+                This function changes the internal driver data base from its
+                default configuration. Please refer to the driver's User Guide for
+                information on default FIFO sizes in the various devices.
+                [OP: 2KB]
+                [1G-RX, 1G-TX: 11KB]
+                [10G-RX, 10G-TX: 12KB]
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_SizeOfFifo    A pointer to a structure of parameters defining
+                                the FIFO allocation.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDeqHighPriority
+
+ @Description   Calling this routine changes the dequeue priority in the
+                internal driver data base from its default configuration
+                1G: [DEFAULT_PORT_deqHighPriority_1G]
+                10G: [DEFAULT_PORT_deqHighPriority_10G]
+
+                May be used for Non-Rx ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     highPri     TRUE to select high priority, FALSE for normal operation.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDeqType
+
+ @Description   Calling this routine changes the dequeue type parameter in the
+                internal driver data base from its default configuration
+                [DEFAULT_PORT_deqType].
+
+                May be used for Non-Rx ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     deqType     According to QM definition.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDeqPrefetchOption
+
+ @Description   Calling this routine changes the dequeue prefetch option parameter in the
+                internal driver data base from its default configuration
+                [DEFAULT_PORT_deqPrefetchOption]
+                Note: Available for some chips only
+
+                May be used for Non-Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     deqPrefetchOption   New option
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOption deqPrefetchOption);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDeqByteCnt
+
+ @Description   Calling this routine changes the dequeue byte count parameter in
+                the internal driver data base from its default configuration
+                1G:[DEFAULT_PORT_deqByteCnt_1G].
+                10G:[DEFAULT_PORT_deqByteCnt_10G].
+
+                May be used for Non-Rx ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     deqByteCnt      New byte count
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigBufferPrefixContent
+
+ @Description   Defines the structure, size and content of the application buffer.
+                The prefix will
+                In Tx ports, if 'passPrsResult', the application
+                should set a value to their offsets in the prefix of
+                the FM will save the first 'privDataSize', than,
+                depending on 'passPrsResult' and 'passTimeStamp', copy parse result
+                and timeStamp, and the packet itself (in this order), to the
+                application buffer, and to offset.
+                Calling this routine changes the buffer margins definitions
+                in the internal driver data base from its default
+                configuration: Data size:  [DEFAULT_PORT_bufferPrefixContent_privDataSize]
+                               Pass Parser result: [DEFAULT_PORT_bufferPrefixContent_passPrsResult].
+                               Pass timestamp: [DEFAULT_PORT_bufferPrefixContent_passTimeStamp].
+
+                May be used for all ports
+
+ @Param[in]     h_FmPort                        A handle to a FM Port module.
+ @Param[in,out] p_FmBufferPrefixContent         A structure of parameters describing the
+                                                structure of the buffer.
+                                                Out parameter: Start margin - offset
+                                                of data from start of external buffer.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle                      h_FmPort,
+                                          t_FmBufferPrefixContent       *p_FmBufferPrefixContent);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigCheksumLastBytesIgnore
+
+ @Description   Calling this routine changes the number of checksum bytes to ignore
+                parameter in the internal driver data base from its default configuration
+                [DEFAULT_PORT_cheksumLastBytesIgnore]
+
+                May be used by Tx & Rx ports only
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     cheksumLastBytesIgnore  New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort, uint8_t cheksumLastBytesIgnore);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigCutBytesFromEnd
+
+ @Description   Calling this routine changes the number of bytes to cut from a
+                frame's end parameter in the internal driver data base
+                from its default configuration [DEFAULT_PORT_cutBytesFromEnd]
+                Note that if the result of (frame length before chop - cutBytesFromEnd) is
+                less than 14 bytes, the chop operation is not executed.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     cutBytesFromEnd     New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigPoolDepletion
+
+ @Description   Calling this routine enables pause frame generation depending on the
+                depletion status of BM pools. It also defines the conditions to activate
+                this functionality. By default, this functionality is disabled.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     p_BufPoolDepletion      A structure of pool depletion parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmBufPoolDepletion *p_BufPoolDepletion);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigObservedPoolDepletion
+
+ @Description   Calling this routine enables a mechanism to stop port enqueue
+                depending on the depletion status of selected BM pools.
+                It also defines the conditions to activate
+                this functionality. By default, this functionality is disabled.
+
+                Note: Available for some chips only
+
+                May be used for OP ports only
+
+ @Param[in]     h_FmPort                            A handle to a FM Port module.
+ @Param[in]     p_FmPortObservedBufPoolDepletion    A structure of parameters for pool depletion.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigObservedPoolDepletion(t_Handle                            h_FmPort,
+                                            t_FmPortObservedBufPoolDepletion    *p_FmPortObservedBufPoolDepletion);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigExtBufPools
+
+ @Description   This routine should be called for OP ports
+                that internally use BM buffer pools. In such cases, e.g. for fragmentation and
+                re-assembly, the FM needs new BM buffers. By calling this routine the user
+                specifies the BM buffer pools that should be used.
+
+                Note: Available for some chips only
+
+                May be used for OP ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_FmExtPools        A structure of parameters for the external pools.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmExtPools *p_FmExtPools);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigBackupPools
+
+ @Description   Calling this routine allows the configuration of some of the BM pools
+                defined for this port as backup pools.
+                A pool configured to be a backup pool will be used only if all other
+                enabled non-backup pools are depleted.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     p_FmPortBackupBmPools   An array of pool id's. All pools specified here will
+                                        be defined as backup pools.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmBackupBmPools *p_FmPortBackupBmPools);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigFrmDiscardOverride
+
+ @Description   Calling this routine changes the error frames destination parameter
+                in the internal driver data base from its default configuration:
+                override = [DEFAULT_PORT_frmDiscardOverride]
+
+                May be used for Rx and OP ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     override    TRUE to override discarding of error frames and
+                            enqueueing them to error queue.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigErrorsToDiscard
+
+ @Description   Calling this routine changes the behaviour on error parameter
+                in the internal driver data base from its default configuration:
+                [DEFAULT_PORT_errorsToDiscard].
+                If a requested error was previously defined as "ErrorsToEnqueue" it's
+                definition will change and the frame will be discarded.
+                Errors that were not defined either as "ErrorsToEnqueue" nor as
+                "ErrorsToDiscard", will be forwarded to CPU.
+
+                May be used for Rx and OP ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     errs        A list of errors to discard
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaSwapData
+
+ @Description   Calling this routine changes the DMA swap data aparameter
+                in the internal driver data base from its default
+                configuration  [DEFAULT_PORT_dmaSwapData]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     swapData    New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmDmaSwapOption swapData);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaIcCacheAttr
+
+ @Description   Calling this routine changes the internal context cache
+                attribute parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_dmaIntContextCacheAttr]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort               A handle to a FM Port module.
+ @Param[in]     intContextCacheAttr    New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmDmaCacheOption intContextCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaHdrAttr
+
+ @Description   Calling this routine changes the header cache
+                attribute parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_dmaHeaderCacheAttr]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                    A handle to a FM Port module.
+ @Param[in]     headerCacheAttr             New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmDmaCacheOption headerCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaScatterGatherAttr
+
+ @Description   Calling this routine changes the scatter gather cache
+                attribute parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_dmaScatterGatherCacheAttr]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                    A handle to a FM Port module.
+ @Param[in]     scatterGatherCacheAttr      New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmDmaCacheOption scatterGatherCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaWriteOptimize
+
+ @Description   Calling this routine changes the write optimization
+                parameter in the internal driver data base
+                from its default configuration:  By default optimize = [DEFAULT_PORT_dmaWriteOptimize].
+                Note:
+
+                1. For head optimization, data alignment must be >= 16 (supported by default).
+
+                3. For tail optimization, note that the optimization is performed by extending the write transaction
+                of the frame payload at the tail as needed to achieve optimal bus transfers, so that the last write
+                is extended to be on 16/64 bytes aligned block (chip dependent).
+
+                Relevant for non-Tx port types
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     optimize    TRUE to enable optimization, FALSE for normal operation
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigNoScatherGather
+
+ @Description    Calling this routine changes the noScatherGather parameter in internal driver data base
+                 from its default configuration.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     noScatherGather (TRUE - frame is discarded if can not be stored in single buffer,
+                                 FALSE - frame can be stored in scatter gather (S/G) format).
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigNoScatherGather(t_Handle h_FmPort, bool noScatherGather);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDfltColor
+
+ @Description   Calling this routine changes the internal default color parameter
+                in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_color]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     color           New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDfltColor(t_Handle h_FmPort, e_FmPortColor color);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigSyncReq
+
+ @Description   Calling this routine changes the synchronization attribute parameter
+                in the internal driver data base from its default configuration:
+                syncReq = [DEFAULT_PORT_syncReq]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     syncReq         TRUE to request synchronization, FALSE otherwize.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigForwardReuseIntContext
+
+ @Description   This routine is relevant for Rx ports that are routed to OP port.
+                It changes the internal context reuse option in the internal
+                driver data base from its default configuration:
+                reuse = [DEFAULT_PORT_forwardIntContextReuse]
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     reuse           TRUE to reuse internal context on frames
+                                forwarded to OP port.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool reuse);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDontReleaseTxBufToBM
+
+ @Description   This routine should be called if no Tx confirmation
+                is done, and yet buffers should not be released to the BM.
+                Normally, buffers are returned using the Tx confirmation
+                process. When Tx confirmation is not used (defFqid=0),
+                buffers are typically released to the BM. This routine
+                may be called to avoid this behavior and not release the
+                buffers.
+
+                May be used for Tx ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDontReleaseTxBufToBM(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMMaxRxBufLength
+
+ @Description   Changes the maximum receive buffer length from its default
+                configuration: Closest rounded down power of 2 value of the
+                data buffer size.
+
+                The maximum receive buffer length directly affects the structure
+                of received frames (single- or multi-buffered) and the performance
+                of both the FM and the driver.
+
+                The selection between single- or multi-buffered frames should be
+                done according to the characteristics of the specific application.
+                The recommended mode is to use a single data buffer per packet,
+                as this mode provides the best performance. However, the user can
+                select to use multiple data buffers per packet.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     newVal          Maximum receive buffer length (in bytes).
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+t_Error FM_PORT_ConfigIMMaxRxBufLength(t_Handle h_FmPort, uint16_t newVal);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMRxBdRingLength
+
+ @Description   Changes the receive BD ring length from its default
+                configuration:[DEFAULT_PORT_rxBdRingLength]
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     newVal          The desired BD ring length.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+t_Error FM_PORT_ConfigIMRxBdRingLength(t_Handle h_FmPort, uint16_t newVal);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMTxBdRingLength
+
+ @Description   Changes the transmit BD ring length from its default
+                configuration:[DEFAULT_PORT_txBdRingLength]
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     newVal          The desired BD ring length.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+t_Error FM_PORT_ConfigIMTxBdRingLength(t_Handle h_FmPort, uint16_t newVal);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMFmanCtrlExternalStructsMemory
+
+ @Description   Configures memory partition and attributes for FMan-Controller
+                data structures (e.g. BD rings).
+                Calling this routine changes the internal driver data base
+                from its default configuration
+                [DEFAULT_PORT_ImfwExtStructsMemId, DEFAULT_PORT_ImfwExtStructsMemAttr].
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     memId           Memory partition ID.
+ @Param[in]     memAttributes   Memory attributes mask (a combination of MEMORY_ATTR_x flags).
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error  FM_PORT_ConfigIMFmanCtrlExternalStructsMemory(t_Handle h_FmPort,
+                                                       uint8_t  memId,
+                                                       uint32_t memAttributes);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMPolling
+
+ @Description   Changes the Rx flow from interrupt driven (default) to polling.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+t_Error FM_PORT_ConfigIMPolling(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigMaxFrameLength
+
+ @Description   Changes the definition of the max size of frame that should be
+                transmitted/received on this port from its default value [DEFAULT_PORT_maxFrameLength].
+                This parameter is used for confirmation of the minimum Fifo
+                size calculations and only for Tx ports or ports working in
+                independent mode. This should be larger than the maximum possible
+                MTU that will be used for this port (i.e. its MAC).
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     length          Max size of frame
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+t_Error FM_PORT_ConfigMaxFrameLength(t_Handle h_FmPort, uint16_t length);
+
+/**************************************************************************//*
+ @Function      FM_PORT_ConfigTxFifoMinFillLevel
+
+ @Description   Calling this routine changes the fifo minimum
+                fill level parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_txFifoMinFillLevel]
+
+                May be used for Tx ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     minFillLevel    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel);
+
+/**************************************************************************//*
+ @Function      FM_PORT_ConfigFifoDeqPipelineDepth
+
+ @Description   Calling this routine changes the fifo dequeue
+                pipeline depth parameter in the internal driver data base
+
+                from its default configuration: 1G ports: [DEFAULT_PORT_fifoDeqPipelineDepth_1G],
+                10G port: [DEFAULT_PORT_fifoDeqPipelineDepth_10G],
+                OP port: [DEFAULT_PORT_fifoDeqPipelineDepth_OH]
+
+                May be used for Tx/OP ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     deqPipelineDepth    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelineDepth);
+
+/**************************************************************************//*
+ @Function      FM_PORT_ConfigTxFifoLowComfLevel
+
+ @Description   Calling this routine changes the fifo low comfort level
+                parameter in internal driver data base
+                from its default configuration [DEFAULT_PORT_txFifoLowComfLevel]
+
+                May be used for Tx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fifoLowComfLevel    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComfLevel);
+
+/**************************************************************************//*
+ @Function      FM_PORT_ConfigRxFifoThreshold
+
+ @Description   Calling this routine changes the threshold of the FIFO
+                fill level parameter in the internal driver data base
+                from its default configuration [DEFAULT_PORT_rxFifoThreshold]
+
+                If the total number of buffers which are
+                currently in use and associated with the
+                specific RX port exceed this threshold, the
+                BMI will signal the MAC to send a pause frame
+                over the link.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fifoThreshold       New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold);
+
+/**************************************************************************//*
+ @Function      FM_PORT_ConfigRxFifoPriElevationLevel
+
+ @Description   Calling this routine changes the priority elevation level
+                parameter in the internal driver data base from its default
+                configuration  [DEFAULT_PORT_rxFifoPriElevationLevel]
+
+                If the total number of buffers which are currently in use and
+                associated with the specific RX port exceed the amount specified
+                in priElevationLevel, BMI will signal the main FM's DMA to
+                elevate the FM priority on the system bus.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     priElevationLevel   New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel);
+
+#ifdef FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
+/**************************************************************************//*
+ @Function      FM_PORT_ConfigBCBWorkaround
+
+ @Description   Configures BCB errata workaround.
+
+                When BCB errata is applicable, the workaround is always
+                performed by FM Controller. Thus, this functions doesn't
+                actually enable errata workaround but rather allows driver
+                to perform adjustments required due to errata workaround
+                execution in FM controller.
+
+                Applying BCB workaround also configures FM_PORT_FRM_ERR_PHYSICAL
+                errors to be discarded. Thus FM_PORT_FRM_ERR_PHYSICAL can't be
+                set by FM_PORT_SetErrorsRoute() function.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigBCBWorkaround(t_Handle h_FmPort);
+#endif /* FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669 */
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//*
+ @Function      FM_PORT_ConfigInternalBuffOffset
+
+ @Description   Configures internal buffer offset.
+
+                May be used for Rx and OP ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     val                 New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigInternalBuffOffset(t_Handle h_FmPort, uint8_t val);
+#endif /* (DPAA_VERSION >= 11) */
+
+/** @} */ /* end of FM_PORT_advanced_init_grp group */
+/** @} */ /* end of FM_PORT_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_PORT_runtime_control_grp FM Port Runtime Control Unit
+
+ @Description   FM Port Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for defining FM Port counters
+*//***************************************************************************/
+typedef enum e_FmPortCounters {
+    e_FM_PORT_COUNTERS_CYCLE,                       /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_TASK_UTIL,                   /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_QUEUE_UTIL,                  /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_DMA_UTIL,                    /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_FIFO_UTIL,                   /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION,         /**< BMI Rx only performance counter */
+    e_FM_PORT_COUNTERS_FRAME,                       /**< BMI statistics counter */
+    e_FM_PORT_COUNTERS_DISCARD_FRAME,               /**< BMI statistics counter */
+    e_FM_PORT_COUNTERS_DEALLOC_BUF,                 /**< BMI deallocate buffer statistics counter */
+    e_FM_PORT_COUNTERS_RX_BAD_FRAME,                /**< BMI Rx only statistics counter */
+    e_FM_PORT_COUNTERS_RX_LARGE_FRAME,              /**< BMI Rx only statistics counter */
+    e_FM_PORT_COUNTERS_RX_FILTER_FRAME,             /**< BMI Rx & OP only statistics counter */
+    e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,             /**< BMI Rx, OP & HC only statistics counter */
+    e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx, OP & HC statistics counter */
+    e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER,  /**< BMI Rx, OP & HC only statistics counter */
+    e_FM_PORT_COUNTERS_WRED_DISCARD,                /**< BMI OP & HC only statistics counter */
+    e_FM_PORT_COUNTERS_LENGTH_ERR,                  /**< BMI non-Rx statistics counter */
+    e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,           /**< BMI non-Rx statistics counter */
+    e_FM_PORT_COUNTERS_DEQ_TOTAL,                   /**< QMI total QM dequeues counter */
+    e_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI total QM enqueues counter */
+    e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,            /**< QMI counter */
+    e_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
+} e_FmPortCounters;
+
+
+/**************************************************************************//**
+ @Description   Structure for Port id parameters.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef struct t_FmPortCongestionGrps {
+    uint16_t    numOfCongestionGrpsToConsider;          /**< The number of required CGs
+                                                             to define the size of the following array */
+    uint8_t     congestionGrpsToConsider[FM_PORT_NUM_OF_CONGESTION_GRPS];
+                                                        /**< An array of CG indexes;
+                                                             Note that the size of the array should be
+                                                             'numOfCongestionGrpsToConsider'. */
+#if (DPAA_VERSION >= 11)
+    bool        pfcPrioritiesEn[FM_PORT_NUM_OF_CONGESTION_GRPS][FM_MAX_NUM_OF_PFC_PRIORITIES];
+                                                        /**< a matrix that represents the map between the CG ids
+                                                             defined in 'congestionGrpsToConsider' to the priorties
+                                                             mapping array. */
+#endif /* (DPAA_VERSION >= 11) */
+} t_FmPortCongestionGrps;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response ARP Entry
+*//***************************************************************************/
+typedef struct t_FmPortDsarArpEntry
+{
+    uint32_t  ipAddress;
+    uint8_t   mac[6];
+    bool      isVlan;
+    uint16_t  vid;
+} t_FmPortDsarArpEntry;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response ARP info
+*//***************************************************************************/
+typedef struct t_FmPortDsarArpInfo
+{
+    uint8_t           tableSize;
+    t_FmPortDsarArpEntry *p_AutoResTable;
+    bool              enableConflictDetection; /* when TRUE Conflict Detection will be checked and wake the host if needed */
+} t_FmPortDsarArpInfo;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response NDP Entry
+*//***************************************************************************/
+typedef struct t_FmPortDsarNdpEntry
+{
+    uint32_t  ipAddress[4];
+    uint8_t   mac[6];
+    bool      isVlan;
+    uint16_t  vid;
+} t_FmPortDsarNdpEntry;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response NDP info
+*//***************************************************************************/
+typedef struct t_FmPortDsarNdpInfo
+{
+    uint32_t              multicastGroup;
+
+    uint8_t               tableSizeAssigned;
+    t_FmPortDsarNdpEntry  *p_AutoResTableAssigned; /* This list refer to solicitation IP addresses.
+                                                                 Note that all IP adresses must be from the same multicast group.
+                                                                 This will be checked and if not operation will fail. */
+    uint8_t               tableSizeTmp;
+    t_FmPortDsarNdpEntry  *p_AutoResTableTmp;      /* This list refer to temp IP addresses.
+                                                             Note that all temp IP adresses must be from the same multicast group.
+                                                             This will be checked and if not operation will fail. */
+
+    bool                  enableConflictDetection; /* when TRUE Conflict Detection will be checked and wake the host if needed */
+
+} t_FmPortDsarNdpInfo;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response ICMPV4 info
+*//***************************************************************************/
+typedef struct t_FmPortDsarEchoIpv4Info
+{
+    uint8_t            tableSize;
+    t_FmPortDsarArpEntry  *p_AutoResTable;
+} t_FmPortDsarEchoIpv4Info;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response ICMPV6 info
+*//***************************************************************************/
+typedef struct t_FmPortDsarEchoIpv6Info
+{
+    uint8_t            tableSize;
+    t_FmPortDsarNdpEntry  *p_AutoResTable;
+} t_FmPortDsarEchoIpv6Info;
+
+/**************************************************************************//**
+@Description    Deep Sleep Auto Response SNMP OIDs table entry
+
+*//***************************************************************************/
+typedef struct {
+    uint16_t oidSize;     /**< Size in octets of the OID. */
+    uint16_t resSize;     /**< Size in octets of the value that is attached to the OID. */
+    uint8_t *p_Oid;       /**< Pointer to the OID. OID is encoded in BER but type and length are excluded. */
+    uint64_t resValOrPtr; /**< Value (for up to 4 octets) or pointer to the Value. Encoded in BER. */
+} t_FmPortDsarOidsEntry;
+
+/**************************************************************************//**
+ @Description   Deep Sleep Auto Response SNMP IPv4 Addresses Table Entry
+                Refer to the FMan Controller spec for more details.
+*//***************************************************************************/
+typedef struct
+{
+    uint32_t ipv4Addr; /*!< 32 bit IPv4 Address. */
+    bool      isVlan;
+    uint16_t vid;   /*!< 12 bits VLAN ID. The 4 left-most bits should be cleared                      */
+                       /*!< This field should be 0x0000 for an entry with no VLAN tag or a null VLAN ID. */
+} t_FmPortDsarSnmpIpv4AddrTblEntry;
+
+/**************************************************************************//**
+ @Description   Deep Sleep Auto Response SNMP IPv6 Addresses Table Entry
+                Refer to the FMan Controller spec for more details.
+*//***************************************************************************/
+typedef struct
+{
+    uint32_t ipv6Addr[4];  /*!< 4 * 32 bit IPv6 Address.                                                     */
+    bool      isVlan;
+    uint16_t vid;       /*!< 12 bits VLAN ID. The 4 left-most bits should be cleared                      */
+                           /*!< This field should be 0x0000 for an entry with no VLAN tag or a null VLAN ID. */
+} t_FmPortDsarSnmpIpv6AddrTblEntry;
+
+/**************************************************************************//**
+ @Description   Deep Sleep Auto Response SNMP Descriptor
+
+*//***************************************************************************/
+typedef struct
+{
+    uint16_t control;                          /**< Control bits [0-15]. */
+    uint16_t maxSnmpMsgLength;                 /**< Maximal allowed SNMP message length. */
+    uint16_t numOfIpv4Addresses;               /**< Number of entries in IPv4 addresses table. */
+    uint16_t numOfIpv6Addresses;               /**< Number of entries in IPv6 addresses table. */
+    t_FmPortDsarSnmpIpv4AddrTblEntry *p_Ipv4AddrTbl; /**< Pointer to IPv4 addresses table. */
+    t_FmPortDsarSnmpIpv6AddrTblEntry *p_Ipv6AddrTbl; /**< Pointer to IPv6 addresses table. */
+    uint8_t *p_RdOnlyCommunityStr;             /**< Pointer to the Read Only Community String. */
+    uint8_t *p_RdWrCommunityStr;               /**< Pointer to the Read Write Community String. */
+    t_FmPortDsarOidsEntry *p_OidsTbl;                 /**< Pointer to OIDs table. */
+    uint32_t oidsTblSize;                      /**< Number of entries in OIDs table. */
+} t_FmPortDsarSnmpInfo;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response filtering Entry
+*//***************************************************************************/
+typedef struct t_FmPortDsarFilteringEntry
+{
+    uint16_t    srcPort;
+    uint16_t    dstPort;
+    uint16_t    srcPortMask;
+    uint16_t    dstPortMask;
+} t_FmPortDsarFilteringEntry;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response filtering info
+*//***************************************************************************/
+typedef struct t_FmPortDsarFilteringInfo
+{
+    /* IP protocol filtering parameters */
+    uint8_t     ipProtTableSize;
+    uint8_t     *p_IpProtTablePtr;
+    bool        ipProtDropOnHit;  /* when TRUE, hit in the table will cause the packet to be droped,
+                                         miss will pass the packet to UDP/TCP filters if needed and if not
+                                         to the classification tree. If the classification tree will pass
+                                         the packet to a queue it will cause a wake interupt.
+                                         When FALSE it the other way around. */
+    /* UDP port filtering parameters */
+    uint8_t     udpPortsTableSize;
+    t_FmPortDsarFilteringEntry *p_UdpPortsTablePtr;
+    bool        udpPortDropOnHit; /* when TRUE, hit in the table will cause the packet to be droped,
+                                         miss will pass the packet to classification tree.
+                                         If the classification tree will pass the packet to a queue it
+                                         will cause a wake interupt.
+                                         When FALSE it the other way around. */
+    /* TCP port filtering parameters */
+    uint16_t    tcpFlagsMask;
+    uint8_t     tcpPortsTableSize;
+    t_FmPortDsarFilteringEntry *p_TcpPortsTablePtr;
+    bool        tcpPortDropOnHit; /* when TRUE, hit in the table will cause the packet to be droped,
+                                         miss will pass the packet to classification tree.
+                                         If the classification tree will pass the packet to a queue it
+                                         will cause a wake interupt.
+                                         When FALSE it the other way around. */
+} t_FmPortDsarFilteringInfo;
+
+/**************************************************************************//**
+ @Description   Structure for Deep Sleep Auto Response parameters
+*//***************************************************************************/
+typedef struct t_FmPortDsarParams
+{
+    t_Handle                  h_FmPortTx;
+    t_FmPortDsarArpInfo       *p_AutoResArpInfo;
+    t_FmPortDsarEchoIpv4Info  *p_AutoResEchoIpv4Info;
+    t_FmPortDsarNdpInfo       *p_AutoResNdpInfo;
+    t_FmPortDsarEchoIpv6Info  *p_AutoResEchoIpv6Info;
+    t_FmPortDsarSnmpInfo      *p_AutoResSnmpInfo;
+    t_FmPortDsarFilteringInfo *p_AutoResFilteringInfo;
+} t_FmPortDsarParams;
+
+/**************************************************************************//**
+ @Function      FM_PORT_EnterDsar
+
+ @Description   Enter Deep Sleep Auto Response mode.
+                This function write the apropriate values to in the relevant
+                tables in the MURAM. It then set the Tx port in independent
+                mode as needed and redirect the receive flow to go through the
+                Dsar Fman-ctrl code
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmPortRx - FM PORT module descriptor
+ @Param[in]     params - Auto Response parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ExitDsar
+
+ @Description   Exit Deep Sleep Auto Response mode.
+                This function reverse the AR mode and put the ports back into
+                their original wake mode
+
+ @Param[in]     h_FmPortRx - FM PORT Rx module descriptor
+ @Param[in]     h_FmPortTx - FM PORT Tx module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_EnterDsar().
+*//***************************************************************************/
+void FM_PORT_ExitDsar(t_Handle h_FmPortRx, t_Handle h_FmPortTx);
+
+/**************************************************************************//**
+ @Function      FM_PORT_IsInDsar
+
+ @Description   This function returns TRUE if the port was set as Auto Response
+                and FALSE if not. Once Exit AR mode it will return FALSE as well
+                until re-enabled once more.
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+bool FM_PORT_IsInDsar(t_Handle h_FmPort);
+
+typedef struct t_FmPortDsarStats
+{
+    uint32_t arpArCnt;
+    uint32_t echoIcmpv4ArCnt;
+    uint32_t ndpArCnt;
+    uint32_t echoIcmpv6ArCnt;
+    uint32_t snmpGetCnt;
+    uint32_t snmpGetNextCnt;
+} t_FmPortDsarStats;
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetDsarStats
+
+ @Description   Return statistics for Deep Sleep Auto Response
+
+ @Param[in]     h_FmPortRx - FM PORT module descriptor
+ @Param[out]    stats - structure containing the statistics counters
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PORT_GetDsarStats(t_Handle h_FmPortRx, t_FmPortDsarStats *stats);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_PORT_DumpRegs
+
+ @Description   Dump all regs.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_DumpRegs(t_Handle h_FmPort);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferDataOffset
+
+ @Description   Relevant for Rx ports.
+                Returns the data offset from the beginning of the data buffer
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+
+ @Return        data offset.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_GetBufferDataOffset(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferICInfo
+
+ @Description   Returns the Internal Context offset from the beginning of the data buffer
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+ @Param[in]     p_Data   - A pointer to the data buffer.
+
+ @Return        Internal context info pointer on success, NULL if 'allOtherInfo' was not
+                configured for this port.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferPrsResult
+
+ @Description   Returns the pointer to the parse result in the data buffer.
+                In Rx ports this is relevant after reception, if parse
+                result is configured to be part of the data passed to the
+                application. For non Rx ports it may be used to get the pointer
+                of the area in the buffer where parse result should be
+                initialized - if so configured.
+                See FM_PORT_ConfigBufferPrefixContent for data buffer prefix
+                configuration.
+
+ @Param[in]     h_FmPort    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        Parse result pointer on success, NULL if parse result was not
+                configured for this port.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferTimeStamp
+
+ @Description   Returns the time stamp in the data buffer.
+                Relevant for Rx ports for getting the buffer time stamp.
+                See FM_PORT_ConfigBufferPrefixContent for data buffer prefix
+                configuration.
+
+ @Param[in]     h_FmPort    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        A pointer to the hash result on success, NULL otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint64_t * FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferHashResult
+
+ @Description   Given a data buffer, on the condition that hash result was defined
+                as a part of the buffer content (see FM_PORT_ConfigBufferPrefixContent)
+                this routine will return the pointer to the hash result location in the
+                buffer prefix.
+
+ @Param[in]     h_FmPort    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        A pointer to the hash result on success, NULL otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint8_t * FM_PORT_GetBufferHashResult(t_Handle h_FmPort, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_PORT_Disable
+
+ @Description   Gracefully disable an FM port. The port will not start new tasks after all
+                tasks associated with the port are terminated.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                This is a blocking routine, it returns after port is
+                gracefully stopped, i.e. the port will not except new frames,
+                but it will finish all frames or tasks which were already began
+*//***************************************************************************/
+t_Error FM_PORT_Disable(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_Enable
+
+ @Description   A runtime routine provided to allow disable/enable of port.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_Enable(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetRateLimit
+
+ @Description   Calling this routine enables rate limit algorithm.
+                By default, this functionality is disabled.
+                Note that rate-limit mechanism uses the FM time stamp.
+                The selected rate limit specified here would be
+                rounded DOWN to the nearest 16M.
+
+                May be used for Tx and OP ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_RateLimit     A structure of rate limit parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                If rate limit is set on a port that need to send PFC frames,
+                it might violate the stop transmit timing.
+*//***************************************************************************/
+t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit);
+
+/**************************************************************************//**
+ @Function      FM_PORT_DeleteRateLimit
+
+ @Description   Calling this routine disables and clears rate limit
+                initialization.
+
+                May be used for Tx and OP ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetPfcPrioritiesMappingToQmanWQ
+
+ @Description   Calling this routine maps each PFC received priority to the transmit WQ.
+                This WQ will be blocked upon receiving a PFC frame with this priority.
+
+                May be used for Tx ports only.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     prio            PFC priority (0-7).
+ @Param[in]     wq              Work Queue (0-7).
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetPfcPrioritiesMappingToQmanWQ(t_Handle h_FmPort, uint8_t prio, uint8_t wq);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetStatisticsCounters
+
+ @Description   Calling this routine enables/disables port's statistics counters.
+                By default, counters are enabled.
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     enable      TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetFrameQueueCounters
+
+ @Description   Calling this routine enables/disables port's enqueue/dequeue counters.
+                By default, counters are enabled.
+
+                May be used for all ports
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     enable      TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PORT_AnalyzePerformanceParams
+
+ @Description   User may call this routine to so the driver will analyze if the
+                basic performance parameters are correct and also the driver may
+                suggest of improvements; The basic parameters are FIFO sizes, number
+                of DMAs and number of TNUMs for the port.
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort);
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetAllocBufCounter
+
+ @Description   Calling this routine enables/disables BM pool allocate
+                buffer counters.
+                By default, counters are enabled.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     poolId      BM pool id.
+ @Param[in]     enable      TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetCounter
+
+ @Description   Reads one of the FM PORT counters.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fmPortCounter       The requested counter.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                Note that it is user's responsibility to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters fmPortCounter);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ModifyCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fmPortCounter       The requested counter.
+ @Param[in]     value               The requested value to be written into the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters fmPortCounter, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetAllocBufCounter
+
+ @Description   Reads one of the FM PORT buffer counters.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     poolId              The requested pool.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                Note that it is user's responsibility to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ModifyAllocBufCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     poolId              The requested pool.
+ @Param[in]     value               The requested value to be written into the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort,  uint8_t poolId, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PORT_AddCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port.
+                It should be called in order to enable pause
+                frame transmission in case of congestion in one or more
+                of the congestion groups relevant to this port.
+                Each call to this routine may add one or more congestion
+                groups to be considered relevant to this port.
+
+                May be used for Rx, or RX+OP ports only (depending on chip)
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_CongestionGrps    A pointer to an array of congestion groups
+                                    id's to consider.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps);
+
+/**************************************************************************//**
+ @Function      FM_PORT_RemoveCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port. It should be
+                called when congestion groups were
+                defined for this port and are no longer relevant, or pause
+                frames transmitting is not required on their behalf.
+                Each call to this routine may remove one or more congestion
+                groups to be considered relevant to this port.
+
+                May be used for Rx, or RX+OP ports only (depending on chip)
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_CongestionGrps    A pointer to an array of congestion groups
+                                    id's to consider.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps);
+
+/**************************************************************************//**
+ @Function      FM_PORT_IsStalled
+
+ @Description   A routine for checking whether the specified port is stalled.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Return        TRUE if port is stalled, FALSE otherwize
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+bool FM_PORT_IsStalled(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ReleaseStalled
+
+ @Description   This routine may be called in case the port was stalled and may
+                now be released.
+                Note that this routine is available only on older FMan revisions
+                (FMan v2, DPAA v1.0 only).
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ReleaseStalled(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetRxL4ChecksumVerify
+
+ @Description   This routine is relevant for Rx ports (1G and 10G). The routine
+                set/clear the L3/L4 checksum verification (on RX side).
+                Note that this takes affect only if hw-parser is enabled!
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     l4Checksum      boolean indicates whether to do L3/L4 checksum
+                                on frames or not.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetErrorsRoute
+
+ @Description   Errors selected for this routine will cause a frame with that error
+                to be enqueued to error queue.
+                Errors not selected for this routine will cause a frame with that error
+                to be enqueued to the one of the other port queues.
+                By default all errors are defined to be enqueued to error queue.
+                Errors that were configured to be discarded (at initialization)
+                may not be selected here.
+
+                May be used for Rx and OP ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     errs        A list of errors to enqueue to error queue
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetIMExceptions
+
+ @Description   Calling this routine enables/disables FM PORT interrupts.
+
+ @Param[in]     h_FmPort        FM PORT module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_PORT_SetIMExceptions(t_Handle h_FmPort, e_FmPortExceptions exception, bool enable);
+
+/**************************************************************************//*
+ @Function      FM_PORT_SetPerformanceCounters
+
+ @Description   Calling this routine enables/disables port's performance counters.
+                By default, counters are enabled.
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     enable                  TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable);
+
+/**************************************************************************//*
+ @Function      FM_PORT_SetPerformanceCountersParams
+
+ @Description   Calling this routine defines port's performance
+                counters parameters.
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     p_FmPortPerformanceCnt  A pointer to a structure of performance
+                                        counters parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt);
+
+/**************************************************************************//**
+ @Group         FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
+
+ @Description   FM Port PCD Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   A structure defining the KG scheme after the parser.
+                This is relevant only to change scheme selection mode - from
+                direct to indirect and vice versa, or when the scheme is selected directly,
+                to select the scheme id.
+
+*//***************************************************************************/
+typedef struct t_FmPcdKgSchemeSelect {
+    bool        direct;                 /**< TRUE to use 'h_Scheme' directly, FALSE to use LCV. */
+    t_Handle    h_DirectScheme;         /**< Scheme handle, selects the scheme after parser;
+                                             Relevant only when 'direct' is TRUE. */
+} t_FmPcdKgSchemeSelect;
+
+/**************************************************************************//**
+ @Description   A structure of scheme parameters
+*//***************************************************************************/
+typedef struct t_FmPcdPortSchemesParams {
+    uint8_t     numOfSchemes;                           /**< Number of schemes for port to be bound to. */
+    t_Handle    h_Schemes[FM_PCD_KG_NUM_OF_SCHEMES];    /**< Array of 'numOfSchemes' schemes for the
+                                                             port to be bound to */
+} t_FmPcdPortSchemesParams;
+
+/**************************************************************************//**
+ @Description   Union for defining port protocol parameters for parser
+*//***************************************************************************/
+typedef union u_FmPcdHdrPrsOpts {
+    /* MPLS */
+    struct {
+        bool            labelInterpretationEnable;  /**< When this bit is set, the last MPLS label will be
+                                                         interpreted as described in HW spec table. When the bit
+                                                         is cleared, the parser will advance to MPLS next parse */
+        e_NetHeaderType nextParse;                  /**< must be equal or higher than IPv4 */
+    } mplsPrsOptions;
+    /* VLAN */
+    struct {
+        uint16_t        tagProtocolId1;             /**< User defined Tag Protocol Identifier, to be recognized
+                                                         on VLAN TAG on top of 0x8100 and 0x88A8 */
+        uint16_t        tagProtocolId2;             /**< User defined Tag Protocol Identifier, to be recognized
+                                                         on VLAN TAG on top of 0x8100 and 0x88A8 */
+    } vlanPrsOptions;
+    /* PPP */
+    struct{
+        bool            enableMTUCheck;             /**< Check validity of MTU according to RFC2516 */
+    } pppoePrsOptions;
+
+    /* IPV6 */
+    struct{
+        bool            routingHdrEnable;          /**< TRUE to enable routing header, otherwise ignore */
+    } ipv6PrsOptions;
+
+    /* UDP */
+    struct{
+        bool            padIgnoreChecksum;          /**< TRUE to ignore pad in checksum */
+    } udpPrsOptions;
+
+    /* TCP */
+    struct {
+        bool            padIgnoreChecksum;          /**< TRUE to ignore pad in checksum */
+    } tcpPrsOptions;
+} u_FmPcdHdrPrsOpts;
+
+/**************************************************************************//**
+ @Description   A structure for defining each header for the parser
+*//***************************************************************************/
+typedef struct t_FmPcdPrsAdditionalHdrParams {
+    e_NetHeaderType         hdr;            /**< Selected header */
+    bool                    errDisable;     /**< TRUE to disable error indication */
+    bool                    swPrsEnable;    /**< Enable jump to SW parser when this
+                                                 header is recognized by the HW parser. */
+    uint8_t                 indexPerHdr;    /**< Normally 0, if more than one sw parser
+                                                 attachments exists for the same header,
+                                                 (in the main sw parser code) use this
+                                                 index to distinguish between them. */
+    bool                    usePrsOpts;     /**< TRUE to use parser options. */
+    u_FmPcdHdrPrsOpts       prsOpts;        /**< A union according to header type,
+                                                 defining the parser options selected.*/
+} t_FmPcdPrsAdditionalHdrParams;
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdPrsParams {
+    uint8_t                         prsResultPrivateInfo;           /**< The private info provides a method of inserting
+                                                                         port information into the parser result. This information
+                                                                         may be extracted by Keygen and be used for frames
+                                                                         distribution when a per-port distinction is required,
+                                                                         it may also be used as a port logical id for analyzing
+                                                                         incoming frames. */
+    uint8_t                         parsingOffset;                  /**< Number of bytes from beginning of packet to start parsing */
+    e_NetHeaderType                 firstPrsHdr;                    /**< The type of the first header expected at 'parsingOffset' */
+    bool                            includeInPrsStatistics;         /**< TRUE to include this port in the parser statistics;
+                                                                         NOTE: this field is not valid when the FM is in "guest" mode
+                                                                               and IPC is not available. */
+    uint8_t                         numOfHdrsWithAdditionalParams;  /**< Normally 0, some headers may get
+                                                                         special parameters */
+    t_FmPcdPrsAdditionalHdrParams   additionalParams[FM_PCD_PRS_NUM_OF_HDRS];
+                                                                    /**< 'numOfHdrsWithAdditionalParams'  structures
+                                                                         of additional parameters
+                                                                         for each header that requires them */
+    bool                            setVlanTpid1;                   /**< TRUE to configure user selection of Ethertype to
+                                                                         indicate a VLAN tag (in addition to the TPID values
+                                                                         0x8100 and 0x88A8). */
+    uint16_t                        vlanTpid1;                      /**< extra tag to use if setVlanTpid1=TRUE. */
+    bool                            setVlanTpid2;                   /**< TRUE to configure user selection of Ethertype to
+                                                                         indicate a VLAN tag (in addition to the TPID values
+                                                                         0x8100 and 0x88A8). */
+    uint16_t                        vlanTpid2;                      /**< extra tag to use if setVlanTpid1=TRUE. */
+} t_FmPortPcdPrsParams;
+
+/**************************************************************************//**
+ @Description   struct for defining coarse alassification parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdCcParams {
+    t_Handle            h_CcTree;                       /**< A handle to a CC tree */
+} t_FmPortPcdCcParams;
+
+/**************************************************************************//**
+ @Description   struct for defining keygen parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdKgParams {
+    uint8_t             numOfSchemes;                   /**< Number of schemes for port to be bound to. */
+    t_Handle            h_Schemes[FM_PCD_KG_NUM_OF_SCHEMES];
+                                                        /**< Array of 'numOfSchemes' schemes handles for the
+                                                             port to be bound to */
+    bool                directScheme;                   /**< TRUE for going from parser to a specific scheme,
+                                                             regardless of parser result */
+    t_Handle            h_DirectScheme;                 /**< relevant only if direct == TRUE, Scheme handle,
+                                                             as returned by FM_PCD_KgSetScheme */
+} t_FmPortPcdKgParams;
+
+/**************************************************************************//**
+ @Description   struct for defining policer parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdPlcrParams {
+    t_Handle                h_Profile;          /**< Selected profile handle */
+} t_FmPortPcdPlcrParams;
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdParams {
+    e_FmPortPcdSupport      pcdSupport;         /**< Relevant for Rx and offline ports only.
+                                                     Describes the active PCD engines for this port. */
+    t_Handle                h_NetEnv;           /**< HL Unused in PLCR only mode */
+    t_FmPortPcdPrsParams    *p_PrsParams;       /**< Parser parameters for this port */
+    t_FmPortPcdCcParams     *p_CcParams;        /**< Coarse classification parameters for this port */
+    t_FmPortPcdKgParams     *p_KgParams;        /**< Keygen parameters for this port */
+    t_FmPortPcdPlcrParams   *p_PlcrParams;      /**< Policer parameters for this port; Relevant for one of
+                                                     following cases:
+                                                     e_FM_PORT_PCD_SUPPORT_PLCR_ONLY or
+                                                     e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR were selected,
+                                                     or if any flow uses a KG scheme were policer
+                                                     profile is not generated
+                                                     ('bypassPlcrProfileGeneration selected'). */
+    t_Handle                h_IpReassemblyManip;    /**< IP Reassembly manipulation */
+#if (DPAA_VERSION >= 11)
+    t_Handle                h_CapwapReassemblyManip;/**< CAPWAP Reassembly manipulation */
+#endif /* (DPAA_VERSION >= 11) */
+} t_FmPortPcdParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining the Parser starting point
+*//***************************************************************************/
+typedef struct t_FmPcdPrsStart {
+    uint8_t             parsingOffset;  /**< Number of bytes from beginning of packet to
+                                             start parsing */
+    e_NetHeaderType     firstPrsHdr;    /**< The type of the first header axpected at
+                                             'parsingOffset' */
+} t_FmPcdPrsStart;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   struct for defining external buffer margins
+*//***************************************************************************/
+typedef struct t_FmPortVSPAllocParams {
+    uint8_t     numOfProfiles;          /**< Number of Virtual Storage Profiles; must be a power of 2 */
+    uint8_t     dfltRelativeId;         /**< The default Virtual-Storage-Profile-id dedicated to Rx/OP port
+                                             The same default Virtual-Storage-Profile-id will be for coupled Tx port
+                                             if relevant function called for Rx port */
+    t_Handle    h_FmTxPort;             /**< Handle to coupled Tx Port; not relevant for OP port. */
+} t_FmPortVSPAllocParams;
+#endif /* (DPAA_VERSION >= 11) */
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetPCD
+
+ @Description   Calling this routine defines the port's PCD configuration.
+                It changes it from its default configuration which is PCD
+                disabled (BMI to BMI) and configures it according to the passed
+                parameters.
+
+                May be used for Rx and OP ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_FmPortPcd     A Structure of parameters defining the port's PCD
+                                configuration.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_FmPortPcd);
+
+/**************************************************************************//**
+ @Function      FM_PORT_DeletePCD
+
+ @Description   Calling this routine releases the port's PCD configuration.
+                The port returns to its default configuration which is PCD
+                disabled (BMI to BMI) and all PCD configuration is removed.
+
+                May be used for Rx and OP ports which are
+                in PCD mode  only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_DeletePCD(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_AttachPCD
+
+ @Description   This routine may be called after FM_PORT_DetachPCD was called,
+                to return to the originally configured PCD support flow.
+                The couple of routines are used to allow PCD configuration changes
+                that demand that PCD will not be used while changes take place.
+
+                May be used for Rx and OP ports which are
+                in PCD mode only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_AttachPCD(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_DetachPCD
+
+ @Description   Calling this routine detaches the port from its PCD functionality.
+                The port returns to its default flow which is BMI to BMI.
+
+                May be used for Rx and OP ports which are
+                in PCD mode only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_AttachPCD().
+*//***************************************************************************/
+t_Error FM_PORT_DetachPCD(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrAllocProfiles
+
+ @Description   This routine may be called only for ports that use the Policer in
+                order to allocate private policer profiles.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     numOfProfiles       The number of required policer profiles
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(),
+                and before FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrFreeProfiles
+
+ @Description   This routine should be called for freeing private policer profiles.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(),
+                and before FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort);
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Function      FM_PORT_VSPAlloc
+
+ @Description   This routine allocated VSPs per port and forces the port to work
+                in VSP mode. Note that the port is initialized by default with the
+                physical-storage-profile only.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     p_Params    A structure of parameters for allocation VSP's per port
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init(), and before FM_PORT_SetPCD()
+                and also before FM_PORT_Enable(); i.e. the port should be disabled.
+*//***************************************************************************/
+t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_Params);
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgModifyInitialScheme
+
+ @Description   This routine may be called only for ports that use the keygen in
+                order to change the initial scheme frame should be routed to.
+                The change may be of a scheme id (in case of direct mode),
+                from direct to indirect, or from indirect to direct - specifying the scheme id.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_FmPcdKgScheme     A structure of parameters for defining whether
+                                    a scheme is direct/indirect, and if direct - scheme id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSelect *p_FmPcdKgScheme);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrModifyInitialProfile
+
+ @Description   This routine may be called for ports with flows
+                e_FM_PORT_PCD_SUPPORT_PLCR_ONLY or e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR
+                only, to change the initial Policer profile frame should be
+                routed to. The change may be of a profile and/or absolute/direct
+                mode selection.
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     h_Profile               Policer profile handle
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_Profile);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdCcModifyTree
+
+ @Description   This routine may be called for ports that use coarse classification tree
+                if the user wishes to replace the tree. The routine may not be called while port
+                receives packets using the PCD functionalities, therefor port must be first detached
+                from the PCD, only than the routine may be called, and than port be attached to PCD again.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     h_CcTree            A CC tree that was already built. The tree id as returned from
+                                    the BuildTree routine.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init(), FM_PORT_SetPCD() and FM_PORT_DetachPCD()
+*//***************************************************************************/
+t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgBindSchemes
+
+ @Description   These routines may be called for adding more schemes for the
+                port to be bound to. The selected schemes are not added,
+                just this specific port starts using them.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_PortScheme    A structure defining the list of schemes to be added.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgUnbindSchemes
+
+ @Description   These routines may be called for adding more schemes for the
+                port to be bound to. The selected schemes are not removed or invalidated,
+                just this specific port stops using them.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_PortScheme    A structure defining the list of schemes to be added.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPrsModifyStartOffset
+
+ @Description   Runtime change of the parser start offset within the header.
+                The routine may not be called while port
+                receives packets using the PCD functionalities, therefore port must be first detached
+                from the PCD, only than the routine may be called, and than port be attached to PCD again.
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_FmPcdPrsStart A structure of parameters for defining the
+                                start point for the parser.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init(), FM_PORT_SetPCD() and FM_PORT_DetatchPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetIPv4OptionsCount
+
+ @Description   TODO
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[out]    p_Ipv4OptionsCount  will hold the counter value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init()
+*//***************************************************************************/
+t_Error FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort, uint32_t *p_Ipv4OptionsCount);
+
+/** @} */ /* end of FM_PORT_pcd_runtime_control_grp group */
+/** @} */ /* end of FM_PORT_runtime_control_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_PORT_runtime_data_grp FM Port Runtime Data-path Unit
+
+ @Description   FM Port Runtime data unit API functions, definitions and enums.
+                This API is valid only if working in Independent-Mode.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_PORT_ImTx
+
+ @Description   Tx function, called to transmit a data buffer on the port.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     p_Data      A pointer to an LCP data buffer.
+ @Param[in]     length      Size of data for transmission.
+ @Param[in]     lastBuffer  Buffer position - TRUE for the last buffer
+                            of a frame, including a single buffer frame
+ @Param[in]     h_BufContext  A handle of the user acossiated with this buffer
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                NOTE - This routine can be used only when working in
+                Independent-Mode mode.
+*//***************************************************************************/
+t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
+                       uint8_t                *p_Data,
+                       uint16_t               length,
+                       bool                   lastBuffer,
+                       t_Handle               h_BufContext);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ImTxConf
+
+ @Description   Tx port confirmation routine, optional, may be called to verify
+                transmission of all frames. The procedure performed by this
+                routine will be performed automatically on next buffer transmission,
+                but if desired, calling this routine will invoke this action on
+                demand.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                NOTE - This routine can be used only when working in
+                Independent-Mode mode.
+*//***************************************************************************/
+void FM_PORT_ImTxConf(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ImRx
+
+ @Description   Rx function, may be called to poll for received buffers.
+                Normally, Rx process is invoked by the driver on Rx interrupt.
+                Alternatively, this routine may be called on demand.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                NOTE - This routine can be used only when working in
+                Independent-Mode mode.
+*//***************************************************************************/
+t_Error  FM_PORT_ImRx(t_Handle h_FmPort);
+
+/** @} */ /* end of FM_PORT_runtime_data_grp group */
+/** @} */ /* end of FM_PORT_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+
+#ifdef NCSW_BACKWARD_COMPATIBLE_API
+#define FM_PORT_ConfigTxFifoDeqPipelineDepth FM_PORT_ConfigFifoDeqPipelineDepth
+#endif /* NCSW_BACKWARD_COMPATIBLE_API */
+
+
+#endif /* __FM_PORT_EXT */
--- fmlib-fslsdk-v1.7/include/fmd/Peripherals/dpaa_ext.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/Peripherals/dpaa_ext.h	2022-05-26 11:28:31.066973984 -0700
@@ -0,0 +1,204 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          dpaa_ext.h
+
+ @Description   DPAA Application Programming Interface.
+*//***************************************************************************/
+#ifndef __DPAA_EXT_H
+#define __DPAA_EXT_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+
+
+/**************************************************************************//**
+ @Group         DPAA_grp Data Path Acceleration Architecture API
+
+ @Description   DPAA API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+
+/**************************************************************************//**
+ @Description   Frame descriptor
+*//***************************************************************************/
+typedef _Packed struct t_DpaaFD {
+    volatile uint32_t    id;                /**< FD id */
+    volatile uint32_t    addrl;             /**< Data Address */
+    volatile uint32_t    length;            /**< Frame length */
+    volatile uint32_t    status;            /**< FD status */
+} _PackedType t_DpaaFD;
+
+/**************************************************************************//**
+ @Description   enum for defining frame format
+*//***************************************************************************/
+typedef enum e_DpaaFDFormatType {
+    e_DPAA_FD_FORMAT_TYPE_SHORT_SBSF  = 0x0,   /**< Simple frame Single buffer; Offset and
+                                                    small length (9b OFFSET, 20b LENGTH) */
+    e_DPAA_FD_FORMAT_TYPE_LONG_SBSF   = 0x2,   /**< Simple frame, single buffer; big length
+                                                    (29b LENGTH ,No OFFSET) */
+    e_DPAA_FD_FORMAT_TYPE_SHORT_MBSF  = 0x4,   /**< Simple frame, Scatter Gather table; Offset
+                                                    and small length (9b OFFSET, 20b LENGTH) */
+    e_DPAA_FD_FORMAT_TYPE_LONG_MBSF   = 0x6,   /**< Simple frame, Scatter Gather table;
+                                                    big length (29b LENGTH ,No OFFSET) */
+    e_DPAA_FD_FORMAT_TYPE_COMPOUND    = 0x1,   /**< Compound Frame (29b CONGESTION-WEIGHT
+                                                    No LENGTH or OFFSET) */
+    e_DPAA_FD_FORMAT_TYPE_DUMMY
+} e_DpaaFDFormatType;
+
+/**************************************************************************//**
+ @Collection   Frame descriptor macros
+*//***************************************************************************/
+#define DPAA_FD_DD_MASK       0xc0000000           /**< FD DD field mask */
+#define DPAA_FD_PID_MASK      0x3f000000           /**< FD PID field mask */
+#define DPAA_FD_ELIODN_MASK   0x0000f000           /**< FD ELIODN field mask */
+#define DPAA_FD_BPID_MASK     0x00ff0000           /**< FD BPID field mask */
+#define DPAA_FD_ADDRH_MASK    0x000000ff           /**< FD ADDRH field mask */
+#define DPAA_FD_ADDRL_MASK    0xffffffff           /**< FD ADDRL field mask */
+#define DPAA_FD_FORMAT_MASK   0xe0000000           /**< FD FORMAT field mask */
+#define DPAA_FD_OFFSET_MASK   0x1ff00000           /**< FD OFFSET field mask */
+#define DPAA_FD_LENGTH_MASK   0x000fffff           /**< FD LENGTH field mask */
+
+#define DPAA_FD_GET_DD(fd)            ((((t_DpaaFD *)fd)->id & DPAA_FD_DD_MASK) >> (31-1))              /**< Macro to get FD DD field */
+#define DPAA_FD_GET_PID(fd)           (((((t_DpaaFD *)fd)->id & DPAA_FD_PID_MASK) >> (31-7)) | \
+                                        ((((t_DpaaFD *)fd)->id & DPAA_FD_ELIODN_MASK) >> (31-19-6)))    /**< Macro to get FD PID field */
+#define DPAA_FD_GET_BPID(fd)          ((((t_DpaaFD *)fd)->id & DPAA_FD_BPID_MASK) >> (31-15))           /**< Macro to get FD BPID field */
+#define DPAA_FD_GET_ADDRH(fd)         (((t_DpaaFD *)fd)->id & DPAA_FD_ADDRH_MASK)                       /**< Macro to get FD ADDRH field */
+#define DPAA_FD_GET_ADDRL(fd)         ((t_DpaaFD *)fd)->addrl                                           /**< Macro to get FD ADDRL field */
+#define DPAA_FD_GET_PHYS_ADDR(fd)     ((physAddress_t)(((uint64_t)DPAA_FD_GET_ADDRH(fd) << 32) | (uint64_t)DPAA_FD_GET_ADDRL(fd))) /**< Macro to get FD ADDR field */
+#define DPAA_FD_GET_FORMAT(fd)        ((((t_DpaaFD *)fd)->length & DPAA_FD_FORMAT_MASK) >> (31-2))      /**< Macro to get FD FORMAT field */
+#define DPAA_FD_GET_OFFSET(fd)        ((((t_DpaaFD *)fd)->length & DPAA_FD_OFFSET_MASK) >> (31-11))     /**< Macro to get FD OFFSET field */
+#define DPAA_FD_GET_LENGTH(fd)        (((t_DpaaFD *)fd)->length & DPAA_FD_LENGTH_MASK)                  /**< Macro to get FD LENGTH field */
+#define DPAA_FD_GET_STATUS(fd)        ((t_DpaaFD *)fd)->status                                          /**< Macro to get FD STATUS field */
+#define DPAA_FD_GET_ADDR(fd)          XX_PhysToVirt(DPAA_FD_GET_PHYS_ADDR(fd))                          /**< Macro to get FD ADDR (virtual) */
+
+#define DPAA_FD_SET_DD(fd,val)        (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~DPAA_FD_DD_MASK) | (((val) << (31-1)) & DPAA_FD_DD_MASK )))      /**< Macro to set FD DD field */
+                                                                                                        /**< Macro to set FD PID field or LIODN offset*/
+#define DPAA_FD_SET_PID(fd,val)       (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~(DPAA_FD_PID_MASK|DPAA_FD_ELIODN_MASK)) | ((((val) << (31-7)) & DPAA_FD_PID_MASK) | ((((val)>>6) << (31-19)) & DPAA_FD_ELIODN_MASK))))
+#define DPAA_FD_SET_BPID(fd,val)      (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~DPAA_FD_BPID_MASK) | (((val)  << (31-15)) & DPAA_FD_BPID_MASK))) /**< Macro to set FD BPID field */
+#define DPAA_FD_SET_ADDRH(fd,val)     (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~DPAA_FD_ADDRH_MASK) | ((val) & DPAA_FD_ADDRH_MASK)))            /**< Macro to set FD ADDRH field */
+#define DPAA_FD_SET_ADDRL(fd,val)     ((t_DpaaFD *)fd)->addrl = (val)                                   /**< Macro to set FD ADDRL field */
+#define DPAA_FD_SET_ADDR(fd,val)                            \
+do {                                                        \
+    uint64_t physAddr = (uint64_t)(XX_VirtToPhys(val));     \
+    DPAA_FD_SET_ADDRH(fd, ((uint32_t)(physAddr >> 32)));    \
+    DPAA_FD_SET_ADDRL(fd, (uint32_t)physAddr);              \
+} while (0)                                                                                             /**< Macro to set FD ADDR field */
+#define DPAA_FD_SET_FORMAT(fd,val)    (((t_DpaaFD *)fd)->length = ((((t_DpaaFD *)fd)->length & ~DPAA_FD_FORMAT_MASK) | (((val)  << (31-2))& DPAA_FD_FORMAT_MASK)))  /**< Macro to set FD FORMAT field */
+#define DPAA_FD_SET_OFFSET(fd,val)    (((t_DpaaFD *)fd)->length = ((((t_DpaaFD *)fd)->length & ~DPAA_FD_OFFSET_MASK) | (((val) << (31-11))& DPAA_FD_OFFSET_MASK) )) /**< Macro to set FD OFFSET field */
+#define DPAA_FD_SET_LENGTH(fd,val)    (((t_DpaaFD *)fd)->length = (((t_DpaaFD *)fd)->length & ~DPAA_FD_LENGTH_MASK) | ((val) & DPAA_FD_LENGTH_MASK))                /**< Macro to set FD LENGTH field */
+#define DPAA_FD_SET_STATUS(fd,val)    ((t_DpaaFD *)fd)->status = (val)                                  /**< Macro to set FD STATUS field */
+/* @} */
+
+/**************************************************************************//**
+ @Description   Frame Scatter/Gather Table Entry
+*//***************************************************************************/
+typedef _Packed struct t_DpaaSGTE {
+    volatile uint32_t    addrh;        /**< Buffer Address high */
+    volatile uint32_t    addrl;        /**< Buffer Address low */
+    volatile uint32_t    length;       /**< Buffer length */
+    volatile uint32_t    offset;       /**< SGTE offset */
+} _PackedType t_DpaaSGTE;
+
+#define DPAA_NUM_OF_SG_TABLE_ENTRY 16
+
+/**************************************************************************//**
+ @Description   Frame Scatter/Gather Table
+*//***************************************************************************/
+typedef _Packed struct t_DpaaSGT {
+    t_DpaaSGTE    tableEntry[DPAA_NUM_OF_SG_TABLE_ENTRY];
+                                    /**< Structure that holds information about
+                                         a single S/G entry. */
+} _PackedType t_DpaaSGT;
+
+/**************************************************************************//**
+ @Description   Compound Frame Table
+*//***************************************************************************/
+typedef _Packed struct t_DpaaCompTbl {
+    t_DpaaSGTE    outputBuffInfo;   /**< Structure that holds information about
+                                         the compound-frame output buffer;
+                                         NOTE: this may point to a S/G table */
+    t_DpaaSGTE    inputBuffInfo;    /**< Structure that holds information about
+                                         the compound-frame input buffer;
+                                         NOTE: this may point to a S/G table */
+} _PackedType t_DpaaCompTbl;
+
+/**************************************************************************//**
+ @Collection   Frame Scatter/Gather Table Entry macros
+*//***************************************************************************/
+#define DPAA_SGTE_ADDRH_MASK    0x000000ff           /**< SGTE ADDRH field mask */
+#define DPAA_SGTE_ADDRL_MASK    0xffffffff           /**< SGTE ADDRL field mask */
+#define DPAA_SGTE_E_MASK        0x80000000           /**< SGTE Extension field mask */
+#define DPAA_SGTE_F_MASK        0x40000000           /**< SGTE Final field mask */
+#define DPAA_SGTE_LENGTH_MASK   0x3fffffff           /**< SGTE LENGTH field mask */
+#define DPAA_SGTE_BPID_MASK     0x00ff0000           /**< SGTE BPID field mask */
+#define DPAA_SGTE_OFFSET_MASK   0x00001fff           /**< SGTE OFFSET field mask */
+
+#define DPAA_SGTE_GET_ADDRH(sgte)         (((t_DpaaSGTE *)sgte)->addrh & DPAA_SGTE_ADDRH_MASK)              /**< Macro to get SGTE ADDRH field */
+#define DPAA_SGTE_GET_ADDRL(sgte)         ((t_DpaaSGTE *)sgte)->addrl                                       /**< Macro to get SGTE ADDRL field */
+#define DPAA_SGTE_GET_PHYS_ADDR(sgte)     ((physAddress_t)(((uint64_t)DPAA_SGTE_GET_ADDRH(sgte) << 32) | (uint64_t)DPAA_SGTE_GET_ADDRL(sgte))) /**< Macro to get FD ADDR field */
+#define DPAA_SGTE_GET_EXTENSION(sgte)     ((((t_DpaaSGTE *)sgte)->length & DPAA_SGTE_E_MASK) >> (31-0))     /**< Macro to get SGTE EXTENSION field */
+#define DPAA_SGTE_GET_FINAL(sgte)         ((((t_DpaaSGTE *)sgte)->length & DPAA_SGTE_F_MASK) >> (31-1))     /**< Macro to get SGTE FINAL field */
+#define DPAA_SGTE_GET_LENGTH(sgte)        (((t_DpaaSGTE *)sgte)->length & DPAA_SGTE_LENGTH_MASK)            /**< Macro to get SGTE LENGTH field */
+#define DPAA_SGTE_GET_BPID(sgte)          ((((t_DpaaSGTE *)sgte)->offset & DPAA_SGTE_BPID_MASK) >> (31-15)) /**< Macro to get SGTE BPID field */
+#define DPAA_SGTE_GET_OFFSET(sgte)        (((t_DpaaSGTE *)sgte)->offset & DPAA_SGTE_OFFSET_MASK)            /**< Macro to get SGTE OFFSET field */
+#define DPAA_SGTE_GET_ADDR(sgte)          XX_PhysToVirt(DPAA_SGTE_GET_PHYS_ADDR(sgte))
+
+#define DPAA_SGTE_SET_ADDRH(sgte,val)     (((t_DpaaSGTE *)sgte)->addrh = ((((t_DpaaSGTE *)sgte)->addrh & ~DPAA_SGTE_ADDRH_MASK) | ((val) & DPAA_SGTE_ADDRH_MASK))) /**< Macro to set SGTE ADDRH field */
+#define DPAA_SGTE_SET_ADDRL(sgte,val)     ((t_DpaaSGTE *)sgte)->addrl = (val)                                 /**< Macro to set SGTE ADDRL field */
+#define DPAA_SGTE_SET_ADDR(sgte,val)                            \
+do {                                                            \
+    uint64_t physAddr = (uint64_t)(XX_VirtToPhys(val));         \
+    DPAA_SGTE_SET_ADDRH(sgte, ((uint32_t)(physAddr >> 32)));    \
+    DPAA_SGTE_SET_ADDRL(sgte, (uint32_t)physAddr);              \
+} while (0)                                                                                                 /**< Macro to set SGTE ADDR field */
+#define DPAA_SGTE_SET_EXTENSION(sgte,val) (((t_DpaaSGTE *)sgte)->length = ((((t_DpaaSGTE *)sgte)->length & ~DPAA_SGTE_E_MASK) | (((val)  << (31-0))& DPAA_SGTE_E_MASK)))            /**< Macro to set SGTE EXTENSION field */
+#define DPAA_SGTE_SET_FINAL(sgte,val)     (((t_DpaaSGTE *)sgte)->length = ((((t_DpaaSGTE *)sgte)->length & ~DPAA_SGTE_F_MASK) | (((val)  << (31-1))& DPAA_SGTE_F_MASK)))            /**< Macro to set SGTE FINAL field */
+#define DPAA_SGTE_SET_LENGTH(sgte,val)    (((t_DpaaSGTE *)sgte)->length = (((t_DpaaSGTE *)sgte)->length & ~DPAA_SGTE_LENGTH_MASK) | ((val) & DPAA_SGTE_LENGTH_MASK))                /**< Macro to set SGTE LENGTH field */
+#define DPAA_SGTE_SET_BPID(sgte,val)      (((t_DpaaSGTE *)sgte)->offset = ((((t_DpaaSGTE *)sgte)->offset & ~DPAA_SGTE_BPID_MASK) | (((val)  << (31-15))& DPAA_SGTE_BPID_MASK)))     /**< Macro to set SGTE BPID field */
+#define DPAA_SGTE_SET_OFFSET(sgte,val)    (((t_DpaaSGTE *)sgte)->offset = ((((t_DpaaSGTE *)sgte)->offset & ~DPAA_SGTE_OFFSET_MASK) | (((val) << (31-31))& DPAA_SGTE_OFFSET_MASK) )) /**< Macro to set SGTE OFFSET field */
+/* @} */
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+/** @} */ /* end of DPAA_grp group */
+
+
+#endif /* __DPAA_EXT_H */
--- fmlib-fslsdk-v1.7/include/fmd/Peripherals/fm_pcd_ext.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/Peripherals/fm_pcd_ext.h	2022-05-26 11:28:31.082973330 -0700
@@ -0,0 +1,3934 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/**************************************************************************//**
+ @File          fm_pcd_ext.h
+
+ @Description   FM PCD API definitions
+*//***************************************************************************/
+#ifndef __FM_PCD_EXT
+#define __FM_PCD_EXT
+
+#include "std_ext.h"
+#include "net_ext.h"
+#include "fm_ext.h"
+#include "fsl_fman_kg.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   Frame Manager Application Programming Interface
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_PCD_grp FM PCD
+
+ @Description   Frame Manager PCD (Parse-Classify-Distribute) API.
+
+                The FM PCD module is responsible for the initialization of all
+                global classifying FM modules. This includes the parser general and
+                common registers, the key generator global and common registers,
+                and the policer global and common registers.
+                In addition, the FM PCD SW module will initialize all required
+                key generator schemes, coarse classification flows, and policer
+                profiles. When FM module is configured to work with one of these
+                entities, it will register to it using the FM PORT API. The PCD
+                module will manage the PCD resources - i.e. resource management of
+                KeyGen schemes, etc.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    General PCD defines
+*//***************************************************************************/
+#define FM_PCD_MAX_NUM_OF_PRIVATE_HDRS              2                   /**< Number of units/headers saved for user */
+
+#define FM_PCD_PRS_NUM_OF_HDRS                      16                  /**< Number of headers supported by HW parser */
+#define FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS         (32 - FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
+                                                                        /**< Number of distinction units is limited by
+                                                                             register size (32 bits) minus reserved bits
+                                                                             for private headers. */
+#define FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS      4                   /**< Maximum number of interchangeable headers
+                                                                             in a distinction unit */
+#define FM_PCD_KG_NUM_OF_GENERIC_REGS               FM_KG_NUM_OF_GENERIC_REGS /**< Total number of generic KeyGen registers */
+#define FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration;
+                                                                             For HW implementation reasons, in most
+                                                                             cases less than this will be allowed; The
+                                                                             driver will return an initialization error
+                                                                             if resource is unavailable. */
+#define FM_PCD_KG_NUM_OF_EXTRACT_MASKS              4                   /**< Total number of masks allowed on KeyGen extractions. */
+#define FM_PCD_KG_NUM_OF_DEFAULT_GROUPS             16                  /**< Number of default value logical groups */
+
+#define FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Maximum number of SW parser labels */
+#define FM_PCD_SW_PRS_SIZE                          0x00000800          /**< Total size of SW parser area */
+#define FM_PCD_PRS_SW_OFFSET                        0x00000040          /**< Size of illegal addresses at the beginning
+                                                                             of the SW parser area */
+
+#define FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE        128                 /**< Maximum size of insertion template for
+                                                                             insert manipulation */
+
+#if (DPAA_VERSION >= 11)
+#define FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES        64                  /**< Maximum possible entries for frame replicator group */
+#endif /* (DPAA_VERSION >= 11) */
+/* @} */
+
+
+/**************************************************************************//**
+ @Group         FM_PCD_init_grp FM PCD Initialization Unit
+
+ @Description   Frame Manager PCD Initialization Unit API
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   PCD counters
+*//***************************************************************************/
+typedef enum e_FmPcdCounters {
+    e_FM_PCD_KG_COUNTERS_TOTAL,                                 /**< KeyGen counter */
+    e_FM_PCD_PLCR_COUNTERS_RED,                                 /**< Policer counter - counts the total number of RED packets that exit the Policer. */
+    e_FM_PCD_PLCR_COUNTERS_YELLOW,                              /**< Policer counter - counts the total number of YELLOW packets that exit the Policer. */
+    e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,                    /**< Policer counter - counts the number of packets that changed color to RED by the Policer;
+                                                                     This is a subset of e_FM_PCD_PLCR_COUNTERS_RED packet count, indicating active color changes. */
+    e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,                 /**< Policer counter - counts the number of packets that changed color to YELLOW by the Policer;
+                                                                     This is a subset of e_FM_PCD_PLCR_COUNTERS_YELLOW packet count, indicating active color changes. */
+    e_FM_PCD_PLCR_COUNTERS_TOTAL,                               /**< Policer counter - counts the total number of packets passed in the Policer. */
+    e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,                     /**< Policer counter - counts the number of packets with length mismatch. */
+    e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,                       /**< Parser counter - counts the number of times the parser block is dispatched. */
+    e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L2 parse result is returned (including errors). */
+    e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L3 parse result is returned (including errors). */
+    e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L4 parse result is returned (including errors). */
+    e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,           /**< Parser counter - counts the number of times SHIM parse result is returned (including errors). */
+    e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L2 parse result is returned with errors. */
+    e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L3 parse result is returned with errors. */
+    e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L4 parse result is returned with errors. */
+    e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter - counts the number of times SHIM parse result is returned with errors. */
+    e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,                      /**< Parser counter - counts the number of cycles spent executing soft parser instruction (including stall cycles). */
+    e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,                /**< Parser counter - counts the number of cycles stalled waiting for parser internal memory reads while executing soft parser instruction. */
+    e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,     /**< Parser counter - counts the number of cycles spent executing hard parser (including stall cycles). */
+    e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,                    /**< MURAM counter - counts the number of cycles while performing FMan Memory read. */
+    e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,              /**< MURAM counter - counts the number of cycles stalled while performing FMan Memory read. */
+    e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,                   /**< MURAM counter - counts the number of cycles while performing FMan Memory write. */
+    e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,             /**< MURAM counter - counts the number of cycles stalled while performing FMan Memory write. */
+    e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES              /**< FPM counter - counts the number of cycles stalled while performing a FPM Command. */
+} e_FmPcdCounters;
+
+/**************************************************************************//**
+ @Description   PCD interrupts
+*//***************************************************************************/
+typedef enum e_FmPcdExceptions {
+    e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,                   /**< KeyGen double-bit ECC error is detected on internal memory read access. */
+    e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,             /**< KeyGen scheme configuration error indicating a key size larger than 56 bytes. */
+    e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,                 /**< Policer double-bit ECC error has been detected on PRAM read access. */
+    e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Policer access to a non-initialized profile has been detected. */
+    e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,    /**< Policer RAM self-initialization complete */
+    e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,     /**< Policer atomic action complete */
+    e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                  /**< Parser double-bit ECC error */
+    e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC                   /**< Parser single-bit ECC error */
+} e_FmPcdExceptions;
+
+
+/**************************************************************************//**
+ @Description   Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+
+ @Param[in]     h_App      - User's application descriptor.
+ @Param[in]     exception  - The exception.
+  *//***************************************************************************/
+typedef void (t_FmPcdExceptionCallback) (t_Handle h_App, e_FmPcdExceptions exception);
+
+/**************************************************************************//**
+ @Description   Exceptions user callback routine, will be called upon an exception
+                passing the exception identification.
+
+ @Param[in]     h_App           - User's application descriptor.
+ @Param[in]     exception       - The exception.
+ @Param[in]     index           - id of the relevant source (may be scheme or profile id).
+ *//***************************************************************************/
+typedef void (t_FmPcdIdExceptionCallback) ( t_Handle           h_App,
+                                            e_FmPcdExceptions  exception,
+                                            uint16_t           index);
+
+/**************************************************************************//**
+ @Description   A callback for enqueuing frame onto a QM queue.
+
+ @Param[in]     h_QmArg         - Application's handle passed to QM module on enqueue.
+ @Param[in]     p_Fd            - Frame descriptor for the frame.
+
+ @Return        E_OK on success; Error code otherwise.
+ *//***************************************************************************/
+typedef t_Error (t_FmPcdQmEnqueueCallback) (t_Handle h_QmArg, void *p_Fd);
+
+/**************************************************************************//**
+ @Description   Host-Command parameters structure.
+
+                When using Host command for PCD functionalities, a dedicated port
+                must be used. If this routine is called for a PCD in a single partition
+                environment, or it is the Master partition in a Multi-partition
+                environment, The port will be initialized by the PCD driver
+                initialization routine.
+ *//***************************************************************************/
+typedef struct t_FmPcdHcParams {
+    uintptr_t                   portBaseAddr;       /**< Virtual Address of Host-Command Port memory mapped registers.*/
+    uint8_t                     portId;             /**< Port Id (0-6 relative to Host-Command/Offline-Parsing ports);
+                                                         NOTE: When configuring Host Command port for
+                                                         FMANv3 devices (DPAA_VERSION 11 and higher),
+                                                         portId=0 MUST be used. */
+    uint16_t                    liodnBase;          /**< LIODN base for this port, to be used together with LIODN offset
+                                                         (irrelevant for P4080 revision 1.0) */
+    uint32_t                    errFqid;            /**< Host-Command Port error queue Id. */
+    uint32_t                    confFqid;           /**< Host-Command Port confirmation queue Id. */
+    uint32_t                    qmChannel;          /**< QM channel dedicated to this Host-Command port;
+                                                         will be used by the FM for dequeue. */
+    t_FmPcdQmEnqueueCallback    *f_QmEnqueue;       /**< Callback routine for enqueuing a frame to the QM */
+    t_Handle                    h_QmArg;            /**< Application's handle passed to QM module on enqueue */
+} t_FmPcdHcParams;
+
+/**************************************************************************//**
+ @Description   The main structure for PCD initialization
+ *//***************************************************************************/
+typedef struct t_FmPcdParams {
+    bool                        prsSupport;             /**< TRUE if Parser will be used for any of the FM ports. */
+    bool                        ccSupport;              /**< TRUE if Coarse Classification will be used for any
+                                                             of the FM ports. */
+    bool                        kgSupport;              /**< TRUE if KeyGen will be used for any of the FM ports. */
+    bool                        plcrSupport;            /**< TRUE if Policer will be used for any of the FM ports. */
+    t_Handle                    h_Fm;                   /**< A handle to the FM module. */
+    uint8_t                     numOfSchemes;           /**< Number of schemes dedicated to this partition.
+                                                             this parameter is relevant if 'kgSupport'=TRUE. */
+    bool                        useHostCommand;         /**< Optional for single partition, Mandatory for Multi partition */
+    t_FmPcdHcParams             hc;                     /**< Host Command parameters, relevant only if 'useHostCommand'=TRUE;
+                                                             Relevant when FM not runs in "guest-mode". */
+
+    t_FmPcdExceptionCallback    *f_Exception;           /**< Callback routine for general PCD exceptions;
+                                                             Relevant when FM not runs in "guest-mode". */
+    t_FmPcdIdExceptionCallback  *f_ExceptionId;         /**< Callback routine for specific KeyGen scheme or
+                                                             Policer profile exceptions;
+                                                             Relevant when FM not runs in "guest-mode". */
+    t_Handle                    h_App;                  /**< A handle to an application layer object; This handle will
+                                                             be passed by the driver upon calling the above callbacks;
+                                                             Relevant when FM not runs in "guest-mode". */
+    uint8_t                     partPlcrProfilesBase;   /**< The first policer-profile-id dedicated to this partition.
+                                                             this parameter is relevant if 'plcrSupport'=TRUE.
+                                                             NOTE: this parameter relevant only when working with multiple partitions. */
+    uint16_t                    partNumOfPlcrProfiles;  /**< Number of policer-profiles dedicated to this partition.
+                                                             this parameter is relevant if 'plcrSupport'=TRUE.
+                                                             NOTE: this parameter relevant only when working with multiple partitions. */
+} t_FmPcdParams;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_Config
+
+ @Description   Basic configuration of the PCD module.
+                Creates descriptor for the FM PCD module.
+
+ @Param[in]     p_FmPcdParams    A structure of parameters for the initialization of PCD.
+
+ @Return        A handle to the initialized module.
+*//***************************************************************************/
+t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_Init
+
+ @Description   Initialization of the PCD module.
+
+ @Param[in]     h_FmPcd - FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_Init(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_Free
+
+ @Description   Frees all resources that were assigned to FM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmPcd - FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_Free(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Group         FM_PCD_advanced_cfg_grp    FM PCD Advanced Configuration Unit
+
+ @Description   Frame Manager PCD Advanced Configuration API.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigException
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enabling.
+                [DEFAULT_numOfSharedPlcrProfiles].
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigHcFramesDataMemory
+
+ @Description   Configures memory-partition-id for FMan-Controller Host-Command
+                frames. Calling this routine changes the internal driver data
+                base from its default configuration [0].
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     memId           Memory partition ID.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      This routine may be called only if 'useHostCommand' was TRUE
+                when FM_PCD_Config() routine was called.
+*//***************************************************************************/
+t_Error FM_PCD_ConfigHcFramesDataMemory(t_Handle h_FmPcd, uint8_t memId);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigPlcrNumOfSharedProfiles
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement.
+                [DEFAULT_numOfSharedPlcrProfiles].
+
+ @Param[in]     h_FmPcd                     FM PCD module descriptor.
+ @Param[in]     numOfSharedPlcrProfiles     Number of profiles to
+                                            be shared between ports on this partition
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSharedPlcrProfiles);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigPlcrAutoRefreshMode
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement.
+                By default auto-refresh is [DEFAULT_plcrAutoRefresh].
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     enable          TRUE to enable, FALSE to disable
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigPrsMaxCycleLimit
+
+ @Description   Calling this routine changes the internal data structure for
+                the maximum parsing time from its default value
+                [DEFAULT_MAX_PRS_CYC_LIM].
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     value           0 to disable the mechanism, or new
+                                maximum parsing time.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value);
+
+/** @} */ /* end of FM_PCD_advanced_cfg_grp group */
+/** @} */ /* end of FM_PCD_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_PCD_Runtime_grp FM PCD Runtime Unit
+
+ @Description   Frame Manager PCD Runtime Unit API
+
+                The runtime control allows creation of PCD infrastructure modules
+                such as Network Environment Characteristics, Classification Plan
+                Groups and Coarse Classification Trees.
+                It also allows on-the-fly initialization, modification and removal
+                of PCD modules such as KeyGen schemes, coarse classification nodes
+                and Policer profiles.
+
+                In order to explain the programming model of the PCD driver interface
+                a few terms should be explained, and will be used below.
+                  - Distinction Header - One of the 16 protocols supported by the FM parser,
+                    or one of the SHIM headers (1 or 2). May be a header with a special
+                    option (see below).
+                  - Interchangeable Headers Group - This is a group of Headers recognized
+                    by either one of them. For example, if in a specific context the user
+                    chooses to treat IPv4 and IPV6 in the same way, they may create an
+                    interchangeable Headers Unit consisting of these 2 headers.
+                  - A Distinction Unit - a Distinction Header or an Interchangeable Headers
+                    Group.
+                  - Header with special option - applies to Ethernet, MPLS, VLAN, IPv4 and
+                    IPv6, includes multicast, broadcast and other protocol specific options.
+                    In terms of hardware it relates to the options available in the classification
+                    plan.
+                  - Network Environment Characteristics - a set of Distinction Units that define
+                    the total recognizable header selection for a certain environment. This is
+                    NOT the list of all headers that will ever appear in a flow, but rather
+                    everything that needs distinction in a flow, where distinction is made by KeyGen
+                    schemes and coarse classification action descriptors.
+
+                The PCD runtime modules initialization is done in stages. The first stage after
+                initializing the PCD module itself is to establish a Network Flows Environment
+                Definition. The application may choose to establish one or more such environments.
+                Later, when needed, the application will have to state, for some of its modules,
+                to which single environment it belongs.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   A structure for SW parser labels
+ *//***************************************************************************/
+typedef struct t_FmPcdPrsLabelParams {
+    uint32_t                instructionOffset;              /**< SW parser label instruction offset (2 bytes
+                                                                 resolution), relative to Parser RAM. */
+    e_NetHeaderType         hdr;                            /**< The existence of this header will invoke
+                                                                 the SW parser code. */
+    uint8_t                 indexPerHdr;                    /**< Normally 0, if more than one SW parser
+                                                                 attachments for the same header, use this
+                                                                 index to distinguish between them. */
+} t_FmPcdPrsLabelParams;
+
+/**************************************************************************//**
+ @Description   A structure for SW parser
+ *//***************************************************************************/
+typedef struct t_FmPcdPrsSwParams {
+    bool                    override;                   /**< FALSE to invoke a check that nothing else
+                                                             was loaded to this address, including
+                                                             internal patches.
+                                                             TRUE to override any existing code.*/
+    uint32_t                size;                       /**< SW parser code size */
+    uint16_t                base;                       /**< SW parser base (in instruction counts!
+                                                             must be larger than 0x20)*/
+    uint8_t                 *p_Code;                    /**< SW parser code */
+    uint32_t                swPrsDataParams[FM_PCD_PRS_NUM_OF_HDRS];
+                                                        /**< SW parser data (parameters) */
+    uint8_t                 numOfLabels;                /**< Number of labels for SW parser. */
+    t_FmPcdPrsLabelParams   labelsTable[FM_PCD_PRS_NUM_OF_LABELS];
+                                                        /**< SW parser labels table, containing
+                                                             numOfLabels entries */
+} t_FmPcdPrsSwParams;
+
+t_Handle FM_PCD_Open( t_FmPcdParams *p_FmPcdParams );
+void FM_PCD_Close(t_Handle h_FmPcd);
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_Enable
+
+ @Description   This routine should be called after PCD is initialized for enabling all
+                PCD engines according to their existing configuration.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+t_Error FM_PCD_Enable(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_Disable
+
+ @Description   This routine may be called when PCD is enabled in order to
+                disable all PCD engines. It may be called
+                only when none of the ports in the system are using the PCD.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init() and when PCD is enabled.
+*//***************************************************************************/
+t_Error FM_PCD_Disable(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_GetCounter
+
+ @Description   Reads one of the FM PCD counters.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     counter     The requested counter.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                Note that it is user's responsibility to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter);
+
+/**************************************************************************//**
+@Function       FM_PCD_PrsLoadSw
+
+@Description    This routine may be called in order to load software parsing code.
+
+
+@Param[in]      h_FmPcd        FM PCD module descriptor.
+@Param[in]      p_SwPrs        A pointer to a structure of software
+                               parser parameters, including the software
+                               parser image.
+
+@Return         E_OK on success; Error code otherwise.
+
+@Cautions       Allowed only following FM_PCD_Init() and when PCD is disabled.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs);
+
+/**************************************************************************//**
+@Function      FM_PCD_SetAdvancedOffloadSupport
+
+@Description   This routine must be called in order to support the following features:
+               IP-fragmentation, IP-reassembly, IPsec, Header-manipulation, frame-replicator.
+
+@Param[in]     h_FmPcd         FM PCD module descriptor.
+
+@Return        E_OK on success; Error code otherwise.
+
+@Cautions      Allowed only following FM_PCD_Init() and when PCD is disabled.
+               This routine should NOT be called from guest-partition
+               (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetDfltValue
+
+ @Description   Calling this routine sets a global default value to be used
+                by the KeyGen when parser does not recognize a required
+                field/header.
+                By default default values are 0.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     valueId         0,1 - one of 2 global default values.
+ @Param[in]     value           The requested default value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init() and when PCD is disabled.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetAdditionalDataAfterParsing
+
+ @Description   Calling this routine allows the KeyGen to access data past
+                the parser finishing point.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     payloadOffset   the number of bytes beyond the parser location.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init() and when PCD is disabled.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset);
+
+/**************************************************************************//**
+ @Function      FM_PCD_SetException
+
+ @Description   Calling this routine enables/disables PCD interrupts.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ModifyCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     counter     The requested counter.
+ @Param[in]     value       The requested value to be written into the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PCD_SetPlcrStatistics
+
+ @Description   This routine may be used to enable/disable policer statistics
+                counter. By default the statistics is enabled.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor
+ @Param[in]     enable          TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_SetPrsStatistics
+
+ @Description   Defines whether to gather parser statistics including all ports.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     enable      TRUE to enable, FALSE to disable.
+
+ @Return        None
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_HcTxConf
+
+ @Description   This routine should be called to confirm frames that were
+                 received on the HC confirmation queue.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     p_Fd            Frame descriptor of the received frame.
+
+ @Cautions      Allowed only following FM_PCD_Init(). Allowed only if 'useHostCommand'
+                option was selected in the initialization.
+*//***************************************************************************/
+void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_DpaaFD *p_Fd);
+
+/**************************************************************************//*
+ @Function      FM_PCD_ForceIntr
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     exception       An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_PCD_DumpRegs
+
+ @Description   Dumps all PCD registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                NOTE: this routine may be called only for FM in master mode
+                (i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
+                are mapped.
+*//***************************************************************************/
+t_Error FM_PCD_DumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgDumpRegs
+
+ @Description   Dumps all PCD KG registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                NOTE: this routine may be called only for FM in master mode
+                (i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
+                are mapped.
+*//***************************************************************************/
+t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrDumpRegs
+
+ @Description   Dumps all PCD Policer registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                NOTE: this routine may be called only for FM in master mode
+                (i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
+                are mapped.
+*//***************************************************************************/
+t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrProfileDumpRegs
+
+ @Description   Dumps all PCD Policer profile registers
+
+ @Param[in]     h_Profile       A handle to a Policer profile.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                NOTE: this routine may be called only for FM in master mode
+                (i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
+                are mapped.
+*//***************************************************************************/
+t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PrsDumpRegs
+
+ @Description   Dumps all PCD Parser registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                NOTE: this routine may be called only for FM in master mode
+                (i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
+                are mapped.
+*//***************************************************************************/
+t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_HcDumpRegs
+
+ @Description   Dumps HC Port registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                NOTE: this routine may be called only for FM in master mode
+                (i.e. 'guestId'=NCSW_MASTER_ID).
+*//***************************************************************************/
+t_Error     FM_PCD_HcDumpRegs(t_Handle h_FmPcd);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+
+
+/**************************************************************************//**
+ KeyGen         FM_PCD_Runtime_build_grp FM PCD Runtime Building Unit
+
+ @Description   Frame Manager PCD Runtime Building API
+
+                This group contains routines for setting, deleting and modifying
+                PCD resources, for defining the total PCD tree.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    Definitions of coarse classification
+                parameters as required by KeyGen (when coarse classification
+                is the next engine after this scheme).
+*//***************************************************************************/
+#define FM_PCD_MAX_NUM_OF_CC_TREES              8
+#define FM_PCD_MAX_NUM_OF_CC_GROUPS             16
+#define FM_PCD_MAX_NUM_OF_CC_UNITS              4
+#define FM_PCD_MAX_NUM_OF_KEYS                  256
+#define FM_PCD_MAX_NUM_OF_FLOWS                 (4*KILOBYTE)
+#define FM_PCD_MAX_SIZE_OF_KEY                  56
+#define FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP     16
+#define FM_PCD_LAST_KEY_INDEX                   0xffff
+
+#define FM_PCD_MAX_NUM_OF_CC_NODES              255 /* Obsolete, not used - will be removed in the future */
+/* @} */
+
+/**************************************************************************//**
+ @Collection    A set of definitions to allow protocol
+                special option description.
+*//***************************************************************************/
+typedef uint32_t        protocolOpt_t;          /**< A general type to define a protocol option. */
+
+typedef protocolOpt_t   ethProtocolOpt_t;       /**< Ethernet protocol options. */
+#define ETH_BROADCAST               0x80000000  /**< Ethernet Broadcast. */
+#define ETH_MULTICAST               0x40000000  /**< Ethernet Multicast. */
+
+typedef protocolOpt_t   vlanProtocolOpt_t;      /**< VLAN protocol options. */
+#define VLAN_STACKED                0x20000000  /**< Stacked VLAN. */
+
+typedef protocolOpt_t   mplsProtocolOpt_t;      /**< MPLS protocol options. */
+#define MPLS_STACKED                0x10000000  /**< Stacked MPLS. */
+
+typedef protocolOpt_t   ipv4ProtocolOpt_t;      /**< IPv4 protocol options. */
+#define IPV4_BROADCAST_1            0x08000000  /**< IPv4 Broadcast. */
+#define IPV4_MULTICAST_1            0x04000000  /**< IPv4 Multicast. */
+#define IPV4_UNICAST_2              0x02000000  /**< Tunneled IPv4 - Unicast. */
+#define IPV4_MULTICAST_BROADCAST_2  0x01000000  /**< Tunneled IPv4 - Broadcast/Multicast. */
+
+#define IPV4_FRAG_1                 0x00000008  /**< IPV4 reassembly option.
+                                                     IPV4 Reassembly manipulation requires network
+                                                     environment with IPV4 header and IPV4_FRAG_1 option  */
+
+typedef protocolOpt_t   ipv6ProtocolOpt_t;      /**< IPv6 protocol options. */
+#define IPV6_MULTICAST_1            0x00800000  /**< IPv6 Multicast. */
+#define IPV6_UNICAST_2              0x00400000  /**< Tunneled IPv6 - Unicast. */
+#define IPV6_MULTICAST_2            0x00200000  /**< Tunneled IPv6 - Multicast. */
+
+#define IPV6_FRAG_1                 0x00000004  /**< IPV6 reassembly option.
+                                                     IPV6 Reassembly manipulation requires network
+                                                     environment with IPV6 header and IPV6_FRAG_1 option;
+                                                     in case where fragment found, the fragment-extension offset
+                                                     may be found at 'shim2' (in parser-result). */
+#if (DPAA_VERSION >= 11)
+typedef protocolOpt_t   capwapProtocolOpt_t;      /**< CAPWAP protocol options. */
+#define CAPWAP_FRAG_1               0x00000008  /**< CAPWAP reassembly option.
+                                                     CAPWAP Reassembly manipulation requires network
+                                                     environment with CAPWAP header and CAPWAP_FRAG_1 option;
+                                                     in case where fragment found, the fragment-extension offset
+                                                     may be found at 'shim2' (in parser-result). */
+#endif /* (DPAA_VERSION >= 11) */
+
+
+/* @} */
+
+#define FM_PCD_MANIP_MAX_HDR_SIZE               256
+#define FM_PCD_MANIP_DSCP_TO_VLAN_TRANS         64
+
+/**************************************************************************//**
+ @Collection    A set of definitions to support Header Manipulation selection.
+*//***************************************************************************/
+typedef uint32_t                hdrManipFlags_t;            /**< A general type to define a HMan update command flags. */
+
+typedef hdrManipFlags_t         ipv4HdrManipUpdateFlags_t;  /**< IPv4 protocol HMan update command flags. */
+
+#define HDR_MANIP_IPV4_TOS      0x80000000                  /**< update TOS with the given value ('tos' field
+                                                                 of t_FmPcdManipHdrFieldUpdateIpv4) */
+#define HDR_MANIP_IPV4_ID       0x40000000                  /**< update IP ID with the given value ('id' field
+                                                                 of t_FmPcdManipHdrFieldUpdateIpv4) */
+#define HDR_MANIP_IPV4_TTL      0x20000000                  /**< Decrement TTL by 1 */
+#define HDR_MANIP_IPV4_SRC      0x10000000                  /**< update IP source address with the given value
+                                                                 ('src' field of t_FmPcdManipHdrFieldUpdateIpv4) */
+#define HDR_MANIP_IPV4_DST      0x08000000                  /**< update IP destination address with the given value
+                                                                 ('dst' field of t_FmPcdManipHdrFieldUpdateIpv4) */
+
+typedef hdrManipFlags_t         ipv6HdrManipUpdateFlags_t;  /**< IPv6 protocol HMan update command flags. */
+
+#define HDR_MANIP_IPV6_TC       0x80000000                  /**< update Traffic Class address with the given value
+                                                                 ('trafficClass' field of t_FmPcdManipHdrFieldUpdateIpv6) */
+#define HDR_MANIP_IPV6_HL       0x40000000                  /**< Decrement Hop Limit by 1 */
+#define HDR_MANIP_IPV6_SRC      0x20000000                  /**< update IP source address with the given value
+                                                                 ('src' field of t_FmPcdManipHdrFieldUpdateIpv6) */
+#define HDR_MANIP_IPV6_DST      0x10000000                  /**< update IP destination address with the given value
+                                                                 ('dst' field of t_FmPcdManipHdrFieldUpdateIpv6) */
+
+typedef hdrManipFlags_t         tcpUdpHdrManipUpdateFlags_t;/**< TCP/UDP protocol HMan update command flags. */
+
+#define HDR_MANIP_TCP_UDP_SRC       0x80000000              /**< update TCP/UDP source address with the given value
+                                                                 ('src' field of t_FmPcdManipHdrFieldUpdateTcpUdp) */
+#define HDR_MANIP_TCP_UDP_DST       0x40000000              /**< update TCP/UDP destination address with the given value
+                                                                 ('dst' field of t_FmPcdManipHdrFieldUpdateTcpUdp) */
+#define HDR_MANIP_TCP_UDP_CHECKSUM  0x20000000             /**< update TCP/UDP checksum */
+
+/* @} */
+
+/**************************************************************************//**
+ @Description   A type used for returning the order of the key extraction.
+                each value in this array represents the index of the extraction
+                command as defined by the user in the initialization extraction array.
+                The valid size of this array is the user define number of extractions
+                required (also marked by the second '0' in this array).
+*//***************************************************************************/
+typedef    uint8_t    t_FmPcdKgKeyOrder [FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+
+/**************************************************************************//**
+ @Description   All PCD engines
+*//***************************************************************************/
+typedef enum e_FmPcdEngine {
+    e_FM_PCD_INVALID = 0,   /**< Invalid PCD engine */
+    e_FM_PCD_DONE,          /**< No PCD Engine indicated */
+    e_FM_PCD_KG,            /**< KeyGen */
+    e_FM_PCD_CC,            /**< Coarse classifier */
+    e_FM_PCD_PLCR,          /**< Policer */
+    e_FM_PCD_PRS,           /**< Parser */
+#if (DPAA_VERSION >= 11)
+    e_FM_PCD_FR,            /**< Frame-Replicator */
+#endif /* (DPAA_VERSION >= 11) */
+    e_FM_PCD_HASH           /**< Hash table */
+} e_FmPcdEngine;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting extraction by header types
+*//***************************************************************************/
+typedef enum e_FmPcdExtractByHdrType {
+    e_FM_PCD_EXTRACT_FROM_HDR,      /**< Extract bytes from header */
+    e_FM_PCD_EXTRACT_FROM_FIELD,    /**< Extract bytes from header field */
+    e_FM_PCD_EXTRACT_FULL_FIELD     /**< Extract a full field */
+} e_FmPcdExtractByHdrType;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting extraction source
+                (when it is not the header)
+*//***************************************************************************/
+typedef enum e_FmPcdExtractFrom {
+    e_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< KG & CC: Extract from beginning of frame */
+    e_FM_PCD_EXTRACT_FROM_DFLT_VALUE,           /**< KG only: Extract from a default value */
+    e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE,    /**< KG & CC: Extract from the point where parsing had finished */
+    e_FM_PCD_EXTRACT_FROM_KEY,                  /**< CC only: Field where saved KEY */
+    e_FM_PCD_EXTRACT_FROM_HASH,                 /**< CC only: Field where saved HASH */
+    e_FM_PCD_EXTRACT_FROM_PARSE_RESULT,         /**< KG only: Extract from the parser result */
+    e_FM_PCD_EXTRACT_FROM_ENQ_FQID,             /**< KG & CC: Extract from enqueue FQID */
+    e_FM_PCD_EXTRACT_FROM_FLOW_ID               /**< CC only: Field where saved Dequeue FQID */
+} e_FmPcdExtractFrom;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting extraction type
+*//***************************************************************************/
+typedef enum e_FmPcdExtractType {
+    e_FM_PCD_EXTRACT_BY_HDR,                /**< Extract according to header */
+    e_FM_PCD_EXTRACT_NON_HDR,               /**< Extract from data that is not the header */
+    e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO   /**< Extract private info as specified by user */
+} e_FmPcdExtractType;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting default extraction value
+*//***************************************************************************/
+typedef enum e_FmPcdKgExtractDfltSelect {
+    e_FM_PCD_KG_DFLT_GBL_0,          /**< Default selection is KG register 0 */
+    e_FM_PCD_KG_DFLT_GBL_1,          /**< Default selection is KG register 1 */
+    e_FM_PCD_KG_DFLT_PRIVATE_0,      /**< Default selection is a per scheme register 0 */
+    e_FM_PCD_KG_DFLT_PRIVATE_1,      /**< Default selection is a per scheme register 1 */
+    e_FM_PCD_KG_DFLT_ILLEGAL         /**< Illegal selection */
+} e_FmPcdKgExtractDfltSelect;
+
+/**************************************************************************//**
+ @Description   Enumeration type defining all default groups - each group shares
+                a default value, one of four user-initialized values.
+*//***************************************************************************/
+typedef enum e_FmPcdKgKnownFieldsDfltTypes {
+    e_FM_PCD_KG_MAC_ADDR,               /**< MAC Address */
+    e_FM_PCD_KG_TCI,                    /**< TCI field */
+    e_FM_PCD_KG_ENET_TYPE,              /**< ENET Type */
+    e_FM_PCD_KG_PPP_SESSION_ID,         /**< PPP Session id */
+    e_FM_PCD_KG_PPP_PROTOCOL_ID,        /**< PPP Protocol id */
+    e_FM_PCD_KG_MPLS_LABEL,             /**< MPLS label */
+    e_FM_PCD_KG_IP_ADDR,                /**< IP address */
+    e_FM_PCD_KG_PROTOCOL_TYPE,          /**< Protocol type */
+    e_FM_PCD_KG_IP_TOS_TC,              /**< TOS or TC */
+    e_FM_PCD_KG_IPV6_FLOW_LABEL,        /**< IPV6 flow label */
+    e_FM_PCD_KG_IPSEC_SPI,              /**< IPSEC SPI */
+    e_FM_PCD_KG_L4_PORT,                /**< L4 Port */
+    e_FM_PCD_KG_TCP_FLAG,               /**< TCP Flag */
+    e_FM_PCD_KG_GENERIC_FROM_DATA,      /**< grouping implemented by SW,
+                                             any data extraction that is not the full
+                                             field described above  */
+    e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by SW,
+                                             any data extraction without validation */
+    e_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by SW,
+                                             extraction from parser result or
+                                             direct use of default value  */
+} e_FmPcdKgKnownFieldsDfltTypes;
+
+/**************************************************************************//**
+ @Description   Enumeration type for defining header index for scenarios with
+                multiple (tunneled) headers
+*//***************************************************************************/
+typedef enum e_FmPcdHdrIndex {
+    e_FM_PCD_HDR_INDEX_NONE = 0,        /**< used when multiple headers not used, also
+                                             to specify regular IP (not tunneled). */
+    e_FM_PCD_HDR_INDEX_1,               /**< may be used for VLAN, MPLS, tunneled IP */
+    e_FM_PCD_HDR_INDEX_2,               /**< may be used for MPLS, tunneled IP */
+    e_FM_PCD_HDR_INDEX_3,               /**< may be used for MPLS */
+    e_FM_PCD_HDR_INDEX_LAST = 0xFF      /**< may be used for VLAN, MPLS */
+} e_FmPcdHdrIndex;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer profile functional type
+*//***************************************************************************/
+typedef enum e_FmPcdProfileTypeSelection {
+    e_FM_PCD_PLCR_PORT_PRIVATE,         /**< Port dedicated profile */
+    e_FM_PCD_PLCR_SHARED                /**< Shared profile (shared within partition) */
+} e_FmPcdProfileTypeSelection;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer profile algorithm
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrAlgorithmSelection {
+    e_FM_PCD_PLCR_PASS_THROUGH,         /**< Policer pass through */
+    e_FM_PCD_PLCR_RFC_2698,             /**< Policer algorithm RFC 2698 */
+    e_FM_PCD_PLCR_RFC_4115              /**< Policer algorithm RFC 4115 */
+} e_FmPcdPlcrAlgorithmSelection;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting a policer profile color mode
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrColorMode {
+    e_FM_PCD_PLCR_COLOR_BLIND,          /**< Color blind */
+    e_FM_PCD_PLCR_COLOR_AWARE           /**< Color aware */
+} e_FmPcdPlcrColorMode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting a policer profile color
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrColor {
+    e_FM_PCD_PLCR_GREEN,                /**< Green color code */
+    e_FM_PCD_PLCR_YELLOW,               /**< Yellow color code */
+    e_FM_PCD_PLCR_RED,                  /**< Red color code */
+    e_FM_PCD_PLCR_OVERRIDE              /**< Color override code */
+} e_FmPcdPlcrColor;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer profile packet frame length selector
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrFrameLengthSelect {
+  e_FM_PCD_PLCR_L2_FRM_LEN,             /**< L2 frame length */
+  e_FM_PCD_PLCR_L3_FRM_LEN,             /**< L3 frame length */
+  e_FM_PCD_PLCR_L4_FRM_LEN,             /**< L4 frame length */
+  e_FM_PCD_PLCR_FULL_FRM_LEN            /**< Full frame length */
+} e_FmPcdPlcrFrameLengthSelect;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting roll-back frame
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrRollBackFrameSelect {
+  e_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN,    /**< Roll-back L2 frame length */
+  e_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN   /**< Roll-back Full frame length */
+} e_FmPcdPlcrRollBackFrameSelect;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer profile packet or byte mode
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrRateMode {
+    e_FM_PCD_PLCR_BYTE_MODE,            /**< Byte mode */
+    e_FM_PCD_PLCR_PACKET_MODE           /**< Packet mode */
+} e_FmPcdPlcrRateMode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for defining action of frame
+*//***************************************************************************/
+typedef enum e_FmPcdDoneAction {
+    e_FM_PCD_ENQ_FRAME = 0,        /**< Enqueue frame */
+    e_FM_PCD_DROP_FRAME            /**< Mark this frame as error frame and continue
+                                        to error flow; 'FM_PORT_FRM_ERR_CLS_DISCARD'
+                                        flag will be set for this frame. */
+} e_FmPcdDoneAction;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer counter
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrProfileCounters {
+    e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER,               /**< Green packets counter */
+    e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER,              /**< Yellow packets counter */
+    e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER,                 /**< Red packets counter */
+    e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER,   /**< Recolored yellow packets counter */
+    e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER       /**< Recolored red packets counter */
+} e_FmPcdPlcrProfileCounters;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the PCD action after extraction
+*//***************************************************************************/
+typedef enum e_FmPcdAction {
+    e_FM_PCD_ACTION_NONE,                           /**< NONE  */
+    e_FM_PCD_ACTION_EXACT_MATCH,                    /**< Exact match on the selected extraction */
+    e_FM_PCD_ACTION_INDEXED_LOOKUP                  /**< Indexed lookup on the selected extraction */
+} e_FmPcdAction;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of insert manipulation
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrInsrtType {
+    e_FM_PCD_MANIP_INSRT_GENERIC,                   /**< Insert according to offset & size */
+    e_FM_PCD_MANIP_INSRT_BY_HDR,                    /**< Insert according to protocol */
+#ifdef FM_CAPWAP_SUPPORT
+    e_FM_PCD_MANIP_INSRT_BY_TEMPLATE                /**< Insert template to start of frame */
+#endif /* FM_CAPWAP_SUPPORT */
+} e_FmPcdManipHdrInsrtType;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of remove manipulation
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrRmvType {
+    e_FM_PCD_MANIP_RMV_GENERIC,                     /**< Remove according to offset & size */
+    e_FM_PCD_MANIP_RMV_BY_HDR                       /**< Remove according to offset & size */
+} e_FmPcdManipHdrRmvType;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific L2 fields removal
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrRmvSpecificL2 {
+    e_FM_PCD_MANIP_HDR_RMV_ETHERNET,                /**< Ethernet/802.3 MAC */
+    e_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS,           /**< stacked QTags */
+    e_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS,       /**< MPLS and Ethernet/802.3 MAC header until
+                                                         the header which follows the MPLS header */
+    e_FM_PCD_MANIP_HDR_RMV_MPLS                     /**< Remove MPLS header (Unlimited MPLS labels) */
+} e_FmPcdManipHdrRmvSpecificL2;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific fields updates
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrFieldUpdateType {
+    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN,               /**< VLAN updates */
+    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4,               /**< IPV4 updates */
+    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6,               /**< IPV6 updates */
+    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP,            /**< TCP_UDP updates */
+} e_FmPcdManipHdrFieldUpdateType;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting VLAN updates
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrFieldUpdateVlan {
+    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI,      /**< Replace VPri of outer most VLAN tag. */
+    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN    /**< DSCP to VLAN priority bits translation */
+} e_FmPcdManipHdrFieldUpdateVlan;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific L2 fields removal
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrInsrtSpecificL2 {
+    e_FM_PCD_MANIP_HDR_INSRT_MPLS                   /**< Insert MPLS header (Unlimited MPLS labels) */
+} e_FmPcdManipHdrInsrtSpecificL2;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Enumeration type for selecting QoS mapping mode
+
+                Note: In all cases except 'e_FM_PCD_MANIP_HDR_QOS_MAPPING_NONE'
+                User should instruct the port to read the parser-result
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrQosMappingMode {
+    e_FM_PCD_MANIP_HDR_QOS_MAPPING_NONE = 0,   /**< No mapping, QoS field will not be changed */
+    e_FM_PCD_MANIP_HDR_QOS_MAPPING_AS_IS, /**< QoS field will be overwritten by the last byte in the parser-result. */
+} e_FmPcdManipHdrQosMappingMode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting QoS source
+
+                Note: In all cases except 'e_FM_PCD_MANIP_HDR_QOS_SRC_NONE'
+                User should left room for the parser-result on input/output buffer
+                and instruct the port to read/write the parser-result to the buffer (RPD should be set)
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrQosSrc {
+    e_FM_PCD_MANIP_HDR_QOS_SRC_NONE = 0,        /**< TODO */
+    e_FM_PCD_MANIP_HDR_QOS_SRC_USER_DEFINED,    /**< QoS will be taken from the last byte in the parser-result. */
+} e_FmPcdManipHdrQosSrc;
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of header insertion
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrInsrtByHdrType {
+    e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2,        /**< Specific L2 fields insertion */
+#if (DPAA_VERSION >= 11)
+    e_FM_PCD_MANIP_INSRT_BY_HDR_IP,                 /**< IP insertion */
+    e_FM_PCD_MANIP_INSRT_BY_HDR_UDP,                /**< UDP insertion */
+    e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE,             /**< UDP lite insertion */
+    e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP                 /**< CAPWAP insertion */
+#endif /* (DPAA_VERSION >= 11) */
+} e_FmPcdManipHdrInsrtByHdrType;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific customCommand
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrCustomType {
+    e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE,           /**< Replace IPv4/IPv6 */
+} e_FmPcdManipHdrCustomType;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific customCommand
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrCustomIpReplace {
+    e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV4_BY_IPV6,           /**< Replace IPv4 by IPv6 */
+    e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4            /**< Replace IPv6 by IPv4 */
+} e_FmPcdManipHdrCustomIpReplace;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of header removal
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrRmvByHdrType {
+    e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2 = 0,      /**< Specific L2 fields removal */
+#if (DPAA_VERSION >= 11)
+    e_FM_PCD_MANIP_RMV_BY_HDR_CAPWAP,                  /**< CAPWAP removal */
+#endif /* (DPAA_VERSION >= 11) */
+#if (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
+    e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START,           /**< Locate from data that is not the header */
+#endif /* (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
+} e_FmPcdManipHdrRmvByHdrType;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of timeout mode
+*//***************************************************************************/
+typedef enum e_FmPcdManipReassemTimeOutMode {
+    e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES, /**< Limits the time of the reassembly process
+                                                 from the first fragment to the last */
+    e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG    /**< Limits the time of receiving the fragment */
+} e_FmPcdManipReassemTimeOutMode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of WaysNumber mode
+*//***************************************************************************/
+typedef enum e_FmPcdManipReassemWaysNumber {
+    e_FM_PCD_MANIP_ONE_WAY_HASH = 1,    /**< One way hash    */
+    e_FM_PCD_MANIP_TWO_WAYS_HASH,       /**< Two ways hash   */
+    e_FM_PCD_MANIP_THREE_WAYS_HASH,     /**< Three ways hash */
+    e_FM_PCD_MANIP_FOUR_WAYS_HASH,      /**< Four ways hash  */
+    e_FM_PCD_MANIP_FIVE_WAYS_HASH,      /**< Five ways hash  */
+    e_FM_PCD_MANIP_SIX_WAYS_HASH,       /**< Six ways hash   */
+    e_FM_PCD_MANIP_SEVEN_WAYS_HASH,     /**< Seven ways hash */
+    e_FM_PCD_MANIP_EIGHT_WAYS_HASH      /**< Eight ways hash */
+} e_FmPcdManipReassemWaysNumber;
+
+#ifdef FM_CAPWAP_SUPPORT
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of statistics mode
+*//***************************************************************************/
+typedef enum e_FmPcdStatsType {
+    e_FM_PCD_STATS_PER_FLOWID = 0       /**< Flow ID is used as index for getting statistics */
+} e_FmPcdStatsType;
+#endif /* FM_CAPWAP_SUPPORT */
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting manipulation type
+*//***************************************************************************/
+typedef enum e_FmPcdManipType {
+    e_FM_PCD_MANIP_HDR = 0,             /**< Header manipulation */
+    e_FM_PCD_MANIP_REASSEM,             /**< Reassembly */
+    e_FM_PCD_MANIP_FRAG,                /**< Fragmentation */
+    e_FM_PCD_MANIP_SPECIAL_OFFLOAD      /**< Special Offloading */
+} e_FmPcdManipType;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of statistics mode
+*//***************************************************************************/
+typedef enum e_FmPcdCcStatsMode {
+    e_FM_PCD_CC_STATS_MODE_NONE = 0,        /**< No statistics support */
+    e_FM_PCD_CC_STATS_MODE_FRAME,           /**< Frame count statistics */
+    e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME,  /**< Byte and frame count statistics */
+#if (DPAA_VERSION >= 11)
+    e_FM_PCD_CC_STATS_MODE_RMON,            /**< Byte and frame length range count statistics;
+                                                 This mode is supported only on B4860 device */
+#endif /* (DPAA_VERSION >= 11) */
+} e_FmPcdCcStatsMode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for determining the action in case an IP packet
+                is larger than MTU but its DF (Don't Fragment) bit is set.
+*//***************************************************************************/
+typedef enum e_FmPcdManipDontFragAction {
+    e_FM_PCD_MANIP_DISCARD_PACKET = 0,                  /**< Discard packet */
+    e_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET = e_FM_PCD_MANIP_DISCARD_PACKET,
+                                                        /**< Obsolete, cannot enqueue to error queue;
+                                                             In practice, selects to discard packets;
+                                                             Will be removed in the future */
+    e_FM_PCD_MANIP_FRAGMENT_PACKET,                     /**< Fragment packet and continue normal processing */
+    e_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG                /**< Continue normal processing without fragmenting the packet */
+} e_FmPcdManipDontFragAction;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of special offload manipulation
+*//***************************************************************************/
+typedef enum e_FmPcdManipSpecialOffloadType {
+    e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC,    /**< IPSec offload manipulation */
+#if (DPAA_VERSION >= 11)
+    e_FM_PCD_MANIP_SPECIAL_OFFLOAD_CAPWAP    /**< CAPWAP offload manipulation */
+#endif /* (DPAA_VERSION >= 11) */
+} e_FmPcdManipSpecialOffloadType;
+
+
+/**************************************************************************//**
+ @Description   A Union of protocol dependent special options
+*//***************************************************************************/
+typedef union u_FmPcdHdrProtocolOpt {
+    ethProtocolOpt_t    ethOpt;     /**< Ethernet options */
+    vlanProtocolOpt_t   vlanOpt;    /**< VLAN options */
+    mplsProtocolOpt_t   mplsOpt;    /**< MPLS options */
+    ipv4ProtocolOpt_t   ipv4Opt;    /**< IPv4 options */
+    ipv6ProtocolOpt_t   ipv6Opt;    /**< IPv6 options */
+#if (DPAA_VERSION >= 11)
+    capwapProtocolOpt_t capwapOpt;  /**< CAPWAP options */
+#endif /* (DPAA_VERSION >= 11) */
+} u_FmPcdHdrProtocolOpt;
+
+/**************************************************************************//**
+ @Description   A union holding protocol fields
+
+
+                Fields supported as "full fields":
+                    HEADER_TYPE_ETH:
+                        NET_HEADER_FIELD_ETH_DA
+                        NET_HEADER_FIELD_ETH_SA
+                        NET_HEADER_FIELD_ETH_TYPE
+
+                    HEADER_TYPE_LLC_SNAP:
+                        NET_HEADER_FIELD_LLC_SNAP_TYPE
+
+                    HEADER_TYPE_VLAN:
+                        NET_HEADER_FIELD_VLAN_TCI
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+                                 e_FM_PCD_HDR_INDEX_LAST)
+
+                    HEADER_TYPE_MPLS:
+                        NET_HEADER_FIELD_MPLS_LABEL_STACK
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+                                 e_FM_PCD_HDR_INDEX_2,
+                                 e_FM_PCD_HDR_INDEX_LAST)
+
+                    HEADER_TYPE_IPv4:
+                        NET_HEADER_FIELD_IPv4_SRC_IP
+                        NET_HEADER_FIELD_IPv4_DST_IP
+                        NET_HEADER_FIELD_IPv4_PROTO
+                        NET_HEADER_FIELD_IPv4_TOS
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+                                 e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
+
+                    HEADER_TYPE_IPv6:
+                        NET_HEADER_FIELD_IPv6_SRC_IP
+                        NET_HEADER_FIELD_IPv6_DST_IP
+                        NET_HEADER_FIELD_IPv6_NEXT_HDR
+                        NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC (must come together!)
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+                                 e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
+
+                                (Note that starting from DPAA 1-1, NET_HEADER_FIELD_IPv6_NEXT_HDR applies to
+                                 the last next header indication, meaning the next L4, which may be
+                                 present at the Ipv6 last extension. On earlier revisions this field
+                                 applies to the Next-Header field of the main IPv6 header)
+
+                    HEADER_TYPE_IP:
+                        NET_HEADER_FIELD_IP_PROTO
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_LAST)
+                        NET_HEADER_FIELD_IP_DSCP
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1)
+                    HEADER_TYPE_GRE:
+                        NET_HEADER_FIELD_GRE_TYPE
+
+                    HEADER_TYPE_MINENCAP
+                        NET_HEADER_FIELD_MINENCAP_SRC_IP
+                        NET_HEADER_FIELD_MINENCAP_DST_IP
+                        NET_HEADER_FIELD_MINENCAP_TYPE
+
+                    HEADER_TYPE_TCP:
+                        NET_HEADER_FIELD_TCP_PORT_SRC
+                        NET_HEADER_FIELD_TCP_PORT_DST
+                        NET_HEADER_FIELD_TCP_FLAGS
+
+                    HEADER_TYPE_UDP:
+                        NET_HEADER_FIELD_UDP_PORT_SRC
+                        NET_HEADER_FIELD_UDP_PORT_DST
+
+                    HEADER_TYPE_UDP_LITE:
+                        NET_HEADER_FIELD_UDP_LITE_PORT_SRC
+                        NET_HEADER_FIELD_UDP_LITE_PORT_DST
+
+                    HEADER_TYPE_IPSEC_AH:
+                        NET_HEADER_FIELD_IPSEC_AH_SPI
+                        NET_HEADER_FIELD_IPSEC_AH_NH
+
+                    HEADER_TYPE_IPSEC_ESP:
+                        NET_HEADER_FIELD_IPSEC_ESP_SPI
+
+                    HEADER_TYPE_SCTP:
+                        NET_HEADER_FIELD_SCTP_PORT_SRC
+                        NET_HEADER_FIELD_SCTP_PORT_DST
+
+                    HEADER_TYPE_DCCP:
+                        NET_HEADER_FIELD_DCCP_PORT_SRC
+                        NET_HEADER_FIELD_DCCP_PORT_DST
+
+                    HEADER_TYPE_PPPoE:
+                        NET_HEADER_FIELD_PPPoE_PID
+                        NET_HEADER_FIELD_PPPoE_SID
+
+        *****************************************************************
+                Fields supported as "from fields":
+                    HEADER_TYPE_ETH (with or without validation):
+                        NET_HEADER_FIELD_ETH_TYPE
+
+                    HEADER_TYPE_VLAN (with or without validation):
+                        NET_HEADER_FIELD_VLAN_TCI
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+                                 e_FM_PCD_HDR_INDEX_LAST)
+
+                    HEADER_TYPE_IPv4 (without validation):
+                        NET_HEADER_FIELD_IPv4_PROTO
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+                                 e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
+
+                    HEADER_TYPE_IPv6 (without validation):
+                        NET_HEADER_FIELD_IPv6_NEXT_HDR
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+                                 e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
+
+*//***************************************************************************/
+typedef union t_FmPcdFields {
+    headerFieldEth_t            eth;            /**< Ethernet               */
+    headerFieldVlan_t           vlan;           /**< VLAN                   */
+    headerFieldLlcSnap_t        llcSnap;        /**< LLC SNAP               */
+    headerFieldPppoe_t          pppoe;          /**< PPPoE                  */
+    headerFieldMpls_t           mpls;           /**< MPLS                   */
+    headerFieldIp_t             ip;             /**< IP                     */
+    headerFieldIpv4_t           ipv4;           /**< IPv4                   */
+    headerFieldIpv6_t           ipv6;           /**< IPv6                   */
+    headerFieldUdp_t            udp;            /**< UDP                    */
+    headerFieldUdpLite_t        udpLite;        /**< UDP Lite               */
+    headerFieldTcp_t            tcp;            /**< TCP                    */
+    headerFieldSctp_t           sctp;           /**< SCTP                   */
+    headerFieldDccp_t           dccp;           /**< DCCP                   */
+    headerFieldGre_t            gre;            /**< GRE                    */
+    headerFieldMinencap_t       minencap;       /**< Minimal Encapsulation  */
+    headerFieldIpsecAh_t        ipsecAh;        /**< IPSec AH               */
+    headerFieldIpsecEsp_t       ipsecEsp;       /**< IPSec ESP              */
+    headerFieldUdpEncapEsp_t    udpEncapEsp;    /**< UDP Encapsulation ESP  */
+} t_FmPcdFields;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header extraction for key generation
+*//***************************************************************************/
+typedef struct t_FmPcdFromHdr {
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} t_FmPcdFromHdr;
+
+/**************************************************************************//**
+ @Description   Parameters for defining field extraction for key generation
+*//***************************************************************************/
+typedef struct t_FmPcdFromField {
+    t_FmPcdFields       field;          /**< Field selection */
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} t_FmPcdFromField;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a single network environment unit
+
+                A distinction unit should be defined if it will later be used
+                by one or more PCD engines to distinguish between flows.
+*//***************************************************************************/
+typedef struct t_FmPcdDistinctionUnit {
+    struct {
+        e_NetHeaderType         hdr;        /**< One of the headers supported by the FM */
+        u_FmPcdHdrProtocolOpt   opt;        /**< Select only one option ! */
+    } hdrs[FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS];
+} t_FmPcdDistinctionUnit;
+
+/**************************************************************************//**
+ @Description   Parameters for defining all different distinction units supported
+                by a specific PCD Network Environment Characteristics module.
+
+                Each unit represent a protocol or a group of protocols that may
+                be used later by the different PCD engines to distinguish
+                between flows.
+*//***************************************************************************/
+typedef struct t_FmPcdNetEnvParams {
+    uint8_t                 numOfDistinctionUnits;                      /**< Number of different units to be identified */
+    t_FmPcdDistinctionUnit  units[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS]; /**< An array of numOfDistinctionUnits of the
+                                                                             different units to be identified */
+} t_FmPcdNetEnvParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a single extraction action when
+                creating a key
+*//***************************************************************************/
+typedef struct t_FmPcdExtractEntry {
+    e_FmPcdExtractType                  type;           /**< Extraction type select */
+    union {
+        struct {
+            e_NetHeaderType             hdr;            /**< Header selection */
+            bool                        ignoreProtocolValidation;
+                                                        /**< Ignore protocol validation */
+            e_FmPcdHdrIndex             hdrIndex;       /**< Relevant only for MPLS, VLAN and tunneled
+                                                             IP. Otherwise should be cleared. */
+            e_FmPcdExtractByHdrType     type;           /**< Header extraction type select */
+            union {
+                t_FmPcdFromHdr          fromHdr;        /**< Extract bytes from header parameters */
+                t_FmPcdFromField        fromField;      /**< Extract bytes from field parameters */
+                t_FmPcdFields           fullField;      /**< Extract full filed parameters */
+            } extractByHdrType;
+        } extractByHdr;                                 /**< used when type = e_FM_PCD_KG_EXTRACT_BY_HDR */
+        struct {
+            e_FmPcdExtractFrom          src;            /**< Non-header extraction source */
+            e_FmPcdAction               action;         /**< Relevant for CC Only */
+            uint16_t                    icIndxMask;     /**< Relevant only for CC when
+                                                             action = e_FM_PCD_ACTION_INDEXED_LOOKUP;
+                                                             Note that the number of bits that are set within
+                                                             this mask must be log2 of the CC-node 'numOfKeys'.
+                                                             Note that the mask cannot be set on the lower bits. */
+            uint8_t                     offset;         /**< Byte offset */
+            uint8_t                     size;           /**< Size in byte */
+        } extractNonHdr;                                /**< used when type = e_FM_PCD_KG_EXTRACT_NON_HDR */
+    };
+} t_FmPcdExtractEntry;
+
+/**************************************************************************//**
+ @Description   Parameters for defining masks for each extracted field in the key.
+*//***************************************************************************/
+typedef struct t_FmPcdKgExtractMask {
+    uint8_t                             extractArrayIndex;  /**< Index in the extraction array, as initialized by user */
+    uint8_t                             offset;             /**< Byte offset */
+    uint8_t                             mask;               /**< A byte mask (selected bits will be used) */
+} t_FmPcdKgExtractMask;
+
+/**************************************************************************//**
+ @Description   Parameters for defining default selection per groups of fields
+*//***************************************************************************/
+typedef struct t_FmPcdKgExtractDflt {
+    e_FmPcdKgKnownFieldsDfltTypes       type;                /**< Default type select */
+    e_FmPcdKgExtractDfltSelect          dfltSelect;          /**< Default register select */
+} t_FmPcdKgExtractDflt;
+
+/**************************************************************************//**
+ @Description   Parameters for defining key extraction and hashing
+*//***************************************************************************/
+typedef struct t_FmPcdKgKeyExtractAndHashParams {
+    uint32_t                    privateDflt0;                /**< Scheme default register 0 */
+    uint32_t                    privateDflt1;                /**< Scheme default register 1 */
+    uint8_t                     numOfUsedExtracts;           /**< defines the valid size of the following array */
+    t_FmPcdExtractEntry         extractArray [FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY]; /**< An array of extractions definition. */
+    uint8_t                     numOfUsedDflts;              /**< defines the valid size of the following array */
+    t_FmPcdKgExtractDflt        dflts[FM_PCD_KG_NUM_OF_DEFAULT_GROUPS];
+                                                             /**< For each extraction used in this scheme, specify the required
+                                                                  default register to be used when header is not found.
+                                                                  types not specified in this array will get undefined value. */
+    uint8_t                     numOfUsedMasks;              /**< defines the valid size of the following array */
+    t_FmPcdKgExtractMask        masks[FM_PCD_KG_NUM_OF_EXTRACT_MASKS];
+    uint8_t                     hashShift;                   /**< hash result right shift. Select the 24 bits out of the 64 hash
+                                                                  result. 0 means using the 24 LSB's, otherwise use the
+                                                                  24 LSB's after shifting right.*/
+    uint32_t                    hashDistributionNumOfFqids;  /**< must be > 1 and a power of 2. Represents the range
+                                                                  of queues for the key and hash functionality */
+    uint8_t                     hashDistributionFqidsShift;  /**< selects the FQID bits that will be effected by the hash */
+    bool                        symmetricHash;               /**< TRUE to generate the same hash for frames with swapped source and
+                                                                  destination fields on all layers; If TRUE, driver will check that for
+                                                                  all layers, if SRC extraction is selected, DST extraction must also be
+                                                                  selected, and vice versa. */
+} t_FmPcdKgKeyExtractAndHashParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a single FQID mask (extracted OR).
+*//***************************************************************************/
+typedef struct t_FmPcdKgExtractedOrParams {
+    e_FmPcdExtractType              type;               /**< Extraction type select */
+    union {
+        struct {                                        /**< used when type = e_FM_PCD_KG_EXTRACT_BY_HDR */
+            e_NetHeaderType         hdr;
+            e_FmPcdHdrIndex         hdrIndex;           /**< Relevant only for MPLS, VLAN and tunneled
+                                                             IP. Otherwise should be cleared.*/
+            bool                    ignoreProtocolValidation;
+                                                        /**< continue extraction even if protocol is not recognized */
+        } extractByHdr;                                 /**< Header to extract by */
+        e_FmPcdExtractFrom          src;                /**< used when type = e_FM_PCD_KG_EXTRACT_NON_HDR */
+    };
+    uint8_t                         extractionOffset;   /**< Offset for extraction (in bytes).  */
+    e_FmPcdKgExtractDfltSelect      dfltValue;          /**< Select register from which extraction is taken if
+                                                             field not found */
+    uint8_t                         mask;               /**< Extraction mask (specified bits are used) */
+    uint8_t                         bitOffsetInFqid;    /**< 0-31, Selects which bits of the 24 FQID bits to effect using
+                                                             the extracted byte; Assume byte is placed as the 8 MSB's in
+                                                             a 32 bit word where the lower bits
+                                                             are the FQID; i.e if bitOffsetInFqid=1 than its LSB
+                                                             will effect the FQID MSB, if bitOffsetInFqid=24 than the
+                                                             extracted byte will effect the 8 LSB's of the FQID,
+                                                             if bitOffsetInFqid=31 than the byte's MSB will effect
+                                                             the FQID's LSB; 0 means - no effect on FQID;
+                                                             Note that one, and only one of
+                                                             bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
+                                                             extracted byte must effect either FQID or Policer profile).*/
+    uint8_t                         bitOffsetInPlcrProfile;
+                                                        /**< 0-15, Selects which bits of the 8 policer profile id bits to
+                                                             effect using the extracted byte; Assume byte is placed
+                                                             as the 8 MSB's in a 16 bit word where the lower bits
+                                                             are the policer profile id; i.e if bitOffsetInPlcrProfile=1
+                                                             than its LSB will effect the profile MSB, if bitOffsetInFqid=8
+                                                             than the extracted byte will effect the whole policer profile id,
+                                                             if bitOffsetInFqid=15 than the byte's MSB will effect
+                                                             the Policer Profile id's LSB;
+                                                             0 means - no effect on policer profile; Note that one, and only one of
+                                                             bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
+                                                             extracted byte must effect either FQID or Policer profile).*/
+} t_FmPcdKgExtractedOrParams;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring a scheme counter
+*//***************************************************************************/
+typedef struct t_FmPcdKgSchemeCounter {
+    bool        update;     /**< FALSE to keep the current counter state
+                                 and continue from that point, TRUE to update/reset
+                                 the counter when the scheme is written. */
+    uint32_t    value;      /**< If update=TRUE, this value will be written into the
+                                 counter. clear this field to reset the counter. */
+} t_FmPcdKgSchemeCounter;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring a policer profile for a KeyGen scheme
+                (when policer is the next engine after this scheme).
+*//***************************************************************************/
+typedef struct t_FmPcdKgPlcrProfile {
+    bool                sharedProfile;              /**< TRUE if this profile is shared between ports
+                                                         (managed by master partition); Must not be TRUE
+                                                         if profile is after Coarse Classification*/
+    bool                direct;                     /**< if TRUE, directRelativeProfileId only selects the profile
+                                                         id, if FALSE fqidOffsetRelativeProfileIdBase is used
+                                                         together with fqidOffsetShift and numOfProfiles
+                                                         parameters, to define a range of profiles from
+                                                         which the KeyGen result will determine the
+                                                         destination policer profile.  */
+    union {
+        uint16_t        directRelativeProfileId;    /**< Used if 'direct' is TRUE, to select policer profile.
+                                                         should indicate the policer profile offset within the
+                                                         port's policer profiles or shared window. */
+        struct {
+            uint8_t     fqidOffsetShift;            /**< Shift on the KeyGen create FQID offset (i.e. not the
+                                                         final FQID - without the FQID base). */
+            uint8_t     fqidOffsetRelativeProfileIdBase;
+                                                    /**< The base of the FMan Port's relative Storage-Profile ID;
+                                                         this value will be "OR'ed" with the KeyGen create FQID
+                                                         offset (i.e. not the final FQID - without the FQID base);
+                                                         the final result should indicate the Storage-Profile offset
+                                                         within the FMan Port's relative Storage-Profiles window/
+                                                         (or the SHARED window depends on 'sharedProfile'). */
+            uint8_t     numOfProfiles;              /**< Range of profiles starting at base */
+        } indirectProfile;                          /**< Indirect profile parameters */
+    } profileSelect;                                /**< Direct/indirect profile selection and parameters */
+} t_FmPcdKgPlcrProfile;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Parameters for configuring a storage profile for a KeyGen scheme.
+*//***************************************************************************/
+typedef struct t_FmPcdKgStorageProfile {
+    bool                direct;                     /**< If TRUE, directRelativeProfileId only selects the
+                                                         profile id;
+                                                         If FALSE, fqidOffsetRelativeProfileIdBase is used
+                                                         together with fqidOffsetShift and numOfProfiles
+                                                         parameters to define a range of profiles from which
+                                                         the KeyGen result will determine the destination
+                                                         storage profile. */
+    union {
+        uint16_t        directRelativeProfileId;    /**< Used when 'direct' is TRUE, to select a storage profile;
+                                                         should indicate the storage profile offset within the
+                                                         port's storage profiles window. */
+        struct {
+            uint8_t     fqidOffsetShift;            /**< Shift on the KeyGen create FQID offset (i.e. not the
+                                                         final FQID - without the FQID base). */
+            uint8_t     fqidOffsetRelativeProfileIdBase;
+                                                    /**< The base of the FMan Port's relative Storage-Profile ID;
+                                                         this value will be "OR'ed" with the KeyGen create FQID
+                                                         offset (i.e. not the final FQID - without the FQID base);
+                                                         the final result should indicate the Storage-Profile offset
+                                                         within the FMan Port's relative Storage-Profiles window. */
+            uint8_t     numOfProfiles;              /**< Range of profiles starting at base. */
+        } indirectProfile;                          /**< Indirect profile parameters. */
+    } profileSelect;                                /**< Direct/indirect profile selection and parameters. */
+} t_FmPcdKgStorageProfile;
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Description   Parameters for defining CC as the next engine after KeyGen
+*//***************************************************************************/
+typedef struct t_FmPcdKgCc {
+    t_Handle                h_CcTree;                       /**< A handle to a CC Tree */
+    uint8_t                 grpId;                          /**< CC group id within the CC tree */
+    bool                    plcrNext;                       /**< TRUE if after CC, in case of data frame,
+                                                                 policing is required. */
+    bool                    bypassPlcrProfileGeneration;    /**< TRUE to bypass KeyGen policer profile generation;
+                                                                 selected profile is the one set at port initialization. */
+    t_FmPcdKgPlcrProfile    plcrProfile;                    /**< Valid only if plcrNext = TRUE and
+                                                                 bypassPlcrProfileGeneration = FALSE */
+} t_FmPcdKgCc;
+
+/**************************************************************************//**
+ @Description   Parameters for defining initializing a KeyGen scheme
+*//***************************************************************************/
+typedef struct t_FmPcdKgSchemeParams {
+    bool                                modify;                 /**< TRUE to change an existing scheme */
+    union
+    {
+        uint8_t                         relativeSchemeId;       /**< if modify=FALSE:Partition relative scheme id */
+        t_Handle                        h_Scheme;               /**< if modify=TRUE: a handle of the existing scheme */
+    } id;
+    bool                                alwaysDirect;           /**< This scheme is reached only directly, i.e. no need
+                                                                     for match vector; KeyGen will ignore it when matching */
+    struct {                                                    /**< HL Relevant only if alwaysDirect = FALSE */
+        t_Handle                        h_NetEnv;               /**< A handle to the Network environment as returned
+                                                                     by FM_PCD_NetEnvCharacteristicsSet() */
+        uint8_t                         numOfDistinctionUnits;  /**< Number of NetEnv units listed in unitIds array */
+        uint8_t                         unitIds[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+                                                                /**< Indexes as passed to SetNetEnvCharacteristics array*/
+    } netEnvParams;
+    bool                                useHash;                /**< use the KeyGen Hash functionality  */
+    t_FmPcdKgKeyExtractAndHashParams    keyExtractAndHashParams;
+                                                                /**< used only if useHash = TRUE */
+    bool                                bypassFqidGeneration;   /**< Normally - FALSE, TRUE to avoid FQID update in the IC;
+                                                                     In such a case FQID after KeyGen will be the default FQID
+                                                                     defined for the relevant port, or the FQID defined by CC
+                                                                     in cases where CC was the previous engine. */
+    uint32_t                            baseFqid;               /**< Base FQID; Relevant only if bypassFqidGeneration = FALSE;
+                                                                     If hash is used and an even distribution is expected
+                                                                     according to hashDistributionNumOfFqids, baseFqid must be aligned to
+                                                                     hashDistributionNumOfFqids. */
+    uint8_t                             numOfUsedExtractedOrs;  /**< Number of FQID masks listed in extractedOrs array */
+    t_FmPcdKgExtractedOrParams          extractedOrs[FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                                                                /**< FM_PCD_KG_NUM_OF_GENERIC_REGS
+                                                                     registers are shared between qidMasks
+                                                                     functionality and some of the extraction
+                                                                     actions; Normally only some will be used
+                                                                     for qidMask. Driver will return error if
+                                                                     resource is full at initialization time. */
+
+#if (DPAA_VERSION >= 11)
+    bool                                overrideStorageProfile; /**< TRUE if KeyGen override previously decided storage profile */
+    t_FmPcdKgStorageProfile             storageProfile;         /**< Used when overrideStorageProfile TRUE */
+#endif /* (DPAA_VERSION >= 11) */
+
+    e_FmPcdEngine                       nextEngine;             /**< may be BMI, PLCR or CC */
+    union {                                                     /**< depends on nextEngine */
+        e_FmPcdDoneAction               doneAction;             /**< Used when next engine is BMI (done) */
+        t_FmPcdKgPlcrProfile            plcrProfile;            /**< Used when next engine is PLCR */
+        t_FmPcdKgCc                     cc;                     /**< Used when next engine is CC */
+    } kgNextEngineParams;
+    t_FmPcdKgSchemeCounter              schemeCounter;          /**< A structure of parameters for updating
+                                                                     the scheme counter */
+} t_FmPcdKgSchemeParams;
+
+/**************************************************************************//**
+ @Collection    Definitions for CC statistics
+*//***************************************************************************/
+#if (DPAA_VERSION >= 11)
+#define FM_PCD_CC_STATS_MAX_NUM_OF_FLR      10  /* Maximal supported number of frame length ranges */
+#define FM_PCD_CC_STATS_FLR_SIZE            2   /* Size in bytes of a frame length range limit */
+#endif /* (DPAA_VERSION >= 11) */
+#define FM_PCD_CC_STATS_COUNTER_SIZE        4   /* Size in bytes of a frame length range counter */
+/* @} */
+
+/**************************************************************************//**
+ @Description   Parameters for defining CC as the next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextCcParams {
+    t_Handle    h_CcNode;               /**< A handle of the next CC node */
+} t_FmPcdCcNextCcParams;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Parameters for defining Frame replicator as the next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextFrParams {
+    t_Handle    h_FrmReplic;               /**< A handle of the next frame replicator group */
+} t_FmPcdCcNextFrParams;
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Description   Parameters for defining Policer as the next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextPlcrParams {
+    bool        overrideParams;         /**< TRUE if CC override previously decided parameters*/
+    bool        sharedProfile;          /**< Relevant only if overrideParams=TRUE:
+                                             TRUE if this profile is shared between ports */
+    uint16_t    newRelativeProfileId;   /**< Relevant only if overrideParams=TRUE:
+                                             (otherwise profile id is taken from KeyGen);
+                                             This parameter should indicate the policer
+                                             profile offset within the port's
+                                             policer profiles or from SHARED window.*/
+    uint32_t    newFqid;                /**< Relevant only if overrideParams=TRUE:
+                                             FQID for enqueuing the frame;
+                                             In earlier chips  if policer next engine is KEYGEN,
+                                             this parameter can be 0, because the KEYGEN
+                                             always decides the enqueue FQID.*/
+#if (DPAA_VERSION >= 11)
+    uint8_t     newRelativeStorageProfileId;
+                                        /**< Indicates the relative storage profile offset within
+                                             the port's storage profiles window;
+                                             Relevant only if the port was configured with VSP. */
+#endif /* (DPAA_VERSION >= 11) */
+} t_FmPcdCcNextPlcrParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining enqueue as the next action after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextEnqueueParams {
+    e_FmPcdDoneAction    action;        /**< Action - when next engine is BMI (done) */
+    bool                 overrideFqid;  /**< TRUE if CC override previously decided fqid and vspid,
+                                             relevant if action = e_FM_PCD_ENQ_FRAME */
+    uint32_t             newFqid;       /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
+                                             (otherwise FQID is taken from KeyGen),
+                                             relevant if action = e_FM_PCD_ENQ_FRAME */
+#if (DPAA_VERSION >= 11)
+    uint8_t              newRelativeStorageProfileId;
+                                        /**< Valid if overrideFqid=TRUE, Indicates the relative virtual
+                                             storage profile offset within the port's storage profiles
+                                             window; Relevant only if the port was configured with VSP. */
+#endif /* (DPAA_VERSION >= 11) */
+} t_FmPcdCcNextEnqueueParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining KeyGen as the next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextKgParams {
+    bool        overrideFqid;           /**< TRUE if CC override previously decided fqid and vspid,
+                                             Note - this parameters irrelevant for earlier chips */
+    uint32_t    newFqid;                /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
+                                             (otherwise FQID is taken from KeyGen),
+                                             Note - this parameters irrelevant for earlier chips */
+#if (DPAA_VERSION >= 11)
+    uint8_t     newRelativeStorageProfileId;
+                                        /**< Valid if overrideFqid=TRUE, Indicates the relative virtual
+                                             storage profile offset within the port's storage profiles
+                                             window; Relevant only if the port was configured with VSP. */
+#endif /* (DPAA_VERSION >= 11) */
+
+    t_Handle    h_DirectScheme;         /**< Direct scheme handle to go to. */
+} t_FmPcdCcNextKgParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextEngineParams {
+    e_FmPcdEngine                       nextEngine;     /**< User has to initialize parameters
+                                                             according to nextEngine definition */
+    union {
+        t_FmPcdCcNextCcParams           ccParams;       /**< Parameters in case next engine is CC */
+        t_FmPcdCcNextPlcrParams         plcrParams;     /**< Parameters in case next engine is PLCR */
+        t_FmPcdCcNextEnqueueParams      enqueueParams;  /**< Parameters in case next engine is BMI */
+        t_FmPcdCcNextKgParams           kgParams;       /**< Parameters in case next engine is KG */
+#if (DPAA_VERSION >= 11)
+        t_FmPcdCcNextFrParams           frParams;       /**< Parameters in case next engine is FR */
+#endif /* (DPAA_VERSION >= 11) */
+    } params;                                           /**< union used for all the next-engine parameters options */
+
+    t_Handle                            h_Manip;        /**< Handle to Manipulation object.
+                                                             Relevant if next engine is of type result
+                                                             (e_FM_PCD_PLCR, e_FM_PCD_KG, e_FM_PCD_DONE) */
+
+    bool                                statisticsEn;   /**< If TRUE, statistics counters are incremented
+                                                             for each frame passing through this
+                                                             Coarse Classification entry. */
+} t_FmPcdCcNextEngineParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a single CC key
+*//***************************************************************************/
+typedef struct t_FmPcdCcKeyParams {
+    uint8_t                     *p_Key;     /**< Relevant only if 'action' = e_FM_PCD_ACTION_EXACT_MATCH;
+                                                 pointer to the key of the size defined in keySize */
+    uint8_t                     *p_Mask;    /**< Relevant only if 'action' = e_FM_PCD_ACTION_EXACT_MATCH;
+                                                 pointer to the Mask per key  of the size defined
+                                                 in keySize. p_Key and p_Mask (if defined) has to be
+                                                 of the same size defined in the keySize;
+                                                 NOTE that if this value is equal for all entries whithin
+                                                 this table, the driver will automatically use global-mask
+                                                 (i.e. one common mask for all entries) instead of private
+                                                 one; that is done in order to spare some memory and for
+                                                 better performance. */
+    t_FmPcdCcNextEngineParams   ccNextEngineParams;
+                                            /**< parameters for the next for the defined Key in
+                                                 the p_Key */
+} t_FmPcdCcKeyParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining CC keys parameters
+                The driver supports two methods for CC node allocation: dynamic and static.
+                Static mode was created in order to prevent runtime alloc/free
+                of FMan memory (MURAM), which may cause fragmentation; in this mode,
+                the driver automatically allocates the memory according to
+                'maxNumOfKeys' parameter. The driver calculates the maximal memory
+                size that may be used for this CC-Node taking into consideration
+                'maskSupport' and 'statisticsMode' parameters.
+                When 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP in the extraction
+                parameters of this node, 'maxNumOfKeys' must be equal to 'numOfKeys'.
+                In dynamic mode, 'maxNumOfKeys' must be zero. At initialization,
+                all required structures are allocated according to 'numOfKeys'
+                parameter. During runtime modification, these structures are
+                re-allocated according to the updated number of keys.
+
+                Please note that 'action' and 'icIndxMask' mentioned in the
+                specific parameter explanations are passed in the extraction
+                parameters of the node (fields of extractCcParams.extractNonHdr).
+*//***************************************************************************/
+typedef struct t_KeysParams {
+    uint16_t                    maxNumOfKeys;   /**< Maximum number of keys that will (ever) be used in this CC-Node;
+                                                     A value of zero may be used for dynamic memory allocation. */
+    bool                        maskSupport;    /**< This parameter is relevant only if a node is initialized with
+                                                     'action' = e_FM_PCD_ACTION_EXACT_MATCH and maxNumOfKeys > 0;
+                                                     Should be TRUE to reserve table memory for key masks, even if
+                                                     initial keys do not contain masks, or if the node was initialized
+                                                     as 'empty' (without keys); this will allow user to add keys with
+                                                     masks at runtime.
+                                                     NOTE that if user want to use only global-masks (i.e. one common mask
+                                                     for all the entries within this table, this parameter should set to 'FALSE'. */
+    e_FmPcdCcStatsMode          statisticsMode; /**< Determines the supported statistics mode for all node's keys.
+                                                     To enable statistics gathering, statistics should be enabled per
+                                                     every key, using 'statisticsEn' in next engine parameters structure
+                                                     of that key;
+                                                     If 'maxNumOfKeys' is set, all required structures will be
+                                                     preallocated for all keys. */
+#if (DPAA_VERSION >= 11)
+    uint16_t                    frameLengthRanges[FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
+                                                /**< Relevant only for 'RMON' statistics mode
+                                                     (this feature is supported only on B4860 device);
+                                                     Holds a list of programmable thresholds - for each received frame,
+                                                     its length in bytes is examined against these range thresholds and
+                                                     the appropriate counter is incremented by 1 - for example, to belong
+                                                     to range i, the following should hold:
+                                                     range i-1 threshold < frame length <= range i threshold
+                                                     Each range threshold must be larger then its preceding range
+                                                     threshold, and last range threshold must be 0xFFFF. */
+#endif /* (DPAA_VERSION >= 11) */
+    uint16_t                    numOfKeys;      /**< Number of initial keys;
+                                                     Note that in case of 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP,
+                                                     this field should be power-of-2 of the number of bits that are
+                                                     set in 'icIndxMask'. */
+    uint8_t                     keySize;        /**< Size of key - for extraction of type FULL_FIELD, 'keySize' has
+                                                     to be the standard size of the selected key; For other extraction
+                                                     types, 'keySize' has to be as size of extraction; When 'action' =
+                                                     e_FM_PCD_ACTION_INDEXED_LOOKUP, 'keySize' must be 2. */
+    t_FmPcdCcKeyParams          keyParams[FM_PCD_MAX_NUM_OF_KEYS];
+                                                /**< An array with 'numOfKeys' entries, each entry specifies the
+                                                     corresponding key parameters;
+                                                     When 'action' = e_FM_PCD_ACTION_EXACT_MATCH, this value must not
+                                                     exceed 255 (FM_PCD_MAX_NUM_OF_KEYS-1) as the last entry is saved
+                                                     for the 'miss' entry. */
+    t_FmPcdCcNextEngineParams   ccNextEngineParamsForMiss;
+                                                /**< Parameters for defining the next engine when a key is not matched;
+                                                     Not relevant if action = e_FM_PCD_ACTION_INDEXED_LOOKUP. */
+} t_KeysParams;
+
+
+/**************************************************************************//**
+ @Description   Parameters for defining a CC node
+*//***************************************************************************/
+typedef struct t_FmPcdCcNodeParams {
+    t_FmPcdExtractEntry         extractCcParams;    /**< Extraction parameters */
+    t_KeysParams                keysParams;         /**< Keys definition matching the selected extraction */
+} t_FmPcdCcNodeParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a hash table
+*//***************************************************************************/
+typedef struct t_FmPcdHashTableParams {
+    uint16_t                    maxNumOfKeys;               /**< Maximum Number Of Keys that will (ever) be used in this Hash-table */
+    e_FmPcdCcStatsMode          statisticsMode;             /**< If not e_FM_PCD_CC_STATS_MODE_NONE, the required structures for the
+                                                                 requested statistics mode will be allocated according to maxNumOfKeys. */
+    uint8_t                     kgHashShift;                /**< KG-Hash-shift as it was configured in the KG-scheme
+                                                                 that leads to this hash-table. */
+    uint16_t                    hashResMask;                /**< Mask that will be used on the hash-result;
+                                                                 The number-of-sets for this hash will be calculated
+                                                                 as (2^(number of bits set in 'hashResMask'));
+                                                                 The 4 lower bits must be cleared. */
+    uint8_t                     hashShift;                  /**< Byte offset from the beginning of the KeyGen hash result to the
+                                                                 2-bytes to be used as hash index. */
+    uint8_t                     matchKeySize;               /**< Size of the exact match keys held by the hash buckets */
+
+    t_FmPcdCcNextEngineParams   ccNextEngineParamsForMiss;  /**< Parameters for defining the next engine when a key is not matched */
+} t_FmPcdHashTableParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a CC tree group.
+
+                This structure defines a CC group in terms of NetEnv units
+                and the action to be taken in each case. The unitIds list must
+                be given in order from low to high indices.
+
+                t_FmPcdCcNextEngineParams is a list of 2^numOfDistinctionUnits
+                structures where each defines the next action to be taken for
+                each units combination. for example:
+                numOfDistinctionUnits = 2
+                unitIds = {1,3}
+                p_NextEnginePerEntriesInGrp[0] = t_FmPcdCcNextEngineParams for the case that
+                                                        unit 1 - not found; unit 3 - not found;
+                p_NextEnginePerEntriesInGrp[1] = t_FmPcdCcNextEngineParams for the case that
+                                                        unit 1 - not found; unit 3 - found;
+                p_NextEnginePerEntriesInGrp[2] = t_FmPcdCcNextEngineParams for the case that
+                                                        unit 1 - found; unit 3 - not found;
+                p_NextEnginePerEntriesInGrp[3] = t_FmPcdCcNextEngineParams for the case that
+                                                        unit 1 - found; unit 3 - found;
+*//***************************************************************************/
+typedef struct t_FmPcdCcGrpParams {
+    uint8_t                     numOfDistinctionUnits;          /**< Up to 4 */
+    uint8_t                     unitIds[FM_PCD_MAX_NUM_OF_CC_UNITS];
+                                                                /**< Indices of the units as defined in
+                                                                     FM_PCD_NetEnvCharacteristicsSet() */
+    t_FmPcdCcNextEngineParams   nextEnginePerEntriesInGrp[FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP];
+                                                                /**< Maximum entries per group is 16 */
+} t_FmPcdCcGrpParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining CC tree groups
+*//***************************************************************************/
+typedef struct t_FmPcdCcTreeParams {
+    t_Handle                h_NetEnv;                   /**< A handle to the Network environment as returned
+                                                             by FM_PCD_NetEnvCharacteristicsSet() */
+    uint8_t                 numOfGrps;                  /**< Number of CC groups within the CC tree */
+    t_FmPcdCcGrpParams      ccGrpParams[FM_PCD_MAX_NUM_OF_CC_GROUPS];
+                                                        /**< Parameters for each group. */
+} t_FmPcdCcTreeParams;
+
+
+/**************************************************************************//**
+ @Description   CC key statistics structure
+*//***************************************************************************/
+typedef struct t_FmPcdCcKeyStatistics {
+    uint32_t    byteCount;      /**< This counter reflects byte count of frames that
+                                     were matched by this key. */
+    uint32_t    frameCount;     /**< This counter reflects count of frames that
+                                     were matched by this key. */
+#if (DPAA_VERSION >= 11)
+    uint32_t    frameLengthRangeCount[FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
+                                /**< These counters reflect how many frames matched
+                                     this key in 'RMON' statistics mode:
+                                     Each counter holds the number of frames of a
+                                     specific frames length range, according to the
+                                     ranges provided at initialization. */
+#endif /* (DPAA_VERSION >= 11) */
+} t_FmPcdCcKeyStatistics;
+
+/**************************************************************************//**
+ @Description   Parameters for defining policer byte rate
+*//***************************************************************************/
+typedef struct t_FmPcdPlcrByteRateModeParams {
+    e_FmPcdPlcrFrameLengthSelect    frameLengthSelection;   /**< Frame length selection */
+    e_FmPcdPlcrRollBackFrameSelect  rollBackFrameSelection; /**< relevant option only e_FM_PCD_PLCR_L2_FRM_LEN,
+                                                                 e_FM_PCD_PLCR_FULL_FRM_LEN */
+} t_FmPcdPlcrByteRateModeParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the policer profile (based on
+                RFC-2698 or RFC-4115 attributes).
+*//***************************************************************************/
+typedef struct t_FmPcdPlcrNonPassthroughAlgParams {
+    e_FmPcdPlcrRateMode              rateMode;                       /**< Byte mode or Packet mode */
+    t_FmPcdPlcrByteRateModeParams    byteModeParams;                 /**< Valid for Byte NULL for Packet */
+    uint32_t                         comittedInfoRate;               /**< KBits/Second or Packets/Second */
+    uint32_t                         comittedBurstSize;              /**< Bytes/Packets */
+    uint32_t                         peakOrAccessiveInfoRate;        /**< KBits/Second or Packets/Second */
+    uint32_t                         peakOrAccessiveBurstSize;       /**< Bytes/Packets */
+} t_FmPcdPlcrNonPassthroughAlgParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the next engine after policer
+*//***************************************************************************/
+typedef union u_FmPcdPlcrNextEngineParams {
+    e_FmPcdDoneAction               action;             /**< Action - when next engine is BMI (done) */
+    t_Handle                        h_Profile;          /**< Policer profile handle -  used when next engine
+                                                             is Policer, must be a SHARED profile */
+    t_Handle                        h_DirectScheme;     /**< Direct scheme select - when next engine is KeyGen */
+} u_FmPcdPlcrNextEngineParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the policer profile entry
+*//***************************************************************************/
+typedef struct t_FmPcdPlcrProfileParams {
+    bool                                modify;                     /**< TRUE to change an existing profile */
+    union {
+        struct {
+            e_FmPcdProfileTypeSelection profileType;                /**< Type of policer profile */
+            t_Handle                    h_FmPort;                   /**< Relevant for per-port profiles only */
+            uint16_t                    relativeProfileId;          /**< Profile id - relative to shared group or to port */
+        } newParams;                                                /**< use it when modify = FALSE */
+        t_Handle                        h_Profile;                  /**< A handle to a profile - use it when modify=TRUE */
+    } id;
+    e_FmPcdPlcrAlgorithmSelection       algSelection;               /**< Profile Algorithm PASS_THROUGH, RFC_2698, RFC_4115 */
+    e_FmPcdPlcrColorMode                colorMode;                  /**< COLOR_BLIND, COLOR_AWARE */
+
+    union {
+        e_FmPcdPlcrColor                dfltColor;                  /**< For Color-Blind Pass-Through mode; the policer will re-color
+                                                                         any incoming packet with the default value. */
+        e_FmPcdPlcrColor                override;                   /**< For Color-Aware modes; the profile response to a
+                                                                         pre-color value of 2'b11. */
+    } color;
+
+    t_FmPcdPlcrNonPassthroughAlgParams  nonPassthroughAlgParams;    /**< RFC2698 or RFC4115 parameters */
+
+    e_FmPcdEngine                       nextEngineOnGreen;          /**< Next engine for green-colored frames */
+    u_FmPcdPlcrNextEngineParams         paramsOnGreen;              /**< Next engine parameters for green-colored frames  */
+
+    e_FmPcdEngine                       nextEngineOnYellow;         /**< Next engine for yellow-colored frames */
+    u_FmPcdPlcrNextEngineParams         paramsOnYellow;             /**< Next engine parameters for yellow-colored frames  */
+
+    e_FmPcdEngine                       nextEngineOnRed;            /**< Next engine for red-colored frames */
+    u_FmPcdPlcrNextEngineParams         paramsOnRed;                /**< Next engine parameters for red-colored frames  */
+
+    bool                                trapProfileOnFlowA;         /**< Obsolete - do not use */
+    bool                                trapProfileOnFlowB;         /**< Obsolete - do not use */
+    bool                                trapProfileOnFlowC;         /**< Obsolete - do not use */
+} t_FmPcdPlcrProfileParams;
+
+/**************************************************************************//**
+ @Description   Parameters for selecting a location for requested manipulation
+*//***************************************************************************/
+typedef struct t_FmManipHdrInfo {
+    e_NetHeaderType                     hdr;            /**< Header selection */
+    e_FmPcdHdrIndex                     hdrIndex;       /**< Relevant only for MPLS, VLAN and tunneled IP. Otherwise should be cleared. */
+    bool                                byField;        /**< TRUE if the location of manipulation is according to some field in the specific header*/
+    t_FmPcdFields                       fullField;      /**< Relevant only when byField = TRUE: Extract field */
+} t_FmManipHdrInfo;
+
+#ifdef FM_CAPWAP_SUPPORT
+/**************************************************************************//**
+ @Description   Parameters for defining an insertion manipulation
+                of type e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrInsrtByTemplateParams {
+    uint8_t         size;                               /**< Size of insert template to the start of the frame. */
+    uint8_t         hdrTemplate[FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE];
+                                                        /**< Array of the insertion template. */
+
+    bool            modifyOuterIp;                      /**< TRUE if user want to modify some fields in outer IP. */
+    struct {
+        uint16_t    ipOuterOffset;                      /**< Offset of outer IP in the insert template, relevant if modifyOuterIp = TRUE.*/
+        uint16_t    dscpEcn;                            /**< value of dscpEcn in IP outer, relevant if modifyOuterIp = TRUE.
+                                                             in IPV4 dscpEcn only byte - it has to be adjusted to the right*/
+        bool        udpPresent;                         /**< TRUE if UDP is present in the insert template, relevant if modifyOuterIp = TRUE.*/
+        uint8_t     udpOffset;                          /**< Offset in the insert template of UDP, relevant if modifyOuterIp = TRUE and udpPresent=TRUE.*/
+        uint8_t     ipIdentGenId;                       /**< Used by FMan-CTRL to calculate IP-identification field,relevant if modifyOuterIp = TRUE.*/
+        bool        recalculateLength;                  /**< TRUE if recalculate length has to be performed due to the engines in the path which can change the frame later, relevant if modifyOuterIp = TRUE.*/
+        struct {
+            uint8_t blockSize;                          /**< The CAAM block-size; Used by FMan-CTRL to calculate the IP Total Length field.*/
+            uint8_t extraBytesAddedAlignedToBlockSize;  /**< Used by FMan-CTRL to calculate the IP Total Length field and UDP length*/
+            uint8_t extraBytesAddedNotAlignedToBlockSize;/**< Used by FMan-CTRL to calculate the IP Total Length field and UDP length.*/
+        } recalculateLengthParams;                      /**< Recalculate length parameters - relevant if modifyOuterIp = TRUE and recalculateLength = TRUE */
+    } modifyOuterIpParams;                              /**< Outer IP modification parameters - ignored if modifyOuterIp is FALSE */
+
+    bool            modifyOuterVlan;                    /**< TRUE if user wants to modify VPri field in the outer VLAN header*/
+    struct {
+        uint8_t     vpri;                               /**< Value of VPri, relevant if modifyOuterVlan = TRUE
+                                                             VPri only 3 bits, it has to be adjusted to the right*/
+    } modifyOuterVlanParams;
+} t_FmPcdManipHdrInsrtByTemplateParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining CAPWAP fragmentation
+*//***************************************************************************/
+typedef struct t_CapwapFragmentationParams {
+    uint16_t         sizeForFragmentation;              /**< if length of the frame is greater than this value, CAPWAP fragmentation will be executed.*/
+    bool             headerOptionsCompr;                /**< TRUE - first fragment include the CAPWAP header options field,
+                                                             and all other fragments exclude the CAPWAP options field,
+                                                             FALSE - all fragments include CAPWAP header options field. */
+} t_CapwapFragmentationParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining CAPWAP reassembly
+*//***************************************************************************/
+typedef struct t_CapwapReassemblyParams {
+    uint16_t                        maxNumFramesInProcess;  /**< Number of frames which can be reassembled concurrently; must be power of 2.
+                                                                 In case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 4 - 512,
+                                                                 In case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048 */
+    bool                            haltOnDuplicationFrag;  /**< If TRUE, reassembly process will be halted due to duplicated fragment,
+                                                                 and all processed fragments will be enqueued with error indication;
+                                                                 If FALSE, only duplicated fragments will be enqueued with error indication. */
+
+    e_FmPcdManipReassemTimeOutMode  timeOutMode;            /**< Expiration delay initialized by the reassembly process */
+    uint32_t                        fqidForTimeOutFrames;   /**< FQID in which time out frames will enqueue during Time Out Process  */
+    uint32_t                        timeoutRoutineRequestTime;
+                                                            /**< Represents the time interval in microseconds between consecutive
+                                                                 timeout routine requests It has to be power of 2. */
+    uint32_t                        timeoutThresholdForReassmProcess;
+                                                            /**< Time interval (microseconds) for marking frames in process as too old;
+                                                                 Frames in process are those for which at least one fragment was received
+                                                                 but not all fragments. */
+
+    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;/**< Number of frames per hash entry (needed for the reassembly process) */
+} t_CapwapReassemblyParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining fragmentation/reassembly manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipFragOrReasmParams {
+    bool                                frag;               /**< TRUE if using the structure for fragmentation,
+                                                                 otherwise this structure is used for reassembly */
+    uint8_t                             sgBpid;             /**< Scatter/Gather buffer pool id;
+                                                                 Same LIODN number is used for these buffers as for
+                                                                 the received frames buffers, so buffers of this pool
+                                                                 need to be allocated in the same memory area as the
+                                                                 received buffers. If the received buffers arrive
+                                                                 from different sources, the Scatter/Gather BP id
+                                                                 should be mutual to all these sources. */
+    e_NetHeaderType                     hdr;                /**< Header selection */
+    union {
+        t_CapwapFragmentationParams     capwapFragParams;   /**< Structure for CAPWAP fragmentation,
+                                                                 relevant if 'frag' = TRUE, 'hdr' = HEADER_TYPE_CAPWAP */
+        t_CapwapReassemblyParams        capwapReasmParams;  /**< Structure for CAPWAP reassembly,
+                                                                 relevant if 'frag' = FALSE, 'hdr' = HEADER_TYPE_CAPWAP */
+    } u;
+} t_FmPcdManipFragOrReasmParams;
+
+#endif /* FM_CAPWAP_SUPPORT */
+
+/**************************************************************************//**
+ @Description   Parameters for defining header removal by header type
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrRmvByHdrParams {
+    e_FmPcdManipHdrRmvByHdrType         type;           /**< Selection of header removal location */
+    union {
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
+        struct {
+            bool                        include;        /**< If FALSE, remove until the specified header (not including the header);
+                                                             If TRUE, remove also the specified header. */
+            t_FmManipHdrInfo            hdrInfo;
+        } fromStartByHdr;                               /**< Relevant when type = e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
+#endif /* FM_CAPWAP_SUPPORT */
+#if (DPAA_VERSION >= 11)
+        t_FmManipHdrInfo                hdrInfo;        /**< Relevant when type = e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
+#endif /* (DPAA_VERSION >= 11) */
+        e_FmPcdManipHdrRmvSpecificL2    specificL2;     /**< Relevant when type = e_FM_PCD_MANIP_BY_HDR_SPECIFIC_L2;
+                                                             Defines which L2 headers to remove. */
+    } u;
+} t_FmPcdManipHdrRmvByHdrParams;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring IP fragmentation manipulation
+
+ Restrictions:
+     - IP Fragmentation output fragments must not be forwarded to application directly.
+     - Maximum number of fragments per frame is 16.
+     - Fragmentation of IP fragments is not supported.
+     - IPv4 packets containing header Option fields are fragmented by copying all option
+       fields to each fragment, regardless of the copy bit value.
+     - Transmit confirmation is not supported.
+     - Fragmentation after SEC can't handle S/G frames.
+     - Fragmentation nodes must be set as the last PCD action (i.e. the
+       corresponding CC node key must have next engine set to e_FM_PCD_DONE).
+     - Only BMan buffers shall be used for frames to be fragmented.
+     - IPF does not support VSP. Therefore, on the same port where we have IPF
+       we cannot support VSP.
+     - NOTE: The following comment is relevant only for FMAN v3 devices: IPF
+       does not support VSP. Therefore, on the same port where we have IPF we
+       cannot support VSP.
+*//***************************************************************************/
+typedef struct t_FmPcdManipFragIpParams {
+    uint16_t                    sizeForFragmentation;   /**< If length of the frame is greater than this value,
+                                                             IP fragmentation will be executed.*/
+#if (DPAA_VERSION == 10)
+    uint8_t                     scratchBpid;            /**< Absolute buffer pool id according to BM configuration.*/
+#endif /* (DPAA_VERSION == 10) */
+    bool                        sgBpidEn;               /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
+                                                             If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
+                                                             received frame's buffer. */
+    uint8_t                     sgBpid;                 /**< Scatter/Gather buffer pool id;
+                                                             This parameters is relevant when 'sgBpidEn=TRUE';
+                                                             Same LIODN number is used for these buffers as for the received frames buffers, so buffers
+                                                             of this pool need to be allocated in the same memory area as the received buffers.
+                                                             If the received buffers arrive from different sources, the Scatter/Gather BP id should be
+                                                             mutual to all these sources. */
+    e_FmPcdManipDontFragAction  dontFragAction;         /**< Don't Fragment Action - If an IP packet is larger
+                                                             than MTU and its DF bit is set, then this field will
+                                                             determine the action to be taken.*/
+} t_FmPcdManipFragIpParams;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring IP reassembly manipulation.
+
+                This is a common structure for both IPv4 and IPv6 reassembly
+                manipulation. For reassembly of both IPv4 and IPv6, make sure to
+                set the 'hdr' field in t_FmPcdManipReassemParams to HEADER_TYPE_IPv6.
+
+ Restrictions:
+    - Application must define at least one scheme to catch the reassembled frames.
+    - Maximum number of fragments per frame is 16.
+    - Reassembly of IPv4 fragments containing Option fields is supported.
+
+*//***************************************************************************/
+typedef struct t_FmPcdManipReassemIpParams {
+    uint8_t                         relativeSchemeId[2];    /**< Partition relative scheme id:
+                                                                 relativeSchemeId[0] -  Relative scheme ID for IPV4 Reassembly manipulation;
+                                                                 relativeSchemeId[1] -  Relative scheme ID for IPV6 Reassembly manipulation;
+                                                                 NOTE: The following comment is relevant only for FMAN v2 devices:
+                                                                 Relative scheme ID for IPv4/IPv6 Reassembly manipulation must be smaller than
+                                                                 the user schemes id to ensure that the reassembly schemes will be first match;
+                                                                 Rest schemes, if defined, should have higher relative scheme ID. */
+#if (DPAA_VERSION >= 11)
+    uint32_t                        nonConsistentSpFqid;    /**< In case that other fragments of the frame corresponds to different storage
+                                                                 profile than the opening fragment (Non-Consistent-SP state)
+                                                                 then one of two possible scenarios occurs:
+                                                                 if 'nonConsistentSpFqid != 0', the reassembled frame will be enqueued to
+                                                                 this fqid, otherwise a 'Non Consistent SP' bit will be set in the FD[status].*/
+#else
+    uint8_t                         sgBpid;                 /**< Buffer pool id for the S/G frame created by the reassembly process */
+#endif /* (DPAA_VERSION >= 11) */
+    uint8_t                         dataMemId;              /**< Memory partition ID for the IPR's external tables structure */
+    uint16_t                        dataLiodnOffset;        /**< LIODN offset for access the IPR's external tables structure. */
+    uint16_t                        minFragSize[2];         /**< Minimum fragment size:
+                                                                 minFragSize[0] - for ipv4, minFragSize[1] - for ipv6 */
+    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry[2];
+                                                            /**< Number of frames per hash entry needed for reassembly process:
+                                                                 numOfFramesPerHashEntry[0] - for ipv4 (max value is e_FM_PCD_MANIP_EIGHT_WAYS_HASH);
+                                                                 numOfFramesPerHashEntry[1] - for ipv6 (max value is e_FM_PCD_MANIP_SIX_WAYS_HASH). */
+    uint16_t                        maxNumFramesInProcess;  /**< Number of frames which can be processed by Reassembly in the same time;
+                                                                 Must be power of 2;
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 4 - 512;
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048. */
+    e_FmPcdManipReassemTimeOutMode  timeOutMode;            /**< Expiration delay initialized by Reassembly process */
+    uint32_t                        fqidForTimeOutFrames;   /**< FQID in which time out frames will enqueue during Time Out Process;
+                                                                 Recommended value for this field is 0; in this way timed-out frames will be discarded */
+    uint32_t                        timeoutThresholdForReassmProcess;
+                                                            /**< Represents the time interval in microseconds which defines
+                                                                 if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
+} t_FmPcdManipReassemIpParams;
+
+/**************************************************************************//**
+ @Description   structure for defining IPSEC manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipSpecialOffloadIPSecParams {
+    bool        decryption;                     /**< TRUE if being used in decryption direction;
+                                                     FALSE if being used in encryption direction. */
+    bool        ecnCopy;                        /**< TRUE to copy the ECN bits from inner/outer to outer/inner
+                                                     (direction depends on the 'decryption' field). */
+    bool        dscpCopy;                       /**< TRUE to copy the DSCP bits from inner/outer to outer/inner
+                                                     (direction depends on the 'decryption' field). */
+    bool        variableIpHdrLen;               /**< TRUE for supporting variable IP header length in decryption. */
+    bool        variableIpVersion;              /**< TRUE for supporting both IP version on the same SA in encryption */
+    uint8_t     outerIPHdrLen;                  /**< if 'variableIpVersion == TRUE' than this field must be set to non-zero value;
+                                                     It is specifies the length of the outer IP header that was configured in the
+                                                     corresponding SA. */
+} t_FmPcdManipSpecialOffloadIPSecParams;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Parameters for configuring CAPWAP fragmentation manipulation
+
+ Restrictions:
+     - Maximum number of fragments per frame is 16.
+     - Transmit confirmation is not supported.
+     - Fragmentation nodes must be set as the last PCD action (i.e. the
+       corresponding CC node key must have next engine set to e_FM_PCD_DONE).
+     - Only BMan buffers shall be used for frames to be fragmented.
+     - NOTE: The following comment is relevant only for FMAN v3 devices: IPF
+       does not support VSP. Therefore, on the same port where we have IPF we
+       cannot support VSP.
+*//***************************************************************************/
+typedef struct t_FmPcdManipFragCapwapParams {
+    uint16_t                    sizeForFragmentation;   /**< If length of the frame is greater than this value,
+                                                             CAPWAP fragmentation will be executed.*/
+    bool                        sgBpidEn;               /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
+                                                             If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
+                                                             received frame's buffer. */
+    uint8_t                     sgBpid;                 /**< Scatter/Gather buffer pool id;
+                                                             This parameters is relevant when 'sgBpidEn=TRUE';
+                                                             Same LIODN number is used for these buffers as for the received frames buffers, so buffers
+                                                             of this pool need to be allocated in the same memory area as the received buffers.
+                                                             If the received buffers arrive from different sources, the Scatter/Gather BP id should be
+                                                             mutual to all these sources. */
+    bool                        compressModeEn;         /**< CAPWAP Header Options Compress Enable mode;
+                                                             When this mode is enabled then only the first fragment include the CAPWAP header options
+                                                             field (if user provides it in the input frame) and all other fragments exclude the CAPWAP
+                                                             options field (CAPWAP header is updated accordingly).*/
+} t_FmPcdManipFragCapwapParams;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring CAPWAP reassembly manipulation.
+
+ Restrictions:
+    - Application must define one scheme to catch the reassembled frames.
+    - Maximum number of fragments per frame is 16.
+
+*//***************************************************************************/
+typedef struct t_FmPcdManipReassemCapwapParams {
+    uint8_t                         relativeSchemeId;    /**< Partition relative scheme id;
+                                                                 NOTE: this id must be smaller than the user schemes id to ensure that the reassembly scheme will be first match;
+                                                                 Rest schemes, if defined, should have higher relative scheme ID. */
+    uint8_t                         dataMemId;              /**< Memory partition ID for the IPR's external tables structure */
+    uint16_t                        dataLiodnOffset;        /**< LIODN offset for access the IPR's external tables structure. */
+    uint16_t                        maxReassembledFrameLength;/**< The maximum CAPWAP reassembled frame length in bytes;
+                                                                   If maxReassembledFrameLength == 0, any successful reassembled frame length is
+                                                                   considered as a valid length;
+                                                                   if maxReassembledFrameLength > 0, a successful reassembled frame which its length
+                                                                   exceeds this value is considered as an error frame (FD status[CRE] bit is set). */
+    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;
+                                                            /**< Number of frames per hash entry needed for reassembly process */
+    uint16_t                        maxNumFramesInProcess;  /**< Number of frames which can be processed by reassembly in the same time;
+                                                                 Must be power of 2;
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 4 - 512;
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048. */
+    e_FmPcdManipReassemTimeOutMode  timeOutMode;            /**< Expiration delay initialized by Reassembly process */
+    uint32_t                        fqidForTimeOutFrames;   /**< FQID in which time out frames will enqueue during Time Out Process;
+                                                                 Recommended value for this field is 0; in this way timed-out frames will be discarded */
+    uint32_t                        timeoutThresholdForReassmProcess;
+                                                            /**< Represents the time interval in microseconds which defines
+                                                                 if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
+} t_FmPcdManipReassemCapwapParams;
+
+/**************************************************************************//**
+ @Description   structure for defining CAPWAP manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipSpecialOffloadCapwapParams {
+    bool                    dtls;   /**< TRUE if continue to SEC DTLS encryption */
+    e_FmPcdManipHdrQosSrc   qosSrc; /**< TODO */
+} t_FmPcdManipSpecialOffloadCapwapParams;
+
+#endif /* (DPAA_VERSION >= 11) */
+
+
+/**************************************************************************//**
+ @Description   Parameters for defining special offload manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipSpecialOffloadParams {
+    e_FmPcdManipSpecialOffloadType              type;       /**< Type of special offload manipulation */
+    union
+    {
+        t_FmPcdManipSpecialOffloadIPSecParams   ipsec;      /**< Parameters for IPSec; Relevant when
+                                                                 type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC */
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipSpecialOffloadCapwapParams  capwap;     /**< Parameters for CAPWAP; Relevant when
+                                                                 type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
+    } u;
+} t_FmPcdManipSpecialOffloadParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining insertion manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrInsrt {
+    uint8_t size;           /**< size of inserted section */
+    uint8_t *p_Data;        /**< data to be inserted */
+} t_FmPcdManipHdrInsrt;
+
+
+/**************************************************************************//**
+ @Description   Parameters for defining generic removal manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrRmvGenericParams {
+    uint8_t                         offset;         /**< Offset from beginning of header to the start
+                                                         location of the removal */
+    uint8_t                         size;           /**< Size of removed section */
+} t_FmPcdManipHdrRmvGenericParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining generic insertion manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrInsrtGenericParams {
+    uint8_t                         offset;         /**< Offset from beginning of header to the start
+                                                         location of the insertion */
+    uint8_t                         size;           /**< Size of inserted section */
+    bool                            replace;        /**< TRUE to override (replace) existing data at
+                                                         'offset', FALSE to insert */
+    uint8_t                         *p_Data;        /**< Pointer to data to be inserted */
+} t_FmPcdManipHdrInsrtGenericParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation VLAN DSCP To Vpri translation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrFieldUpdateVlanDscpToVpri {
+    uint8_t                         dscpToVpriTable[FM_PCD_MANIP_DSCP_TO_VLAN_TRANS];
+                                                        /**< A table of VPri values for each DSCP value;
+                                                             The index is the DSCP value (0-0x3F) and the
+                                                             value is the corresponding VPRI (0-15). */
+    uint8_t                         vpriDefVal;         /**< 0-7, Relevant only if if updateType =
+                                                             e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN,
+                                                             this field is the Q Tag default value if the
+                                                             IP header is not found. */
+} t_FmPcdManipHdrFieldUpdateVlanDscpToVpri;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation VLAN fields updates
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrFieldUpdateVlan {
+    e_FmPcdManipHdrFieldUpdateVlan                  updateType; /**< Selects VLAN update type */
+    union {
+        uint8_t                                     vpri;       /**< 0-7, Relevant only if If updateType =
+                                                                     e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_PRI, this
+                                                                     is the new VLAN pri. */
+        t_FmPcdManipHdrFieldUpdateVlanDscpToVpri    dscpToVpri; /**< Parameters structure, Relevant only if updateType
+                                                                     = e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN. */
+    } u;
+} t_FmPcdManipHdrFieldUpdateVlan;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation IPV4 fields updates
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrFieldUpdateIpv4 {
+    ipv4HdrManipUpdateFlags_t       validUpdates;       /**< ORed flag, selecting the required updates */
+    uint8_t                         tos;                /**< 8 bit New TOS; Relevant if validUpdates contains
+                                                             HDR_MANIP_IPV4_TOS */
+    uint16_t                        id;                 /**< 16 bit New IP ID; Relevant only if validUpdates
+                                                             contains HDR_MANIP_IPV4_ID */
+    uint32_t                        src;                /**< 32 bit New IP SRC; Relevant only if validUpdates
+                                                             contains HDR_MANIP_IPV4_SRC */
+    uint32_t                        dst;                /**< 32 bit New IP DST; Relevant only if validUpdates
+                                                             contains HDR_MANIP_IPV4_DST */
+} t_FmPcdManipHdrFieldUpdateIpv4;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation IPV6 fields updates
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrFieldUpdateIpv6 {
+    ipv6HdrManipUpdateFlags_t   validUpdates;           /**< ORed flag, selecting the required updates */
+    uint8_t                     trafficClass;           /**< 8 bit New Traffic Class; Relevant if validUpdates contains
+                                                             HDR_MANIP_IPV6_TC */
+    uint8_t                     src[NET_HEADER_FIELD_IPv6_ADDR_SIZE];
+                                                        /**< 16 byte new IP SRC; Relevant only if validUpdates
+                                                             contains HDR_MANIP_IPV6_SRC */
+    uint8_t                     dst[NET_HEADER_FIELD_IPv6_ADDR_SIZE];
+                                                        /**< 16 byte new IP DST; Relevant only if validUpdates
+                                                             contains HDR_MANIP_IPV6_DST */
+} t_FmPcdManipHdrFieldUpdateIpv6;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation TCP/UDP fields updates
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrFieldUpdateTcpUdp {
+    tcpUdpHdrManipUpdateFlags_t     validUpdates;       /**< ORed flag, selecting the required updates */
+    uint16_t                        src;                /**< 16 bit New TCP/UDP SRC; Relevant only if validUpdates
+                                                             contains HDR_MANIP_TCP_UDP_SRC */
+    uint16_t                        dst;                /**< 16 bit New TCP/UDP DST; Relevant only if validUpdates
+                                                             contains HDR_MANIP_TCP_UDP_DST */
+} t_FmPcdManipHdrFieldUpdateTcpUdp;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation fields updates
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrFieldUpdateParams {
+    e_FmPcdManipHdrFieldUpdateType                  type;           /**< Type of header field update manipulation */
+    union {
+        t_FmPcdManipHdrFieldUpdateVlan              vlan;           /**< Parameters for VLAN update. Relevant when
+                                                                         type = e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN */
+        t_FmPcdManipHdrFieldUpdateIpv4              ipv4;           /**< Parameters for IPv4 update. Relevant when
+                                                                         type = e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4 */
+        t_FmPcdManipHdrFieldUpdateIpv6              ipv6;           /**< Parameters for IPv6 update. Relevant when
+                                                                         type = e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6 */
+        t_FmPcdManipHdrFieldUpdateTcpUdp            tcpUdp;         /**< Parameters for TCP/UDP update. Relevant when
+                                                                         type = e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP */
+    } u;
+} t_FmPcdManipHdrFieldUpdateParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining custom header manipulation for IP replacement
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrCustomIpHdrReplace {
+    e_FmPcdManipHdrCustomIpReplace  replaceType;        /**< Selects replace update type */
+    bool                            decTtlHl;           /**< Decrement TTL (IPV4) or Hop limit (IPV6) by 1  */
+    bool                            updateIpv4Id;       /**< Relevant when replaceType =
+                                                             e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4 */
+    uint16_t                        id;                 /**< 16 bit New IP ID; Relevant only if
+                                                             updateIpv4Id = TRUE */
+    uint8_t                         hdrSize;            /**< The size of the new IP header */
+    uint8_t                         hdr[FM_PCD_MANIP_MAX_HDR_SIZE];
+                                                        /**< The new IP header */
+} t_FmPcdManipHdrCustomIpHdrReplace;
+
+/**************************************************************************//**
+ @Description   Parameters for defining custom header manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrCustomParams {
+    e_FmPcdManipHdrCustomType               type;           /**< Type of header field update manipulation */
+    union {
+        t_FmPcdManipHdrCustomIpHdrReplace   ipHdrReplace;   /**< Parameters IP header replacement */
+    } u;
+} t_FmPcdManipHdrCustomParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining specific L2 insertion manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrInsrtSpecificL2Params {
+    e_FmPcdManipHdrInsrtSpecificL2  specificL2;     /**< Selects which L2 headers to insert */
+    bool                            update;         /**< TRUE to update MPLS header */
+    uint8_t                         size;           /**< size of inserted section */
+    uint8_t                         *p_Data;        /**< data to be inserted */
+} t_FmPcdManipHdrInsrtSpecificL2Params;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Parameters for defining IP insertion manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrInsrtIpParams {
+    bool    calcL4Checksum; /**< Calculate L4 checksum. */
+    e_FmPcdManipHdrQosMappingMode   mappingMode; /**< TODO */
+    uint8_t lastPidOffset;     /**< the offset of the last Protocol within
+                                 the inserted header */
+    uint16_t  id;           /**< 16 bit New IP ID */
+    t_FmPcdManipHdrInsrt insrt; /**< size and data to be inserted. */
+} t_FmPcdManipHdrInsrtIpParams;
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Description   Parameters for defining header insertion manipulation by header type
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrInsrtByHdrParams {
+    e_FmPcdManipHdrInsrtByHdrType               type;   /**< Selects manipulation type */
+    union {
+
+        t_FmPcdManipHdrInsrtSpecificL2Params    specificL2Params;
+                                                             /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2:
+                                                              Selects which L2 headers to insert */
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipHdrInsrtIpParams             ipParams;  /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_IP */
+        t_FmPcdManipHdrInsrt                    insrt;     /**< Used when type is one of e_FM_PCD_MANIP_INSRT_BY_HDR_UDP,
+                                                                e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE, or
+                                                                e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
+    } u;
+} t_FmPcdManipHdrInsrtByHdrParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header insertion manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrInsrtParams {
+    e_FmPcdManipHdrInsrtType                    type;       /**< Type of insertion manipulation */
+    union {
+        t_FmPcdManipHdrInsrtByHdrParams         byHdr;      /**< Parameters for defining header insertion manipulation by header type,
+                                                                 relevant if 'type' = e_FM_PCD_MANIP_INSRT_BY_HDR */
+        t_FmPcdManipHdrInsrtGenericParams       generic;    /**< Parameters for defining generic header insertion manipulation,
+                                                                 relevant if 'type' = e_FM_PCD_MANIP_INSRT_GENERIC */
+#ifdef FM_CAPWAP_SUPPORT
+        t_FmPcdManipHdrInsrtByTemplateParams    byTemplate; /**< Parameters for defining header insertion manipulation by template,
+                                                                 relevant if 'type' = e_FM_PCD_MANIP_INSRT_BY_TEMPLATE */
+#endif /* FM_CAPWAP_SUPPORT */
+    } u;
+} t_FmPcdManipHdrInsrtParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header removal manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrRmvParams {
+    e_FmPcdManipHdrRmvType                  type;       /**< Type of header removal manipulation */
+    union {
+        t_FmPcdManipHdrRmvByHdrParams       byHdr;      /**< Parameters for defining header removal manipulation by header type,
+                                                             relevant if type = e_FM_PCD_MANIP_RMV_BY_HDR */
+        t_FmPcdManipHdrRmvGenericParams     generic;    /**< Parameters for defining generic header removal manipulation,
+                                                             relevant if type = e_FM_PCD_MANIP_RMV_GENERIC */
+    } u;
+} t_FmPcdManipHdrRmvParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation node
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrParams {
+    bool                                        rmv;                /**< TRUE, to define removal manipulation */
+    t_FmPcdManipHdrRmvParams                    rmvParams;          /**< Parameters for removal manipulation, relevant if 'rmv' = TRUE */
+
+    bool                                        insrt;              /**< TRUE, to define insertion manipulation */
+    t_FmPcdManipHdrInsrtParams                  insrtParams;        /**< Parameters for insertion manipulation, relevant if 'insrt' = TRUE */
+
+    bool                                        fieldUpdate;        /**< TRUE, to define field update manipulation */
+    t_FmPcdManipHdrFieldUpdateParams            fieldUpdateParams;  /**< Parameters for field update manipulation, relevant if 'fieldUpdate' = TRUE */
+
+    bool                                        custom;             /**< TRUE, to define custom manipulation */
+    t_FmPcdManipHdrCustomParams                 customParams;       /**< Parameters for custom manipulation, relevant if 'custom' = TRUE */
+
+    bool                                        dontParseAfterManip;/**< FALSE to activate the parser a second time after
+                                                                         completing the manipulation on the frame */
+} t_FmPcdManipHdrParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining fragmentation manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipFragParams {
+    e_NetHeaderType                     hdr;          /**< Header selection */
+    union {
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipFragCapwapParams    capwapFrag;   /**< Parameters for defining CAPWAP fragmentation,
+                                                           relevant if 'hdr' = HEADER_TYPE_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
+        t_FmPcdManipFragIpParams        ipFrag;       /**< Parameters for defining IP fragmentation,
+                                                           relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+    } u;
+} t_FmPcdManipFragParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining reassembly manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipReassemParams {
+    e_NetHeaderType                     hdr;          /**< Header selection */
+    union {
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipReassemCapwapParams capwapReassem;  /**< Parameters for defining CAPWAP reassembly,
+                                                           relevant if 'hdr' = HEADER_TYPE_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
+
+        t_FmPcdManipReassemIpParams     ipReassem;    /**< Parameters for defining IP reassembly,
+                                                           relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+    } u;
+} t_FmPcdManipReassemParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a manipulation node
+*//***************************************************************************/
+typedef struct t_FmPcdManipParams {
+    e_FmPcdManipType                        type;               /**< Selects type of manipulation node */
+    union{
+        t_FmPcdManipHdrParams               hdr;                /**< Parameters for defining header manipulation node */
+        t_FmPcdManipReassemParams           reassem;            /**< Parameters for defining reassembly manipulation node */
+        t_FmPcdManipFragParams              frag;               /**< Parameters for defining fragmentation manipulation node */
+        t_FmPcdManipSpecialOffloadParams    specialOffload;     /**< Parameters for defining special offload manipulation node */
+    } u;
+
+    t_Handle                                h_NextManip;        /**< Supported for Header Manipulation only;
+                                                                     Handle to another (previously defined) manipulation node;
+                                                                     Allows concatenation of manipulation actions;
+                                                                     This parameter is optional and may be NULL. */
+#ifdef FM_CAPWAP_SUPPORT
+    bool                                    fragOrReasm;        /**< TRUE, if defined fragmentation/reassembly manipulation */
+    t_FmPcdManipFragOrReasmParams           fragOrReasmParams;  /**< Parameters for fragmentation/reassembly manipulation,
+                                                                     relevant if fragOrReasm = TRUE */
+#endif /* FM_CAPWAP_SUPPORT */
+} t_FmPcdManipParams;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving IP reassembly statistics
+*//***************************************************************************/
+typedef struct t_FmPcdManipReassemIpStats {
+    /* common counters for both IPv4 and IPv6 */
+    uint32_t        timeout;                    /**< Counts the number of timeout occurrences */
+    uint32_t        rfdPoolBusy;                /**< Counts the number of failed attempts to allocate
+                                                     a Reassembly Frame Descriptor */
+    uint32_t        internalBufferBusy;         /**< Counts the number of times an internal buffer busy occurred */
+    uint32_t        externalBufferBusy;         /**< Counts the number of times external buffer busy occurred */
+    uint32_t        sgFragments;                /**< Counts the number of Scatter/Gather fragments */
+    uint32_t        dmaSemaphoreDepletion;      /**< Counts the number of failed attempts to allocate a DMA semaphore */
+#if (DPAA_VERSION >= 11)
+    uint32_t        nonConsistentSp;            /**< Counts the number of Non Consistent Storage Profile events for
+                                                     successfully reassembled frames */
+#endif /* (DPAA_VERSION >= 11) */
+    struct {
+        uint32_t    successfullyReassembled;    /**< Counts the number of successfully reassembled frames */
+        uint32_t    validFragments;             /**< Counts the total number of valid fragments that
+                                                     have been processed for all frames */
+        uint32_t    processedFragments;         /**< Counts the number of processed fragments
+                                                     (valid and error fragments) for all frames */
+        uint32_t    malformedFragments;         /**< Counts the number of malformed fragments processed for all frames */
+        uint32_t    discardedFragments;         /**< Counts the number of fragments discarded by the reassembly process */
+        uint32_t    autoLearnBusy;              /**< Counts the number of times a busy condition occurs when attempting
+                                                     to access an IP-Reassembly Automatic Learning Hash set */
+        uint32_t    moreThan16Fragments;        /**< Counts the fragment occurrences in which the number of fragments-per-frame
+                                                     exceeds 16 */
+    } specificHdrStatistics[2];                 /**< slot '0' is for IPv4, slot '1' is for IPv6 */
+} t_FmPcdManipReassemIpStats;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving IP fragmentation statistics
+*//***************************************************************************/
+typedef struct t_FmPcdManipFragIpStats {
+    uint32_t    totalFrames;            /**< Number of frames that passed through the manipulation node */
+    uint32_t    fragmentedFrames;       /**< Number of frames that were fragmented */
+    uint32_t    generatedFragments;     /**< Number of fragments that were generated */
+} t_FmPcdManipFragIpStats;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Structure for retrieving CAPWAP reassembly statistics
+*//***************************************************************************/
+typedef struct t_FmPcdManipReassemCapwapStats {
+    uint32_t    timeout;                    /**< Counts the number of timeout occurrences */
+    uint32_t    rfdPoolBusy;                /**< Counts the number of failed attempts to allocate
+                                                 a Reassembly Frame Descriptor */
+    uint32_t    internalBufferBusy;         /**< Counts the number of times an internal buffer busy occurred */
+    uint32_t    externalBufferBusy;         /**< Counts the number of times external buffer busy occurred */
+    uint32_t    sgFragments;                /**< Counts the number of Scatter/Gather fragments */
+    uint32_t    dmaSemaphoreDepletion;      /**< Counts the number of failed attempts to allocate a DMA semaphore */
+    uint32_t    successfullyReassembled;    /**< Counts the number of successfully reassembled frames */
+    uint32_t    validFragments;             /**< Counts the total number of valid fragments that
+                                                 have been processed for all frames */
+    uint32_t    processedFragments;         /**< Counts the number of processed fragments
+                                                 (valid and error fragments) for all frames */
+    uint32_t    malformedFragments;         /**< Counts the number of malformed fragments processed for all frames */
+    uint32_t    autoLearnBusy;              /**< Counts the number of times a busy condition occurs when attempting
+                                                 to access an Reassembly Automatic Learning Hash set */
+    uint32_t    discardedFragments;         /**< Counts the number of fragments discarded by the reassembly process */
+    uint32_t    moreThan16Fragments;        /**< Counts the fragment occurrences in which the number of fragments-per-frame
+                                                 exceeds 16 */
+    uint32_t    exceedMaxReassemblyFrameLen;/**< ounts the number of times that a successful reassembled frame
+                                                 length exceeds MaxReassembledFrameLength value */
+} t_FmPcdManipReassemCapwapStats;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving CAPWAP fragmentation statistics
+*//***************************************************************************/
+typedef struct t_FmPcdManipFragCapwapStats {
+    uint32_t    totalFrames;            /**< Number of frames that passed through the manipulation node */
+    uint32_t    fragmentedFrames;       /**< Number of frames that were fragmented */
+    uint32_t    generatedFragments;     /**< Number of fragments that were generated */
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    uint8_t     sgAllocationFailure;    /**< Number of allocation failure of s/g buffers */
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+} t_FmPcdManipFragCapwapStats;
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Description   Structure for retrieving reassembly statistics
+*//***************************************************************************/
+typedef struct t_FmPcdManipReassemStats {
+    union {
+        t_FmPcdManipReassemIpStats  ipReassem;  /**< Structure for IP reassembly statistics */
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipReassemCapwapStats  capwapReassem;  /**< Structure for CAPWAP reassembly statistics */
+#endif /* (DPAA_VERSION >= 11) */
+    } u;
+} t_FmPcdManipReassemStats;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving fragmentation statistics
+*//***************************************************************************/
+typedef struct t_FmPcdManipFragStats {
+    union {
+        t_FmPcdManipFragIpStats     ipFrag;     /**< Structure for IP fragmentation statistics */
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipFragCapwapStats capwapFrag; /**< Structure for CAPWAP fragmentation statistics */
+#endif /* (DPAA_VERSION >= 11) */
+    } u;
+} t_FmPcdManipFragStats;
+
+/**************************************************************************//**
+ @Description   Structure for selecting manipulation statistics
+*//***************************************************************************/
+typedef struct t_FmPcdManipStats {
+    union {
+        t_FmPcdManipReassemStats    reassem;    /**< Structure for reassembly statistics */
+        t_FmPcdManipFragStats       frag;       /**< Structure for fragmentation statistics */
+    } u;
+} t_FmPcdManipStats;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Parameters for defining frame replicator group and its members
+*//***************************************************************************/
+typedef struct t_FmPcdFrmReplicGroupParams {
+    uint8_t                     maxNumOfEntries;    /**< Maximal number of members in the group;
+                                                         Must be at least 2. */
+    uint8_t                     numOfEntries;       /**< Number of members in the group;
+                                                         Must be at least 1. */
+    t_FmPcdCcNextEngineParams   nextEngineParams[FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES];
+                                                    /**< Array of members' parameters */
+} t_FmPcdFrmReplicGroupParams;
+#endif /* (DPAA_VERSION >= 11) */
+
+#ifdef FM_CAPWAP_SUPPORT
+/**************************************************************************//**
+ @Description   structure for defining statistics node
+*//***************************************************************************/
+typedef struct t_FmPcdStatsParams {
+    e_FmPcdStatsType    type;   /**< type of statistics node */
+} t_FmPcdStatsParams;
+#endif /* FM_CAPWAP_SUPPORT */
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_NetEnvCharacteristicsSet
+
+ @Description   Define a set of Network Environment Characteristics.
+
+                When setting an environment it is important to understand its
+                application. It is not meant to describe the flows that will run
+                on the ports using this environment, but what the user means TO DO
+                with the PCD mechanisms in order to parse-classify-distribute those
+                frames.
+                By specifying a distinction unit, the user means it would use that option
+                for distinction between frames at either a KeyGen scheme or a coarse
+                classification action descriptor. Using interchangeable headers to define a
+                unit means that the user is indifferent to which of the interchangeable
+                headers is present in the frame, and wants the distinction to be based
+                on the presence of either one of them.
+
+                Depending on context, there are limitations to the use of environments. A
+                port using the PCD functionality is bound to an environment. Some or even
+                all ports may share an environment but also an environment per port is
+                possible. When initializing a scheme, a classification plan group (see below),
+                or a coarse classification tree, one of the initialized environments must be
+                stated and related to. When a port is bound to a scheme, a classification
+                plan group, or a coarse classification tree, it MUST be bound to the same
+                environment.
+
+                The different PCD modules, may relate (for flows definition) ONLY on
+                distinction units as defined by their environment. When initializing a
+                scheme for example, it may not choose to select IPV4 as a match for
+                recognizing flows unless it was defined in the relating environment. In
+                fact, to guide the user through the configuration of the PCD, each module's
+                characterization in terms of flows is not done using protocol names, but using
+                environment indexes.
+
+                In terms of HW implementation, the list of distinction units sets the LCV vectors
+                and later used for match vector, classification plan vectors and coarse classification
+                indexing.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     p_NetEnvParams  A structure of parameters for the initialization of
+                                the network environment.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams *p_NetEnvParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_NetEnvCharacteristicsDelete
+
+ @Description   Deletes a set of Network Environment Characteristics.
+
+ @Param[in]     h_NetEnv        A handle to the Network environment.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_NetEnvCharacteristicsDelete(t_Handle h_NetEnv);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSchemeSet
+
+ @Description   Initializing or modifying and enabling a scheme for the KeyGen.
+                This routine should be called for adding or modifying a scheme.
+                When a scheme needs modifying, the API requires that it will be
+                rewritten. In such a case 'modify' should be TRUE. If the
+                routine is called for a valid scheme and 'modify' is FALSE,
+                it will return error.
+
+ @Param[in]     h_FmPcd         If this is a new scheme - A handle to an FM PCD Module.
+                                Otherwise NULL (ignored by driver).
+ @Param[in,out] p_SchemeParams  A structure of parameters for defining the scheme
+
+ @Return        A handle to the initialized scheme on success; NULL code otherwise.
+                When used as "modify" (rather than for setting a new scheme),
+                p_SchemeParams->id.h_Scheme will return NULL if action fails due to scheme
+                BUSY state.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_KgSchemeSet(t_Handle                h_FmPcd,
+                            t_FmPcdKgSchemeParams   *p_SchemeParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSchemeDelete
+
+ @Description   Deleting an initialized scheme.
+
+ @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSchemeSet()
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init() & FM_PCD_KgSchemeSet().
+*//***************************************************************************/
+t_Error     FM_PCD_KgSchemeDelete(t_Handle h_Scheme);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSchemeGetCounter
+
+ @Description   Reads scheme packet counter.
+
+ @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSchemeSet().
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PCD_Init() & FM_PCD_KgSchemeSet().
+*//***************************************************************************/
+uint32_t  FM_PCD_KgSchemeGetCounter(t_Handle h_Scheme);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSchemeSetCounter
+
+ @Description   Writes scheme packet counter.
+
+ @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSchemeSet().
+ @Param[in]     value           New scheme counter value - typically '0' for
+                                resetting the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init() & FM_PCD_KgSchemeSet().
+*//***************************************************************************/
+t_Error  FM_PCD_KgSchemeSetCounter(t_Handle h_Scheme, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrProfileSet
+
+ @Description   Sets a profile entry in the policer profile table.
+                The routine overrides any existing value.
+
+ @Param[in]     h_FmPcd           A handle to an FM PCD Module.
+ @Param[in]     p_Profile         A structure of parameters for defining a
+                                  policer profile entry.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+                When used as "modify" (rather than for setting a new profile),
+                p_Profile->id.h_Profile will return NULL if action fails due to profile
+                BUSY state.
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_PlcrProfileSet(t_Handle                  h_FmPcd,
+                               t_FmPcdPlcrProfileParams  *p_Profile);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrProfileDelete
+
+ @Description   Delete a profile entry in the policer profile table.
+                The routine set entry to invalid.
+
+ @Param[in]     h_Profile       A handle to the profile.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_PlcrProfileDelete(t_Handle h_Profile);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrProfileGetCounter
+
+ @Description   Sets an entry in the classification plan.
+                The routine overrides any existing value.
+
+ @Param[in]     h_Profile       A handle to the profile.
+ @Param[in]     counter         Counter selector.
+
+ @Return        specific counter value.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+uint32_t FM_PCD_PlcrProfileGetCounter(t_Handle                      h_Profile,
+                                      e_FmPcdPlcrProfileCounters    counter);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrProfileSetCounter
+
+ @Description   Sets an entry in the classification plan.
+                The routine overrides any existing value.
+
+ @Param[in]     h_Profile       A handle to the profile.
+ @Param[in]     counter         Counter selector.
+ @Param[in]     value           value to set counter with.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_PlcrProfileSetCounter(t_Handle                   h_Profile,
+                                     e_FmPcdPlcrProfileCounters counter,
+                                     uint32_t                   value);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcRootBuild
+
+ @Description   This routine must be called to define a complete coarse
+                classification tree. This is the way to define coarse
+                classification to a certain flow - the KeyGen schemes
+                may point only to trees defined in this way.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     p_Params        A structure of parameters to define the tree.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_CcRootBuild (t_Handle             h_FmPcd,
+                             t_FmPcdCcTreeParams  *p_Params);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcRootDelete
+
+ @Description   Deleting an built tree.
+
+ @Param[in]     h_CcTree        A handle to a CC tree.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcRootModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the entry of the tree.
+
+ @Param[in]     h_CcTree                    A handle to the tree
+ @Param[in]     grpId                       A Group index in the tree
+ @Param[in]     index                       Entry index in the group defined by grpId
+ @Param[in]     p_FmPcdCcNextEngineParams   Pointer to new next engine parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcBuildTree().
+*//***************************************************************************/
+t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
+                                      uint8_t                   grpId,
+                                      uint8_t                   index,
+                                      t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableSet
+
+ @Description   This routine should be called for each CC (coarse classification)
+                node. The whole CC tree should be built bottom up so that each
+                node points to already defined nodes.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     p_Param         A structure of parameters defining the CC node
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle   FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_Param);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableDelete
+
+ @Description   Deleting an built node.
+
+ @Param[in]     h_CcNode        A handle to a CC node.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableModifyMissNextEngine
+
+ @Description   Modify the Next Engine Parameters of the Miss key case of the node.
+
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     p_FmPcdCcNextEngineParams   Parameters for defining next engine
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet();
+                Not relevant in the case the node is of type 'INDEXED_LOOKUP'.
+                When configuring nextEngine = e_FM_PCD_CC, note that
+                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+                from the currently changed table.
+
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle                  h_CcNode,
+                                              t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableRemoveKey
+
+ @Description   Remove the key (including next engine parameters of this key)
+                defined by the index of the relevant node.
+
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for removing
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
+                node and the nodes that lead to it.
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableAddKey
+
+ @Description   Add the key (including next engine parameters of this key in the
+                index defined by the keyIndex. Note that 'FM_PCD_LAST_KEY_INDEX'
+                may be used by user that don't care about the position of the
+                key in the table - in that case, the key will be automatically
+                added by the driver in the last available entry.
+
+ @Param[in]     h_CcNode     A handle to the node
+ @Param[in]     keyIndex     Key index for adding.
+ @Param[in]     keySize      Key size of added key
+ @Param[in]     p_KeyParams  A pointer to the parameters includes
+                             new key with Next Engine Parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
+                node and the nodes that lead to it.
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
+                                uint16_t            keyIndex,
+                                uint8_t             keySize,
+                                t_FmPcdCcKeyParams  *p_KeyParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the relevant key entry of the node.
+
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for Next Engine modifications
+ @Param[in]     p_FmPcdCcNextEngineParams   Parameters for defining next engine
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
+                When configuring nextEngine = e_FM_PCD_CC, note that
+                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+                from the currently changed table.
+
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle                  h_CcNode,
+                                          uint16_t                  keyIndex,
+                                          t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableModifyKeyAndNextEngine
+
+ @Description   Modify the key and Next Engine Parameters of this key in the
+                index defined by the keyIndex.
+
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for adding
+ @Param[in]     keySize                     Key size of added key
+ @Param[in]     p_KeyParams                 A pointer to the parameters includes
+                                            modified key and modified Next Engine Parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
+                node and the nodes that lead to it.
+                When configuring nextEngine = e_FM_PCD_CC, note that
+                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+                from the currently changed table.
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle            h_CcNode,
+                                                uint16_t            keyIndex,
+                                                uint8_t             keySize,
+                                                t_FmPcdCcKeyParams  *p_KeyParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableModifyKey
+
+ @Description   Modify the key in the index defined by the keyIndex.
+
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for adding
+ @Param[in]     keySize                     Key size of added key
+ @Param[in]     p_Key                       A pointer to the new key
+ @Param[in]     p_Mask                      A pointer to the new mask if relevant,
+                                            otherwise pointer to NULL
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
+                node and the nodes that lead to it.
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
+                                   uint16_t keyIndex,
+                                   uint8_t  keySize,
+                                   uint8_t  *p_Key,
+                                   uint8_t  *p_Mask);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableFindNRemoveKey
+
+ @Description   Remove the key (including next engine parameters of this key)
+                defined by the key and mask. Note that this routine will search
+                the node to locate the index of the required key (& mask) to remove.
+
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keySize                     Key size of the one to remove.
+ @Param[in]     p_Key                       A pointer to the requested key to remove.
+ @Param[in]     p_Mask                      A pointer to the mask if relevant,
+                                            otherwise pointer to NULL
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
+                node and the nodes that lead to it.
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
+                                        uint8_t  keySize,
+                                        uint8_t  *p_Key,
+                                        uint8_t  *p_Mask);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableFindNModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the relevant key entry of
+                the node. Note that this routine will search the node to locate
+                the index of the required key (& mask) to modify.
+
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keySize                     Key size of the one to modify.
+ @Param[in]     p_Key                       A pointer to the requested key to modify.
+ @Param[in]     p_Mask                      A pointer to the mask if relevant,
+                                            otherwise pointer to NULL
+ @Param[in]     p_FmPcdCcNextEngineParams   Parameters for defining next engine
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
+                When configuring nextEngine = e_FM_PCD_CC, note that
+                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+                from the currently changed table.
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNode,
+                                               uint8_t                   keySize,
+                                               uint8_t                   *p_Key,
+                                               uint8_t                   *p_Mask,
+                                               t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableFindNModifyKeyAndNextEngine
+
+ @Description   Modify the key and Next Engine Parameters of this key in the
+                index defined by the keyIndex. Note that this routine will search
+                the node to locate the index of the required key (& mask) to modify.
+
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keySize                     Key size of the one to modify.
+ @Param[in]     p_Key                       A pointer to the requested key to modify.
+ @Param[in]     p_Mask                      A pointer to the mask if relevant,
+                                            otherwise pointer to NULL
+ @Param[in]     p_KeyParams                 A pointer to the parameters includes
+                                            modified key and modified Next Engine Parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
+                node and the nodes that lead to it.
+                When configuring nextEngine = e_FM_PCD_CC, note that
+                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+                from the currently changed table.
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNode,
+                                                     uint8_t             keySize,
+                                                     uint8_t             *p_Key,
+                                                     uint8_t             *p_Mask,
+                                                     t_FmPcdCcKeyParams  *p_KeyParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableFindNModifyKey
+
+ @Description   Modify the key  in the index defined by the keyIndex. Note that
+                this routine will search the node to locate the index of the
+                required key (& mask) to modify.
+
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keySize                     Key size of the one to modify.
+ @Param[in]     p_Key                       A pointer to the requested key to modify.
+ @Param[in]     p_Mask                      A pointer to the mask if relevant,
+                                            otherwise pointer to NULL
+ @Param[in]     p_NewKey                    A pointer to the new key
+ @Param[in]     p_NewMask                   A pointer to the new mask if relevant,
+                                            otherwise pointer to NULL
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
+                node and the nodes that lead to it.
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
+                                        uint8_t  keySize,
+                                        uint8_t  *p_Key,
+                                        uint8_t  *p_Mask,
+                                        uint8_t  *p_NewKey,
+                                        uint8_t  *p_NewMask);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableGetKeyCounter
+
+ @Description   This routine may be used to get a counter of specific key in a CC
+                Node; This counter reflects how many frames passed that were matched
+                this key.
+
+ @Param[in]     h_CcNode        A handle to the node
+ @Param[in]     keyIndex        Key index for adding
+
+ @Return        The specific key counter.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableGetKeyStatistics
+
+ @Description   This routine may be used to get statistics counters of specific key
+                in a CC Node.
+
+                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+                these counters reflect how many frames passed that were matched
+                this key; The total frames count will be returned in the counter
+                of the first range (as only one frame length range was defined).
+                If 'e_FM_PCD_CC_STATS_MODE_RMON' was set for this node, the total
+                frame count will be separated to frame length counters, based on
+                provided frame length ranges.
+
+ @Param[in]     h_CcNode        A handle to the node
+ @Param[in]     keyIndex        Key index for adding
+ @Param[out]    p_KeyStatistics Key statistics counters
+
+ @Return        The specific key statistics.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableGetKeyStatistics(t_Handle                  h_CcNode,
+                                          uint16_t                  keyIndex,
+                                          t_FmPcdCcKeyStatistics    *p_KeyStatistics);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableGetMissStatistics
+
+ @Description   This routine may be used to get statistics counters of miss entry
+                in a CC Node.
+
+                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+                these counters reflect how many frames were not matched to any
+                existing key and therefore passed through the miss entry; The
+                total frames count will be returned in the counter of the
+                first range (as only one frame length range was defined).
+
+ @Param[in]     h_CcNode            A handle to the node
+ @Param[out]    p_MissStatistics    Statistics counters for 'miss'
+
+ @Return        The statistics for 'miss'.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableGetMissStatistics(t_Handle                  h_CcNode,
+                                           t_FmPcdCcKeyStatistics    *p_MissStatistics);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableFindNGetKeyStatistics
+
+ @Description   This routine may be used to get statistics counters of specific key
+                in a CC Node.
+
+                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+                these counters reflect how many frames passed that were matched
+                this key; The total frames count will be returned in the counter
+                of the first range (as only one frame length range was defined).
+                If 'e_FM_PCD_CC_STATS_MODE_RMON' was set for this node, the total
+                frame count will be separated to frame length counters, based on
+                provided frame length ranges.
+                Note that this routine will search the node to locate the index
+                of the required key based on received key parameters.
+
+ @Param[in]     h_CcNode        A handle to the node
+ @Param[in]     keySize         Size of the requested key
+ @Param[in]     p_Key           A pointer to the requested key
+ @Param[in]     p_Mask          A pointer to the mask if relevant,
+                                otherwise pointer to NULL
+ @Param[out]    p_KeyStatistics Key statistics counters
+
+ @Return        The specific key statistics.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableFindNGetKeyStatistics(t_Handle                 h_CcNode,
+                                               uint8_t                  keySize,
+                                               uint8_t                  *p_Key,
+                                               uint8_t                  *p_Mask,
+                                               t_FmPcdCcKeyStatistics   *p_KeyStatistics);
+
+/**************************************************************************//*
+ @Function      FM_PCD_MatchTableGetNextEngine
+
+ @Description   Gets NextEngine of the relevant keyIndex.
+
+ @Param[in]     h_CcNode                    A handle to the node.
+ @Param[in]     keyIndex                    keyIndex in the relevant node.
+ @Param[out]    p_FmPcdCcNextEngineParams   here updated nextEngine parameters for
+                                            the relevant keyIndex of the CC Node
+                                            received as parameter to this function
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
+                                       uint16_t                     keyIndex,
+                                       t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//*
+ @Function      FM_PCD_MatchTableGetIndexedHashBucket
+
+ @Description   This routine simulates KeyGen operation on the provided key and
+                calculates to which hash bucket it will be mapped.
+
+ @Param[in]     h_CcNode                A handle to the node.
+ @Param[in]     kgKeySize               Key size as it was configured in the KG
+                                        scheme that leads to this hash.
+ @Param[in]     p_KgKey                 Pointer to the key; must be like the key
+                                        that the KG is generated, i.e. the same
+                                        extraction and with mask if exist.
+ @Param[in]     kgHashShift             Hash-shift as it was configured in the KG
+                                        scheme that leads to this hash.
+ @Param[out]    p_CcNodeBucketHandle    Pointer to the bucket of the provided key.
+ @Param[out]    p_BucketIndex           Index to the bucket of the provided key
+ @Param[out]    p_LastIndex             Pointer to last index in the bucket of the
+                                        provided key.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet()
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableGetIndexedHashBucket(t_Handle    h_CcNode,
+                                              uint8_t     kgKeySize,
+                                              uint8_t     *p_KgKey,
+                                              uint8_t     kgHashShift,
+                                              t_Handle    *p_CcNodeBucketHandle,
+                                              uint8_t     *p_BucketIndex,
+                                              uint16_t    *p_LastIndex);
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableSet
+
+ @Description   This routine initializes a hash table structure.
+                KeyGen hash result determines the hash bucket.
+                Next, KeyGen key is compared against all keys of this
+                bucket (exact match).
+                Number of sets (number of buckets) of the hash equals to the
+                number of 1-s in 'hashResMask' in the provided parameters.
+                Number of hash table ways is then calculated by dividing
+                'maxNumOfKeys' equally between the hash sets. This is the maximal
+                number of keys that a hash bucket may hold.
+                The hash table is initialized empty and keys may be
+                added to it following the initialization. Keys masks are not
+                supported in current hash table implementation.
+                The initialized hash table can be integrated as a node in a
+                CC tree.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     p_Param     A structure of parameters defining the hash table
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param);
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableDelete
+
+ @Description   This routine deletes the provided hash table and released all
+                its allocated resources.
+
+ @Param[in]     h_HashTbl       A handle to a hash table
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+t_Error FM_PCD_HashTableDelete(t_Handle h_HashTbl);
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableAddKey
+
+ @Description   This routine adds the provided key (including next engine
+                parameters of this key) to the hash table.
+                The key is added as the last key of the bucket that it is
+                mapped to.
+
+ @Param[in]     h_HashTbl    A handle to a hash table
+ @Param[in]     keySize      Key size of added key
+ @Param[in]     p_KeyParams  A pointer to the parameters includes
+                             new key with next engine parameters; The pointer
+                             to the key mask must be NULL, as masks are not
+                             supported in hash table implementation.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+t_Error FM_PCD_HashTableAddKey(t_Handle            h_HashTbl,
+                               uint8_t             keySize,
+                               t_FmPcdCcKeyParams  *p_KeyParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableRemoveKey
+
+ @Description   This routine removes the requested key (including next engine
+                parameters of this key) from the hash table.
+
+ @Param[in]     h_HashTbl    A handle to a hash table
+ @Param[in]     keySize      Key size of the one to remove.
+ @Param[in]     p_Key        A pointer to the requested key to remove.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+t_Error FM_PCD_HashTableRemoveKey(t_Handle h_HashTbl,
+                                  uint8_t  keySize,
+                                  uint8_t  *p_Key);
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableModifyNextEngine
+
+ @Description   This routine modifies the next engine for the provided key. The
+                key should be previously added to the hash table.
+
+ @Param[in]     h_HashTbl                   A handle to a hash table
+ @Param[in]     keySize                     Key size of the key to modify.
+ @Param[in]     p_Key                       A pointer to the requested key to modify.
+ @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine
+                                            parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+                When configuring nextEngine = e_FM_PCD_CC, note that
+                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+                from the currently changed table.
+*//***************************************************************************/
+t_Error FM_PCD_HashTableModifyNextEngine(t_Handle                  h_HashTbl,
+                                         uint8_t                   keySize,
+                                         uint8_t                   *p_Key,
+                                         t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableModifyMissNextEngine
+
+ @Description   This routine modifies the next engine on key match miss.
+
+ @Param[in]     h_HashTbl                   A handle to a hash table
+ @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine
+                                            parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+                When configuring nextEngine = e_FM_PCD_CC, note that
+                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+                from the currently changed table.
+*//***************************************************************************/
+t_Error FM_PCD_HashTableModifyMissNextEngine(t_Handle                  h_HashTbl,
+                                             t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//*
+ @Function      FM_PCD_HashTableGetMissNextEngine
+
+ @Description   Gets NextEngine in case of key match miss.
+
+ @Param[in]     h_HashTbl                   A handle to a hash table
+ @Param[out]    p_FmPcdCcNextEngineParams   Next engine parameters for the specified
+                                            hash table.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+t_Error FM_PCD_HashTableGetMissNextEngine(t_Handle                     h_HashTbl,
+                                          t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableFindNGetKeyStatistics
+
+ @Description   This routine may be used to get statistics counters of specific key
+                in a hash table.
+
+                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+                these counters reflect how many frames passed that were matched
+                this key; The total frames count will be returned in the counter
+                of the first range (as only one frame length range was defined).
+                If 'e_FM_PCD_CC_STATS_MODE_RMON' was set for this node, the total
+                frame count will be separated to frame length counters, based on
+                provided frame length ranges.
+                Note that this routine will identify the bucket of this key in
+                the hash table and will search the bucket to locate the index
+                of the required key based on received key parameters.
+
+ @Param[in]     h_HashTbl       A handle to a hash table
+ @Param[in]     keySize         Size of the requested key
+ @Param[in]     p_Key           A pointer to the requested key
+ @Param[out]    p_KeyStatistics Key statistics counters
+
+ @Return        The specific key statistics.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+t_Error FM_PCD_HashTableFindNGetKeyStatistics(t_Handle                 h_HashTbl,
+                                              uint8_t                  keySize,
+                                              uint8_t                  *p_Key,
+                                              t_FmPcdCcKeyStatistics   *p_KeyStatistics);
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableGetMissStatistics
+
+ @Description   This routine may be used to get statistics counters of 'miss'
+                entry of the a hash table.
+
+                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+                these counters reflect how many frames were not matched to any
+                existing key and therefore passed through the miss entry;
+
+ @Param[in]     h_HashTbl           A handle to a hash table
+ @Param[out]    p_MissStatistics    Statistics counters for 'miss'
+
+ @Return        The statistics for 'miss'.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+t_Error FM_PCD_HashTableGetMissStatistics(t_Handle                 h_HashTbl,
+                                          t_FmPcdCcKeyStatistics   *p_MissStatistics);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ManipNodeSet
+
+ @Description   This routine should be called for defining a manipulation
+                node. A manipulation node must be defined before the CC node
+                that precedes it.
+
+ @Param[in]     h_FmPcd             FM PCD module descriptor.
+ @Param[in]     p_FmPcdManipParams  A structure of parameters defining the manipulation
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_FmPcdManipParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ManipNodeDelete
+
+ @Description   Delete an existing manipulation node.
+
+ @Param[in]     h_ManipNode     A handle to a manipulation node.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+t_Error  FM_PCD_ManipNodeDelete(t_Handle h_ManipNode);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ManipGetStatistics
+
+ @Description   Retrieve the manipulation statistics.
+
+ @Param[in]     h_ManipNode         A handle to a manipulation node.
+ @Param[out]    p_FmPcdManipStats   A structure for retrieving the manipulation statistics
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+t_Error FM_PCD_ManipGetStatistics(t_Handle h_ManipNode, t_FmPcdManipStats *p_FmPcdManipStats);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ManipNodeReplace
+
+ @Description   Change existing manipulation node to be according to new requirement.
+
+ @Param[in]     h_ManipNode         A handle to a manipulation node.
+ @Param[out]    p_ManipParams       A structure of parameters defining the change requirement
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+t_Error FM_PCD_ManipNodeReplace(t_Handle h_ManipNode, t_FmPcdManipParams *p_ManipParams);
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicSetGroup
+
+ @Description   Initialize a Frame Replicator group.
+
+ @Param[in]     h_FmPcd                FM PCD module descriptor.
+ @Param[in]     p_FrmReplicGroupParam  A structure of parameters for the initialization of
+                                       the frame replicator group.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_FrmReplicSetGroup(t_Handle h_FmPcd, t_FmPcdFrmReplicGroupParams *p_FrmReplicGroupParam);
+
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicDeleteGroup
+
+ @Description   Delete a Frame Replicator group.
+
+ @Param[in]     h_FrmReplicGroup  A handle to the frame replicator group.
+
+ @Return        E_OK on success;  Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup().
+*//***************************************************************************/
+t_Error FM_PCD_FrmReplicDeleteGroup(t_Handle h_FrmReplicGroup);
+
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicAddMember
+
+ @Description   Add the member in the index defined by the memberIndex.
+
+ @Param[in]     h_FrmReplicGroup   A handle to the frame replicator group.
+ @Param[in]     memberIndex        member index for adding.
+ @Param[in]     p_MemberParams     A pointer to the new member parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup() of this group.
+*//***************************************************************************/
+t_Error FM_PCD_FrmReplicAddMember(t_Handle                   h_FrmReplicGroup,
+                                  uint16_t                   memberIndex,
+                                  t_FmPcdCcNextEngineParams *p_MemberParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicRemoveMember
+
+ @Description   Remove the member defined by the index from the relevant group.
+
+ @Param[in]     h_FrmReplicGroup   A handle to the frame replicator group.
+ @Param[in]     memberIndex        member index for removing.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup() of this group.
+*//***************************************************************************/
+t_Error FM_PCD_FrmReplicRemoveMember(t_Handle h_FrmReplicGroup,
+                                     uint16_t memberIndex);
+#endif /* (DPAA_VERSION >= 11) */
+
+#ifdef FM_CAPWAP_SUPPORT
+/**************************************************************************//**
+ @Function      FM_PCD_StatisticsSetNode
+
+ @Description   This routine should be called for defining a statistics node.
+
+ @Param[in]     h_FmPcd             FM PCD module descriptor.
+ @Param[in]     p_FmPcdstatsParams  A structure of parameters defining the statistics
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_FmPcdstatsParams);
+#endif /* FM_CAPWAP_SUPPORT */
+
+/** @} */ /* end of FM_PCD_Runtime_build_grp group */
+/** @} */ /* end of FM_PCD_Runtime_grp group */
+/** @} */ /* end of FM_PCD_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+#ifdef NCSW_BACKWARD_COMPATIBLE_API
+#define FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS   FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
+#define e_FM_PCD_MANIP_ONE_WAYS_HASH            e_FM_PCD_MANIP_ONE_WAY_HASH
+#define e_FM_PCD_MANIP_TOW_WAYS_HASH            e_FM_PCD_MANIP_TWO_WAYS_HASH
+
+#define e_FM_PCD_MANIP_FRAGMENT_PACKECT         e_FM_PCD_MANIP_FRAGMENT_PACKET /* Feb13 */
+
+#define FM_PCD_SetNetEnvCharacteristics(_pcd, _params)  \
+    FM_PCD_NetEnvCharacteristicsSet(_pcd, _params)
+#define FM_PCD_KgSetScheme(_pcd, _params)       FM_PCD_KgSchemeSet(_pcd, _params)
+#define FM_PCD_CcBuildTree(_pcd, _params)       FM_PCD_CcRootBuild(_pcd, _params)
+#define FM_PCD_CcSetNode(_pcd, _params)         FM_PCD_MatchTableSet(_pcd, _params)
+#define FM_PCD_PlcrSetProfile(_pcd, _params)    FM_PCD_PlcrProfileSet(_pcd, _params)
+#define FM_PCD_ManipSetNode(_pcd, _params)      FM_PCD_ManipNodeSet(_pcd, _params)
+
+#define FM_PCD_DeleteNetEnvCharacteristics(_pcd, ...)   \
+    FM_PCD_NetEnvCharacteristicsDelete(__VA_ARGS__)
+#define FM_PCD_KgDeleteScheme(_pcd, ...)   \
+    FM_PCD_KgSchemeDelete(__VA_ARGS__)
+#define FM_PCD_KgGetSchemeCounter(_pcd, ...)   \
+    FM_PCD_KgSchemeGetCounter(__VA_ARGS__)
+#define FM_PCD_KgSetSchemeCounter(_pcd, ...)   \
+    FM_PCD_KgSchemeSetCounter(__VA_ARGS__)
+#define FM_PCD_PlcrDeleteProfile(_pcd, ...)   \
+    FM_PCD_PlcrProfileDelete(__VA_ARGS__)
+#define FM_PCD_PlcrGetProfileCounter(_pcd, ...)   \
+    FM_PCD_PlcrProfileGetCounter(__VA_ARGS__)
+#define FM_PCD_PlcrSetProfileCounter(_pcd, ...)   \
+    FM_PCD_PlcrProfileSetCounter(__VA_ARGS__)
+#define FM_PCD_CcDeleteTree(_pcd, ...)   \
+    FM_PCD_CcRootDelete(__VA_ARGS__)
+#define FM_PCD_CcTreeModifyNextEngine(_pcd, ...)   \
+    FM_PCD_CcRootModifyNextEngine(__VA_ARGS__)
+#define FM_PCD_CcDeleteNode(_pcd, ...)   \
+    FM_PCD_MatchTableDelete(__VA_ARGS__)
+#define FM_PCD_CcNodeModifyMissNextEngine(_pcd, ...)   \
+    FM_PCD_MatchTableModifyMissNextEngine(__VA_ARGS__)
+#define FM_PCD_CcNodeRemoveKey(_pcd, ...)   \
+    FM_PCD_MatchTableRemoveKey(__VA_ARGS__)
+#define FM_PCD_CcNodeAddKey(_pcd, ...)   \
+    FM_PCD_MatchTableAddKey(__VA_ARGS__)
+#define FM_PCD_CcNodeModifyNextEngine(_pcd, ...)   \
+    FM_PCD_MatchTableModifyNextEngine(__VA_ARGS__)
+#define FM_PCD_CcNodeModifyKeyAndNextEngine(_pcd, ...)   \
+    FM_PCD_MatchTableModifyKeyAndNextEngine(__VA_ARGS__)
+#define FM_PCD_CcNodeModifyKey(_pcd, ...)   \
+    FM_PCD_MatchTableModifyKey(__VA_ARGS__)
+#define FM_PCD_CcNodeFindNRemoveKey(_pcd, ...)   \
+    FM_PCD_MatchTableFindNRemoveKey(__VA_ARGS__)
+#define FM_PCD_CcNodeFindNModifyNextEngine(_pcd, ...)   \
+    FM_PCD_MatchTableFindNModifyNextEngine(__VA_ARGS__)
+#define FM_PCD_CcNodeFindNModifyKeyAndNextEngine(_pcd, ...) \
+    FM_PCD_MatchTableFindNModifyKeyAndNextEngine(__VA_ARGS__)
+#define FM_PCD_CcNodeFindNModifyKey(_pcd, ...)   \
+    FM_PCD_MatchTableFindNModifyKey(__VA_ARGS__)
+#define FM_PCD_CcIndexedHashNodeGetBucket(_pcd, ...)   \
+    FM_PCD_MatchTableGetIndexedHashBucket(__VA_ARGS__)
+#define FM_PCD_CcNodeGetNextEngine(_pcd, ...)   \
+    FM_PCD_MatchTableGetNextEngine(__VA_ARGS__)
+#define FM_PCD_CcNodeGetKeyCounter(_pcd, ...)   \
+    FM_PCD_MatchTableGetKeyCounter(__VA_ARGS__)
+#define FM_PCD_ManipDeleteNode(_pcd, ...)   \
+    FM_PCD_ManipNodeDelete(__VA_ARGS__)
+#endif /* NCSW_BACKWARD_COMPATIBLE_API */
+
+
+#endif /* __FM_PCD_EXT */
--- fmlib-fslsdk-v1.7/include/fmd/Peripherals/fm_ext.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/Peripherals/fm_ext.h	2022-05-26 11:28:31.074973657 -0700
@@ -0,0 +1,598 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+
+/**************************************************************************//**
+ @File          fm_ext.h
+
+ @Description   FM Application Programming Interface.
+*//***************************************************************************/
+#ifndef __FM_EXT
+#define __FM_EXT
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "dpaa_ext.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_usr_FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         lnx_usr_FM_lib_grp FM library
+
+ @Description   FM API functions, definitions and enums
+
+                The FM module is the main driver module and is a mandatory module
+                for FM driver users. This module must be initialized first prior
+                to any other drivers modules.
+                The FM is a "singleton" module. It is responsible of the common
+                HW modules: FPM, DMA, common QMI and common BMI initializations and
+                run-time control routines. This module must be initialized always
+                when working with any of the FM modules.
+                NOTE - We assume that the FM library will be initialized only by core No. 0!
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Enum for defining port types
+*//***************************************************************************/
+typedef enum e_FmPortType {
+    e_FM_PORT_TYPE_OH_OFFLINE_PARSING = 0,  /**< Offline parsing port */
+    e_FM_PORT_TYPE_RX,                      /**< 1G Rx port */
+    e_FM_PORT_TYPE_RX_10G,                  /**< 10G Rx port */
+    e_FM_PORT_TYPE_TX,                      /**< 1G Tx port */
+    e_FM_PORT_TYPE_TX_10G,                  /**< 10G Tx port */
+    e_FM_PORT_TYPE_DUMMY
+} e_FmPortType;
+
+/**************************************************************************//**
+ @Description   Parse results memory layout
+*//***************************************************************************/
+typedef _Packed struct t_FmPrsResult {
+    volatile uint8_t     lpid;               /**< Logical port id */
+    volatile uint8_t     shimr;              /**< Shim header result  */
+    volatile uint16_t    l2r;                /**< Layer 2 result */
+    volatile uint16_t    l3r;                /**< Layer 3 result */
+    volatile uint8_t     l4r;                /**< Layer 4 result */
+    volatile uint8_t     cplan;              /**< Classification plan id */
+    volatile uint16_t    nxthdr;             /**< Next Header  */
+    volatile uint16_t    cksum;              /**< Running-sum */
+    volatile uint16_t    flags_frag_off;     /**< Flags & fragment-offset field of the last IP-header */
+    volatile uint8_t     route_type;         /**< Routing type field of a IPv6 routing extension header */
+    volatile uint8_t     rhp_ip_valid;       /**< Routing Extension Header Present; last bit is IP valid */
+    volatile uint8_t     shim_off[2];        /**< Shim offset */
+    volatile uint8_t     ip_pid_off;         /**< IP PID (last IP-proto) offset */
+    volatile uint8_t     eth_off;            /**< ETH offset */
+    volatile uint8_t     llc_snap_off;       /**< LLC_SNAP offset */
+    volatile uint8_t     vlan_off[2];        /**< VLAN offset */
+    volatile uint8_t     etype_off;          /**< ETYPE offset */
+    volatile uint8_t     pppoe_off;          /**< PPP offset */
+    volatile uint8_t     mpls_off[2];        /**< MPLS offset */
+    volatile uint8_t     ip_off[2];          /**< IP offset */
+    volatile uint8_t     gre_off;            /**< GRE offset */
+    volatile uint8_t     l4_off;             /**< Layer 4 offset */
+    volatile uint8_t     nxthdr_off;         /**< Parser end point */
+} _PackedType t_FmPrsResult;
+
+/**************************************************************************//**
+ @Collection   FM Parser results
+*//***************************************************************************/
+#define FM_PR_L2_VLAN_STACK         0x00000100  /**< Parse Result: VLAN stack */
+#define FM_PR_L2_ETHERNET           0x00008000  /**< Parse Result: Ethernet*/
+#define FM_PR_L2_VLAN               0x00004000  /**< Parse Result: VLAN */
+#define FM_PR_L2_LLC_SNAP           0x00002000  /**< Parse Result: LLC_SNAP */
+#define FM_PR_L2_MPLS               0x00001000  /**< Parse Result: MPLS */
+#define FM_PR_L2_PPPoE              0x00000800  /**< Parse Result: PPPoE */
+/* @} */
+
+/**************************************************************************//**
+ @Collection   FM Frame descriptor macros
+*//***************************************************************************/
+#define FM_FD_CMD_FCO                   0x80000000  /**< Frame queue Context Override */
+#define FM_FD_CMD_RPD                   0x40000000  /**< Read Prepended Data */
+#define FM_FD_CMD_UPD                   0x20000000  /**< Update Prepended Data */
+#define FM_FD_CMD_DTC                   0x10000000  /**< Do L4 Checksum */
+#define FM_FD_CMD_DCL4C                 0x10000000  /**< Didn't calculate L4 Checksum */
+#define FM_FD_CMD_CFQ                   0x00ffffff  /**< Confirmation Frame Queue */
+
+#define FM_FD_ERR_UNSUPPORTED_FORMAT    0x04000000  /**< Not for Rx-Port! Unsupported Format */
+#define FM_FD_ERR_LENGTH                0x02000000  /**< Not for Rx-Port! Length Error */
+#define FM_FD_ERR_DMA                   0x01000000  /**< DMA Data error */
+
+#define FM_FD_IPR                       0x00000001  /**< IPR frame (not error) */
+
+#define FM_FD_ERR_IPR_NCSP              (0x00100000 | FM_FD_IPR)    /**< IPR non-consistent-sp */
+#define FM_FD_ERR_IPR                   (0x00200000 | FM_FD_IPR)    /**< IPR error */
+#define FM_FD_ERR_IPR_TO                (0x00300000 | FM_FD_IPR)    /**< IPR timeout */
+
+#ifdef FM_CAPWAP_SUPPORT
+#define FM_FD_ERR_CRE                   0x00200000
+#define FM_FD_ERR_CHE                   0x00100000
+#endif /* FM_CAPWAP_SUPPORT */
+
+#define FM_FD_ERR_PHYSICAL              0x00080000  /**< Rx FIFO overflow, FCS error, code error, running disparity
+                                                         error (SGMII and TBI modes), FIFO parity error. PHY
+                                                         Sequence error, PHY error control character detected. */
+#define FM_FD_ERR_SIZE                  0x00040000  /**< Frame too long OR Frame size exceeds max_length_frame  */
+#define FM_FD_ERR_CLS_DISCARD           0x00020000  /**< classification discard */
+#define FM_FD_ERR_EXTRACTION            0x00008000  /**< Extract Out of Frame */
+#define FM_FD_ERR_NO_SCHEME             0x00004000  /**< No Scheme Selected */
+#define FM_FD_ERR_KEYSIZE_OVERFLOW      0x00002000  /**< Keysize Overflow */
+#define FM_FD_ERR_COLOR_RED             0x00000800  /**< Frame color is red */
+#define FM_FD_ERR_COLOR_YELLOW          0x00000400  /**< Frame color is yellow */
+#define FM_FD_ERR_ILL_PLCR              0x00000200  /**< Illegal Policer Profile selected */
+#define FM_FD_ERR_PLCR_FRAME_LEN        0x00000100  /**< Policer frame length error */
+#define FM_FD_ERR_PRS_TIMEOUT           0x00000080  /**< Parser Time out Exceed */
+#define FM_FD_ERR_PRS_ILL_INSTRUCT      0x00000040  /**< Invalid Soft Parser instruction */
+#define FM_FD_ERR_PRS_HDR_ERR           0x00000020  /**< Header error was identified during parsing */
+#define FM_FD_ERR_BLOCK_LIMIT_EXCEEDED  0x00000008  /**< Frame parsed beyind 256 first bytes */
+
+#define FM_FD_TX_STATUS_ERR_MASK        (FM_FD_ERR_UNSUPPORTED_FORMAT   | \
+                                         FM_FD_ERR_LENGTH               | \
+                                         FM_FD_ERR_DMA) /**< TX Error FD bits */
+
+#define FM_FD_RX_STATUS_ERR_MASK        (FM_FD_ERR_UNSUPPORTED_FORMAT   | \
+                                         FM_FD_ERR_LENGTH               | \
+                                         FM_FD_ERR_DMA                  | \
+                                         FM_FD_ERR_IPR                  | \
+                                         FM_FD_ERR_IPR_TO               | \
+                                         FM_FD_ERR_IPR_NCSP             | \
+                                         FM_FD_ERR_PHYSICAL             | \
+                                         FM_FD_ERR_SIZE                 | \
+                                         FM_FD_ERR_CLS_DISCARD          | \
+                                         FM_FD_ERR_COLOR_RED            | \
+                                         FM_FD_ERR_COLOR_YELLOW         | \
+                                         FM_FD_ERR_ILL_PLCR             | \
+                                         FM_FD_ERR_PLCR_FRAME_LEN       | \
+                                         FM_FD_ERR_EXTRACTION           | \
+                                         FM_FD_ERR_NO_SCHEME            | \
+                                         FM_FD_ERR_KEYSIZE_OVERFLOW     | \
+                                         FM_FD_ERR_PRS_TIMEOUT          | \
+                                         FM_FD_ERR_PRS_ILL_INSTRUCT     | \
+                                         FM_FD_ERR_PRS_HDR_ERR          | \
+                                         FM_FD_ERR_BLOCK_LIMIT_EXCEEDED) /**< RX Error FD bits */
+
+#define FM_FD_RX_STATUS_ERR_NON_FM      0x00400000  /**< non Frame-Manager error */
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   FM Exceptions
+*//***************************************************************************/
+typedef enum e_FmExceptions {
+    e_FM_EX_DMA_BUS_ERROR = 0,          /**< DMA bus error. */
+    e_FM_EX_DMA_READ_ECC,               /**< Read Buffer ECC error (Valid for FM rev < 6)*/
+    e_FM_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side (Valid for FM rev < 6)*/
+    e_FM_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side (Valid for FM rev < 6)*/
+    e_FM_EX_DMA_SINGLE_PORT_ECC,        /**< Single Port ECC error on FM side (Valid for FM rev > 6)*/
+    e_FM_EX_FPM_STALL_ON_TASKS,         /**< Stall of tasks on FPM */
+    e_FM_EX_FPM_SINGLE_ECC,             /**< Single ECC on FPM. */
+    e_FM_EX_FPM_DOUBLE_ECC,             /**< Double ECC error on FPM ram access */
+    e_FM_EX_QMI_SINGLE_ECC,             /**< Single ECC on QMI. */
+    e_FM_EX_QMI_DOUBLE_ECC,             /**< Double bit ECC occurred on QMI */
+    e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,/**< Dequeue from unknown port id */
+    e_FM_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
+    e_FM_EX_BMI_STORAGE_PROFILE_ECC,    /**< Storage Profile ECC Error */
+    e_FM_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
+    e_FM_EX_BMI_DISPATCH_RAM_ECC,       /**< Dispatch RAM ECC Error Enable */
+    e_FM_EX_IRAM_ECC,                   /**< Double bit ECC occurred on IRAM*/
+    e_FM_EX_MURAM_ECC                   /**< Double bit ECC occurred on MURAM*/
+} e_FmExceptions;
+
+/**************************************************************************//**
+ @Description   Enum for defining port DMA swap mode
+*//***************************************************************************/
+typedef enum e_FmDmaSwapOption {
+    e_FM_DMA_NO_SWP,           /**< No swap, transfer data as is.*/
+    e_FM_DMA_SWP_PPC_LE,       /**< The transferred data should be swapped
+                                    in PowerPc Little Endian mode. */
+    e_FM_DMA_SWP_BE            /**< The transferred data should be swapped
+                                    in Big Endian mode */
+} e_FmDmaSwapOption;
+
+/**************************************************************************//**
+ @Description   Enum for defining port DMA cache attributes
+*//***************************************************************************/
+typedef enum e_FmDmaCacheOption {
+    e_FM_DMA_NO_STASH = 0,     /**< Cacheable, no Allocate (No Stashing) */
+    e_FM_DMA_STASH = 1         /**< Cacheable and Allocate (Stashing on) */
+} e_FmDmaCacheOption;
+/**************************************************************************//**
+ @Group         lnx_usr_FM_init_grp FM Initialization Unit
+
+ @Description   FM Initialization Unit
+
+                Initialization Flow
+                Initialization of the FM Module will be carried out by the application
+                according to the following sequence:
+                -  Calling the configuration routine with basic parameters.
+                -  Calling the advance initialization routines to change driver's defaults.
+                -  Calling the initialization routine.
+
+ @{
+*//***************************************************************************/
+
+t_Handle FM_Open(uint8_t id);
+void     FM_Close(t_Handle h_Fm);
+
+
+/**************************************************************************//**
+ @Description   A structure for defining buffer prefix area content.
+*//***************************************************************************/
+typedef struct t_FmBufferPrefixContent {
+    uint16_t    privDataSize;       /**< Number of bytes to be left at the beginning
+                                         of the external buffer; Note that the private-area will
+                                         start from the base of the buffer address. */
+    bool        passPrsResult;      /**< TRUE to pass the parse result to/from the FM;
+                                         User may use FM_PORT_GetBufferPrsResult() in order to
+                                         get the parser-result from a buffer. */
+    bool        passTimeStamp;      /**< TRUE to pass the timeStamp to/from the FM
+                                         User may use FM_PORT_GetBufferTimeStamp() in order to
+                                         get the parser-result from a buffer. */
+    bool        passHashResult;     /**< TRUE to pass the KG hash result to/from the FM
+                                         User may use FM_PORT_GetBufferHashResult() in order to
+                                         get the parser-result from a buffer. */
+    bool        passAllOtherPCDInfo;/**< Add all other Internal-Context information:
+                                         AD, hash-result, key, etc. */
+    uint16_t    dataAlign;          /**< 0 to use driver's default alignment [64],
+                                         other value for selecting a data alignment (must be a power of 2);
+                                         if write optimization is used, must be >= 16. */
+    uint8_t     manipExtraSpace;    /**< Maximum extra size needed (insertion-size minus removal-size);
+                                         Note that this field impacts the size of the buffer-prefix
+                                         (i.e. it pushes the data offset);
+                                         This field is irrelevant if DPAA_VERSION==10 */
+} t_FmBufferPrefixContent;
+
+/**************************************************************************//**
+ @Description   A structure of information about each of the external
+                buffer pools used by a port or storage-profile.
+*//***************************************************************************/
+typedef struct t_FmExtPoolParams {
+    uint8_t                 id;     /**< External buffer pool id */
+    uint16_t                size;   /**< External buffer pool buffer size */
+} t_FmExtPoolParams;
+
+/**************************************************************************//**
+ @Description   A structure for informing the driver about the external
+                buffer pools allocated in the BM and used by a port or a
+                storage-profile.
+*//***************************************************************************/
+typedef struct t_FmExtPools {
+    uint8_t                 numOfPoolsUsed;     /**< Number of pools use by this port */
+    t_FmExtPoolParams       extBufPool[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                                /**< Parameters for each port */
+} t_FmExtPools;
+
+/**************************************************************************//**
+ @Description   A structure for defining backup BM Pools.
+*//***************************************************************************/
+typedef struct t_FmBackupBmPools {
+    uint8_t     numOfBackupPools;       /**< Number of BM backup pools -
+                                             must be smaller than the total number of
+                                             pools defined for the specified port.*/
+    uint8_t     poolIds[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                        /**< numOfBackupPools pool id's, specifying which
+                                             pools should be used only as backup. Pool
+                                             id's specified here must be a subset of the
+                                             pools used by the specified port.*/
+} t_FmBackupBmPools;
+
+/**************************************************************************//**
+ @Description   A structure for defining BM pool depletion criteria
+*//***************************************************************************/
+typedef struct t_FmBufPoolDepletion {
+    bool        poolsGrpModeEnable;                 /**< select mode in which pause frames will be sent after
+                                                         a number of pools (all together!) are depleted */
+    uint8_t     numOfPools;                         /**< the number of depleted pools that will invoke
+                                                         pause frames transmission. */
+    bool        poolsToConsider[BM_MAX_NUM_OF_POOLS];
+                                                    /**< For each pool, TRUE if it should be considered for
+                                                         depletion (Note - this pool must be used by this port!). */
+    bool        singlePoolModeEnable;               /**< select mode in which pause frames will be sent after
+                                                         a single-pool is depleted; */
+    bool        poolsToConsiderForSingleMode[BM_MAX_NUM_OF_POOLS];
+                                                    /**< For each pool, TRUE if it should be considered for
+                                                         depletion (Note - this pool must be used by this port!) */
+#if (DPAA_VERSION >= 11)
+    bool        pfcPrioritiesEn[FM_MAX_NUM_OF_PFC_PRIORITIES];
+                                                    /**< This field is used by the MAC as the Priority Enable Vector in the PFC frame which is transmitted */
+#endif /* (DPAA_VERSION >= 11) */
+} t_FmBufPoolDepletion;
+
+
+/** @} */ /* end of lnx_usr_FM_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         lnx_usr_FM_runtime_control_grp FM Runtime Control Unit
+
+ @Description   FM Runtime control unit API functions, definitions and enums.
+                The FM driver provides a set of control routines.
+                These routines may only be called after the module was fully
+                initialized (both configuration and initialization routines were
+                called). They are typically used to get information from hardware
+                (status, counters/statistics, revision etc.), to modify a current
+                state or to force/enable a required action. Run-time control may
+                be called whenever necessary and as many times as needed.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection   General FM defines.
+*//***************************************************************************/
+#define FM_MAX_NUM_OF_VALID_PORTS   (FM_MAX_NUM_OF_OH_PORTS +       \
+                                     FM_MAX_NUM_OF_1G_RX_PORTS +    \
+                                     FM_MAX_NUM_OF_10G_RX_PORTS +   \
+                                     FM_MAX_NUM_OF_1G_TX_PORTS +    \
+                                     FM_MAX_NUM_OF_10G_TX_PORTS)      /**< Number of available FM ports */
+/* @} */
+
+/**************************************************************************//**
+ @Description   A structure for Port bandwidth requirement. Port is identified
+                by type and relative id.
+*//***************************************************************************/
+typedef struct t_FmPortBandwidth {
+    e_FmPortType        type;           /**< FM port type */
+    uint8_t             relativePortId; /**< Type relative port id */
+    uint8_t             bandwidth;      /**< bandwidth - (in term of percents) */
+} t_FmPortBandwidth;
+
+/**************************************************************************//**
+ @Description   A Structure containing an array of Port bandwidth requirements.
+                The user should state the ports requiring bandwidth in terms of
+                percentage - i.e. all port's bandwidths in the array must add
+                up to 100.
+*//***************************************************************************/
+typedef struct t_FmPortsBandwidthParams {
+    uint8_t             numOfPorts;         /**< The number of relevant ports, which is the
+                                                 number of valid entries in the array below */
+    t_FmPortBandwidth   portsBandwidths[FM_MAX_NUM_OF_VALID_PORTS];
+                                            /**< for each port, it's bandwidth (all port's
+                                                 bandwidths must add up to 100.*/
+} t_FmPortsBandwidthParams;
+
+/**************************************************************************//**
+ @Description   Enum for defining FM counters
+*//***************************************************************************/
+typedef enum e_FmCounters {
+    e_FM_COUNTERS_ENQ_TOTAL_FRAME = 0,              /**< QMI total enqueued frames counter */
+    e_FM_COUNTERS_DEQ_TOTAL_FRAME,                  /**< QMI total dequeued frames counter */
+    e_FM_COUNTERS_DEQ_0,                            /**< QMI 0 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_1,                            /**< QMI 1 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_2,                            /**< QMI 2 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_3,                            /**< QMI 3 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_FROM_DEFAULT,                 /**< QMI dequeue from default queue counter */
+    e_FM_COUNTERS_DEQ_FROM_CONTEXT,                 /**< QMI dequeue from FQ context counter */
+    e_FM_COUNTERS_DEQ_FROM_FD,                      /**< QMI dequeue from FD command field counter */
+    e_FM_COUNTERS_DEQ_CONFIRM                       /**< QMI dequeue confirm counter */
+} e_FmCounters;
+
+/**************************************************************************//**
+ @Description   A structure for returning FM revision information
+*//***************************************************************************/
+typedef struct t_FmRevisionInfo {
+    uint8_t         majorRev;               /**< Major revision */
+    uint8_t         minorRev;               /**< Minor revision */
+} t_FmRevisionInfo;
+
+/**************************************************************************//**
+ @Description   A structure for returning FM ctrl code revision information
+*//***************************************************************************/
+typedef struct t_FmCtrlCodeRevisionInfo {
+    uint16_t        packageRev;             /**< Package revision */
+    uint8_t         majorRev;               /**< Major revision */
+    uint8_t         minorRev;               /**< Minor revision */
+} t_FmCtrlCodeRevisionInfo;
+
+/**************************************************************************//**
+ @Description   A Structure for obtaining FM controller monitor values
+*//***************************************************************************/
+typedef struct t_FmCtrlMon {
+    uint8_t percentCnt[1];          /**< Percentage value */
+} t_FmCtrlMon;
+
+/**************************************************************************//**
+ @Function      FM_SetPortsBandwidth
+
+ @Description   Sets relative weights between ports when accessing common resources.
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_PortsBandwidth    A structure of ports bandwidths in percentage, i.e.
+                                    total must equal 100.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBandwidth);
+
+/**************************************************************************//**
+ @Function      FM_GetRevision
+
+ @Description   Returns the FM revision
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[out]    p_FmRevisionInfo    A structure of revision information parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error  FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo);
+
+/**************************************************************************//**
+ @Function      FM_GetFmanCtrlCodeRevision
+
+ @Description   Returns the Fman controller code revision
+		(Not implemented in fm-lib just yet!)
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[out]    p_RevisionInfo      A structure of revision information parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FM_GetFmanCtrlCodeRevision(t_Handle h_Fm, t_FmCtrlCodeRevisionInfo *p_RevisionInfo);
+
+/**************************************************************************//**
+ @Function      FM_GetCounter
+
+ @Description   Reads one of the FM counters.
+
+ @Param[in]     h_Fm        A handle to an FM Module.
+ @Param[in]     counter     The requested counter.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_Init().
+                Note that it is user's responsibility to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter);
+
+/**************************************************************************//**
+ @Function      FM_ModifyCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     h_Fm        A handle to an FM Module.
+ @Param[in]     counter     The requested counter.
+ @Param[in]     val         The requested value to be written into the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val);
+
+/**************************************************************************//**
+ @Function      FM_CtrlMonStart
+
+ @Description   Start monitoring utilization of all available FM controllers.
+
+                In order to obtain FM controllers utilization the following sequence
+                should be used:
+                -# FM_CtrlMonStart()
+                -# FM_CtrlMonStop()
+                -# FM_CtrlMonGetCounters() - issued for each FM controller
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID).
+*//***************************************************************************/
+t_Error FM_CtrlMonStart(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_CtrlMonStop
+
+ @Description   Stop monitoring utilization of all available FM controllers.
+
+                In order to obtain FM controllers utilization the following sequence
+                should be used:
+                -# FM_CtrlMonStart()
+                -# FM_CtrlMonStop()
+                -# FM_CtrlMonGetCounters() - issued for each FM controller
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID).
+*//***************************************************************************/
+t_Error FM_CtrlMonStop(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_CtrlMonGetCounters
+
+ @Description   Obtain FM controller utilization parameters.
+
+                In order to obtain FM controllers utilization the following sequence
+                should be used:
+                -# FM_CtrlMonStart()
+                -# FM_CtrlMonStop()
+                -# FM_CtrlMonGetCounters() - issued for each FM controller
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     fmCtrlIndex     FM Controller index for that utilization results
+                                are requested.
+ @Param[in]     p_Mon           Pointer to utilization results structure.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID).
+*//***************************************************************************/
+t_Error FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p_Mon);
+
+
+/**************************************************************************//*
+ @Function      FM_ForceIntr
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     exception       An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception);
+
+/** @} */ /* end of lnx_usr_FM_runtime_control_grp group */
+/** @} */ /* end of lnx_usr_FM_lib_grp group */
+/** @} */ /* end of lnx_usr_FM_grp group */
+
+#ifdef NCSW_BACKWARD_COMPATIBLE_API
+typedef t_FmBackupBmPools           t_FmPortBackupBmPools;
+typedef t_FmBufPoolDepletion        t_FmPortBufPoolDepletion;
+#define e_FM_EX_BMI_PIPELINE_ECC    e_FM_EX_BMI_STORAGE_PROFILE_ECC
+#endif /* NCSW_BACKWARD_COMPATIBLE_API */
+
+#endif /* __FM_EXT */
--- fmlib-fslsdk-v1.7/include/fmd/Peripherals/fm_mac_ext.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/Peripherals/fm_mac_ext.h	2022-05-26 11:28:31.078973494 -0700
@@ -0,0 +1,819 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/**************************************************************************//**
+ @File          fm_mac_ext.h
+
+ @Description   FM MAC ...
+*//***************************************************************************/
+#ifndef __FM_MAC_EXT_H
+#define __FM_MAC_EXT_H
+
+#include "std_ext.h"
+#include "enet_ext.h"
+
+
+/**************************************************************************//**
+
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_mac_grp FM MAC
+
+ @Description   FM MAC API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+#define FM_MAC_NO_PFC   0xff
+
+
+/**************************************************************************//**
+ @Description   FM MAC Exceptions
+*//***************************************************************************/
+typedef enum e_FmMacExceptions {
+    e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO = 0                     /**< 10GEC MDIO scan event interrupt */
+   ,e_FM_MAC_EX_10G_MDIO_CMD_CMPL                               /**< 10GEC MDIO command completion interrupt */
+   ,e_FM_MAC_EX_10G_REM_FAULT                                   /**< 10GEC, mEMAC Remote fault interrupt */
+   ,e_FM_MAC_EX_10G_LOC_FAULT                                   /**< 10GEC, mEMAC Local fault interrupt */
+   ,e_FM_MAC_EX_10G_1TX_ECC_ER                                  /**< 10GEC, mEMAC Transmit frame ECC error interrupt */
+   ,e_FM_MAC_EX_10G_TX_FIFO_UNFL                                /**< 10GEC, mEMAC Transmit FIFO underflow interrupt */
+   ,e_FM_MAC_EX_10G_TX_FIFO_OVFL                                /**< 10GEC, mEMAC Transmit FIFO overflow interrupt */
+   ,e_FM_MAC_EX_10G_TX_ER                                       /**< 10GEC Transmit frame error interrupt */
+   ,e_FM_MAC_EX_10G_RX_FIFO_OVFL                                /**< 10GEC, mEMAC Receive FIFO overflow interrupt */
+   ,e_FM_MAC_EX_10G_RX_ECC_ER                                   /**< 10GEC, mEMAC Receive frame ECC error interrupt */
+   ,e_FM_MAC_EX_10G_RX_JAB_FRM                                  /**< 10GEC Receive jabber frame interrupt */
+   ,e_FM_MAC_EX_10G_RX_OVRSZ_FRM                                /**< 10GEC Receive oversized frame interrupt */
+   ,e_FM_MAC_EX_10G_RX_RUNT_FRM                                 /**< 10GEC Receive runt frame interrupt */
+   ,e_FM_MAC_EX_10G_RX_FRAG_FRM                                 /**< 10GEC Receive fragment frame interrupt */
+   ,e_FM_MAC_EX_10G_RX_LEN_ER                                   /**< 10GEC Receive payload length error interrupt */
+   ,e_FM_MAC_EX_10G_RX_CRC_ER                                   /**< 10GEC Receive CRC error interrupt */
+   ,e_FM_MAC_EX_10G_RX_ALIGN_ER                                 /**< 10GEC Receive alignment error interrupt */
+   ,e_FM_MAC_EX_1G_BAB_RX                                       /**< dTSEC Babbling receive error */
+   ,e_FM_MAC_EX_1G_RX_CTL                                       /**< dTSEC Receive control (pause frame) interrupt */
+   ,e_FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET                      /**< dTSEC Graceful transmit stop complete */
+   ,e_FM_MAC_EX_1G_BAB_TX                                       /**< dTSEC Babbling transmit error */
+   ,e_FM_MAC_EX_1G_TX_CTL                                       /**< dTSEC Transmit control (pause frame) interrupt */
+   ,e_FM_MAC_EX_1G_TX_ERR                                       /**< dTSEC Transmit error */
+   ,e_FM_MAC_EX_1G_LATE_COL                                     /**< dTSEC Late collision */
+   ,e_FM_MAC_EX_1G_COL_RET_LMT                                  /**< dTSEC Collision retry limit */
+   ,e_FM_MAC_EX_1G_TX_FIFO_UNDRN                                /**< dTSEC Transmit FIFO underrun */
+   ,e_FM_MAC_EX_1G_MAG_PCKT                                     /**< dTSEC Magic Packet detection */
+   ,e_FM_MAC_EX_1G_MII_MNG_RD_COMPLET                           /**< dTSEC MII management read completion */
+   ,e_FM_MAC_EX_1G_MII_MNG_WR_COMPLET                           /**< dTSEC MII management write completion */
+   ,e_FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET                      /**< dTSEC Graceful receive stop complete */
+   ,e_FM_MAC_EX_1G_TX_DATA_ERR                                  /**< dTSEC Internal data error on transmit */
+   ,e_FM_MAC_EX_1G_RX_DATA_ERR                                  /**< dTSEC Internal data error on receive */
+   ,e_FM_MAC_EX_1G_1588_TS_RX_ERR                               /**< dTSEC Time-Stamp Receive Error */
+   ,e_FM_MAC_EX_1G_RX_MIB_CNT_OVFL                              /**< dTSEC MIB counter overflow */
+} e_FmMacExceptions;
+
+/**************************************************************************//**
+ @Description   TM MAC statistics level
+*//***************************************************************************/
+typedef enum e_FmMacStatisticsLevel {
+    e_FM_MAC_NONE_STATISTICS = 0,       /**< No statistics */
+    e_FM_MAC_PARTIAL_STATISTICS,        /**< Only error counters are available; Optimized for performance */
+    e_FM_MAC_FULL_STATISTICS            /**< All counters available; Not optimized for performance */
+} e_FmMacStatisticsLevel;
+
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Priority Flow Control Parameters
+*//***************************************************************************/
+typedef struct t_FmMacPfcParams {
+    bool        pfcEnable;                                      /**< Enable/Disable PFC */
+
+    uint16_t    pauseQuanta[FM_MAX_NUM_OF_PFC_PRIORITIES];      /**< Pause Quanta per priority to be sent in a pause frame. Each quanta represents a 512 bit-times*/
+
+    uint16_t    pauseThresholdQuanta[FM_MAX_NUM_OF_PFC_PRIORITIES];/**< Pause threshold per priority, when timer passes this threshold time a PFC frames is sent again if the port is still congested or BM pool in depletion*/
+
+
+} t_FmMacPfcParams;
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Function      t_FmMacExceptionCallback
+
+ @Description   Fm Mac Exception Callback from FM MAC to the user
+
+ @Param[in]     h_App             - Handle to the upper layer handler
+
+ @Param[in]     exceptions        - The exception that occurred
+
+ @Return        void.
+*//***************************************************************************/
+typedef void (t_FmMacExceptionCallback)(t_Handle h_App, e_FmMacExceptions exceptions);
+
+
+/**************************************************************************//**
+ @Description   TM MAC statistics rfc3635
+*//***************************************************************************/
+typedef struct t_FmMacStatistics {
+/* RMON */
+    uint64_t  eStatPkts64;             /**< r-10G tr-DT 64 byte frame counter */
+    uint64_t  eStatPkts65to127;        /**< r-10G 65 to 127 byte frame counter */
+    uint64_t  eStatPkts128to255;       /**< r-10G 128 to 255 byte frame counter */
+    uint64_t  eStatPkts256to511;       /**< r-10G 256 to 511 byte frame counter */
+    uint64_t  eStatPkts512to1023;      /**< r-10G 512 to 1023 byte frame counter */
+    uint64_t  eStatPkts1024to1518;     /**< r-10G 1024 to 1518 byte frame counter */
+    uint64_t  eStatPkts1519to1522;     /**< r-10G 1519 to 1522 byte good frame count */
+/* */
+    uint64_t  eStatFragments;          /**< Total number of packets that were less than 64 octets long with a wrong CRC.*/
+    uint64_t  eStatJabbers;            /**< Total number of packets longer than valid maximum length octets */
+    uint64_t  eStatsDropEvents;        /**< number of dropped packets due to internal errors of the MAC Client (during recieve). */
+    uint64_t  eStatCRCAlignErrors;     /**< Incremented when frames of correct length but with CRC error are received.*/
+    uint64_t  eStatUndersizePkts;      /**< Incremented for frames under 64 bytes with a valid FCS and otherwise well formed;
+                                            This count does not include range length errors */
+    uint64_t  eStatOversizePkts;       /**< Incremented for frames which exceed 1518 (non VLAN) or 1522 (VLAN) and contains
+                                            a valid FCS and otherwise well formed */
+/* Pause */
+    uint64_t  teStatPause;             /**< Pause MAC Control received */
+    uint64_t  reStatPause;             /**< Pause MAC Control sent */
+/* MIB II */
+    uint64_t  ifInOctets;              /**< Total number of byte received. */
+    uint64_t  ifInPkts;                /**< Total number of packets received.*/
+    uint64_t  ifInUcastPkts;           /**< Total number of unicast frame received;
+                                            NOTE: this counter is not supported on dTSEC MAC */
+    uint64_t  ifInMcastPkts;           /**< Total number of multicast frame received*/
+    uint64_t  ifInBcastPkts;           /**< Total number of broadcast frame received */
+    uint64_t  ifInDiscards;            /**< Frames received, but discarded due to problems within the MAC RX. */
+    uint64_t  ifInErrors;              /**< Number of frames received with error:
+                                               - FIFO Overflow Error
+                                               - CRC Error
+                                               - Frame Too Long Error
+                                               - Alignment Error
+                                               - The dedicated Error Code (0xfe, not a code error) was received */
+    uint64_t  ifOutOctets;             /**< Total number of byte sent. */
+    uint64_t  ifOutPkts;               /**< Total number of packets sent .*/
+    uint64_t  ifOutUcastPkts;          /**< Total number of unicast frame sent;
+                                            NOTE: this counter is not supported on dTSEC MAC */
+    uint64_t  ifOutMcastPkts;          /**< Total number of multicast frame sent */
+    uint64_t  ifOutBcastPkts;          /**< Total number of multicast frame sent */
+    uint64_t  ifOutDiscards;           /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
+    uint64_t  ifOutErrors;             /**< Number of frames transmitted with error:
+                                               - FIFO Overflow Error
+                                               - FIFO Underflow Error
+                                               - Other */
+} t_FmMacStatistics;
+
+
+/**************************************************************************//**
+ @Group         FM_mac_init_grp FM MAC Initialization Unit
+
+ @Description   FM MAC Initialization Unit
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM MAC config input
+*//***************************************************************************/
+typedef struct t_FmMacParams {
+    uintptr_t                   baseAddr;           /**< Base of memory mapped FM MAC registers */
+    t_EnetAddr                  addr;               /**< MAC address of device; First octet is sent first */
+    uint8_t                     macId;              /**< MAC ID <dTSEC 0-3> <10G-MAC 0>      */
+    e_EnetMode                  enetMode;           /**< Ethernet operation mode (MAC-PHY interface and speed);
+                                                         Note that the speed should indicate the maximum rate that
+                                                         this MAC should support rather than the actuall speed;
+                                                         i.e. user should use the FM_MAC_AdjustLink() routine to
+                                                         provide accurate speed;
+                                                         In addition, in mEMAC, in case where user is using the higher MACs
+                                                         (i.e. the MACs that should support 10G), user should pass here
+                                                         speed=10000 even if the interface is not allowing that (e.g. SGMII). */
+    t_Handle                    h_Fm;               /**< A handle to the FM object this port related to */
+    int                         mdioIrq;            /**< MDIO exceptions interrupt source - not valid for all
+                                                         MACs; MUST be set to 'NO_IRQ' for MACs that don't have
+                                                         mdio-irq, or for polling */
+    t_FmMacExceptionCallback    *f_Event;           /**< MDIO Events Callback Routine         */
+    t_FmMacExceptionCallback    *f_Exception;       /**< Exception Callback Routine         */
+    t_Handle                    h_App;              /**< A handle to an application layer object; This handle will
+                                                         be passed by the driver upon calling the above callbacks */
+} t_FmMacParams;
+
+
+/**************************************************************************//**
+ @Function      FM_MAC_Config
+
+ @Description   Creates descriptor for the FM MAC module.
+
+                The routine returns a handle (descriptor) to the FM MAC object.
+                This descriptor must be passed as first parameter to all other
+                FM MAC function calls.
+
+                No actual initialization or configuration of FM MAC hardware is
+                done by this routine.
+
+ @Param[in]     p_FmMacParam   - Pointer to data structure of parameters
+
+ @Retval        Handle to FM MAC object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_MAC_Config(t_FmMacParams *p_FmMacParam);
+
+/**************************************************************************//**
+ @Function      FM_MAC_Init
+
+ @Description   Initializes the FM MAC module
+
+ @Param[in]     h_FmMac - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error  FM_MAC_Init(t_Handle h_FmMac);
+
+/**************************************************************************//**
+ @Function      FM_Free
+
+ @Description   Frees all resources that were assigned to FM MAC module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmMac - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error  FM_MAC_Free(t_Handle h_FmMac);
+
+
+/**************************************************************************//**
+ @Group         FM_mac_advanced_init_grp    FM MAC Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigResetOnInit
+
+ @Description   Tell the driver whether to reset the FM MAC before initialization or
+                not. It changes the default configuration [FALSE].
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     When TRUE, FM will be reset before any initialization.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigResetOnInit(t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigLoopback
+
+ @Description   Enable/Disable internal loopback mode
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigLoopback(t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigMaxFrameLength
+
+ @Description   Setup maximum Rx Frame Length (in 1G MAC, effects also Tx)
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     newVal     MAX Frame length
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigMaxFrameLength(t_Handle h_FmMac, uint16_t newVal);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigWan
+
+ @Description   ENABLE WAN mode in 10G-MAC
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigWan(t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigPadAndCrc
+
+ @Description   Config PAD and CRC mode
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+                Not supported on 10G-MAC (i.e. CRC & PAD are added automatically
+                by HW); on mEMAC, this routine supports only PAD (i.e. CRC is
+                added automatically by HW).
+*//***************************************************************************/
+t_Error FM_MAC_ConfigPadAndCrc(t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigHalfDuplex
+
+ @Description   Config Half Duplex Mode
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigHalfDuplex(t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigTbiPhyAddr
+
+ @Description   Configures the address of internal TBI PHY.
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     newVal     TBI PHY address (1-31).
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigTbiPhyAddr(t_Handle h_FmMac, uint8_t newVal);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigLengthCheck
+
+ @Description   Configure the frame length checking.
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigLengthCheck(t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigException
+
+ @Description   Change Exception selection from default
+
+ @Param[in]     h_FmMac         A handle to a FM MAC Module.
+ @Param[in]     ex              Type of the desired exceptions
+ @Param[in]     enable          TRUE to enable the specified exception, FALSE to disable it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigException(t_Handle h_FmMac, e_FmMacExceptions ex, bool enable);
+
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+t_Error FM_MAC_ConfigSkipFman11Workaround (t_Handle h_FmMac);
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+/** @} */ /* end of FM_mac_advanced_init_grp group */
+/** @} */ /* end of FM_mac_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_mac_runtime_control_grp FM MAC Runtime Control Unit
+
+ @Description   FM MAC Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MAC_Enable
+
+ @Description   Enable the MAC
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     mode       Mode of operation (RX, TX, Both)
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_Enable(t_Handle h_FmMac,  e_CommMode mode);
+
+/**************************************************************************//**
+ @Function      FM_MAC_Disable
+
+ @Description   DISABLE the MAC
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     mode       Define what part to Disable (RX,  TX or BOTH)
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_Disable(t_Handle h_FmMac, e_CommMode mode);
+
+/**************************************************************************//**
+ @Function      FM_MAC_Enable1588TimeStamp
+
+ @Description   Enables the TSU operation.
+
+ @Param[in]     h_Fm   - Handle to the PTP as returned from the FM_MAC_PtpConfig.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_Enable1588TimeStamp(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_MAC_Disable1588TimeStamp
+
+ @Description   Disables the TSU operation.
+
+ @Param[in]     h_Fm   - Handle to the PTP as returned from the FM_MAC_PtpConfig.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_Disable1588TimeStamp(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_MAC_SetTxAutoPauseFrames
+
+ @Description   Enable/Disable transmission of Pause-Frames.
+                The routine changes the default configuration [0xf000].
+
+ @Param[in]     h_FmMac       -  A handle to a FM MAC Module.
+ @Param[in]     pauseTime     -  Pause quanta value used with transmitted pause frames.
+                                 Each quanta represents a 512 bit-times; Note that '0'
+                                 as an input here will be used as disabling the
+                                 transmission of the pause-frames.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_SetTxAutoPauseFrames(t_Handle h_FmMac,
+                                    uint16_t pauseTime);
+
+ /**************************************************************************//**
+ @Function      FM_MAC_SetTxPauseFrames
+
+ @Description   Enable/Disable transmission of Pause-Frames.
+                The routine changes the default configuration:
+                pause-time - [0xf000]
+                threshold-time - [0]
+
+ @Param[in]     h_FmMac       -  A handle to a FM MAC Module.
+ @Param[in]     priority      -  the PFC class of service; use 'FM_MAC_NO_PFC'
+                                 to indicate legacy pause support (i.e. no PFC).
+ @Param[in]     pauseTime     -  Pause quanta value used with transmitted pause frames.
+                                 Each quanta represents a 512 bit-times;
+                                 Note that '0' as an input here will be used as disabling the
+                                 transmission of the pause-frames.
+ @Param[in]     threshTime    -  Pause Threshold equanta value used by the MAC to retransmit pause frame.
+                                 if the situation causing a pause frame to be sent didn't finish when the timer
+                                 reached the threshold quanta, the MAC will retransmit the pause frame.
+                                 Each quanta represents a 512 bit-times.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+                PFC is supported only on new mEMAC; i.e. in MACs that don't have
+                PFC support (10G-MAC and dTSEC), user should use 'FM_MAC_NO_PFC'
+                in the 'priority' field.
+*//***************************************************************************/
+t_Error FM_MAC_SetTxPauseFrames(t_Handle h_FmMac,
+                                uint8_t  priority,
+                                uint16_t pauseTime,
+                                uint16_t threshTime);
+
+/**************************************************************************//**
+ @Function      FM_MAC_SetRxIgnorePauseFrames
+
+ @Description   Enable/Disable ignoring of Pause-Frames.
+
+ @Param[in]     h_FmMac    - A handle to a FM MAC Module.
+ @Param[in]     en         - boolean indicates whether to ignore the incoming pause
+                             frames or not.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_SetRxIgnorePauseFrames(t_Handle h_FmMac, bool en);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ResetCounters
+
+ @Description   reset all statistics counters
+
+ @Param[in]     h_FmMac    - A handle to a FM MAC Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ResetCounters(t_Handle h_FmMac);
+
+/**************************************************************************//**
+ @Function      FM_MAC_SetException
+
+ @Description   Enable/Disable a specific Exception
+
+ @Param[in]     h_FmMac        - A handle to a FM MAC Module.
+ @Param[in]     ex             - Type of the desired exceptions
+ @Param[in]     enable         - TRUE to enable the specified exception, FALSE to disable it.
+
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_SetException(t_Handle h_FmMac, e_FmMacExceptions ex, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_SetStatistics
+
+ @Description   Define Statistics level.
+                Where applicable, the routine also enables the MIB counters
+                overflow interrupt in order to keep counters accurate
+                and account for overflows.
+                This routine is relevant only for dTSEC.
+
+ @Param[in]     h_FmMac         - A handle to a FM MAC Module.
+ @Param[in]     statisticsLevel - Full statistics level provides all standard counters but may
+                                  reduce performance. Partial statistics provides only special
+                                  event counters (errors etc.). If selected, regular counters (such as
+                                  byte/packet) will be invalid and will return -1.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_SetStatistics(t_Handle h_FmMac, e_FmMacStatisticsLevel statisticsLevel);
+
+/**************************************************************************//**
+ @Function      FM_MAC_GetStatistics
+
+ @Description   get all statistics counters
+
+ @Param[in]     h_FmMac       -  A handle to a FM MAC Module.
+ @Param[in]     p_Statistics  -  Structure with statistics
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FM_MAC_GetStatistics(t_Handle h_FmMac, t_FmMacStatistics *p_Statistics);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ModifyMacAddr
+
+ @Description   Replace the main MAC Address
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   Ethernet Mac address
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ModifyMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_AddHashMacAddr
+
+ @Description   Add an Address to the hash table. This is for filter purpose only.
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   Ethernet Mac address
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init(). It is a filter only address.
+ @Cautions      Some address need to be filterd out in upper FM blocks.
+*//***************************************************************************/
+t_Error FM_MAC_AddHashMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_RemoveHashMacAddr
+
+ @Description   Delete an Address to the hash table. This is for filter purpose only.
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   Ethernet Mac address
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_RemoveHashMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_AddExactMatchMacAddr
+
+ @Description   Add a unicast or multicast mac address for exact-match filtering
+                (8 on dTSEC, 2 for 10G-MAC)
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   MAC Address to ADD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_AddExactMatchMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_RemovelExactMatchMacAddr
+
+ @Description   Remove a uni cast or multi cast mac address.
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   MAC Address to remove
+
+ @Return        E_OK on success; Error code otherwise..
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_RemovelExactMatchMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_SetPromiscuous
+
+ @Description   Enable/Disable MAC Promiscuous mode for ALL mac addresses.
+
+ @Param[in]     h_FmMac    - A handle to a FM MAC Module.
+ @Param[in]     enable     - TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_SetPromiscuous(t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_AdjustLink
+
+ @Description   Adjusts the Ethernet link with new speed/duplex setup.
+                This routine is relevant only for dTSEC.
+
+ @Param[in]     h_FmMac     - A handle to a FM Module.
+ @Param[in]     speed       - Ethernet speed.
+ @Param[in]     fullDuplex  - TRUE for Full-Duplex mode;
+                              FALSE for Half-Duplex mode.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MAC_AdjustLink(t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex);
+
+/**************************************************************************//**
+ @Function      FM_MAC_RestartAutoneg
+
+ @Description   Restarts the autonegotiation process.
+                When autonegegotiation process is invoked under traffic the
+                autonegotiation process between the internal TBI PHY and the
+                external PHY does not always complete succesfuly. Calling this
+                function will restart the autonegotiation process that will end
+                succesfuly. It is recomended to call this function after issuing
+                autoneg restart command to the Eth Phy.
+                This routine is relevant only for dTSEC.
+
+ @Param[in]     h_FmMac     - A handle to a FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MAC_RestartAutoneg(t_Handle h_FmMac);
+
+/**************************************************************************//**
+ @Function      FM_MAC_GetId
+
+ @Description   Return the MAC ID
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[out]    p_MacId     -   MAC ID of device
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_GetId(t_Handle h_FmMac, uint32_t *p_MacId);
+
+/**************************************************************************//**
+ @Function      FM_MAC_GetVesrion
+
+ @Description   Return Mac HW chip version
+
+ @Param[in]     h_FmMac      -   A handle to a FM Module.
+ @Param[out]    p_MacVresion -   Mac version as defined by the chip
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_GetVesrion(t_Handle h_FmMac, uint32_t *p_MacVresion);
+
+/**************************************************************************//**
+ @Function      FM_MAC_MII_WritePhyReg
+
+ @Description   Write data into Phy Register
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     phyAddr     -   Phy Address on the MII bus
+ @Param[in]     reg         -   Register Number.
+ @Param[in]     data        -   Data to write.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_MII_WritePhyReg(t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg, uint16_t data);
+
+/**************************************************************************//**
+ @Function      FM_MAC_MII_ReadPhyReg
+
+ @Description   Read data from Phy Register
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     phyAddr     -   Phy Address on the MII bus
+ @Param[in]     reg         -   Register Number.
+ @Param[out]    p_Data      -   Data from PHY.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_MII_ReadPhyReg(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_MAC_DumpRegs
+
+ @Description   Dump internal registers
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_DumpRegs(t_Handle h_FmMac);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/** @} */ /* end of FM_mac_runtime_control_grp group */
+/** @} */ /* end of FM_mac_grp group */
+/** @} */ /* end of FM_grp group */
+
+/**************************************************************************//**
+ @Function      DtsecRestartTbiAN
+
+ @Description   Restart TBI autonegotiation for a given Dtsec TBI interface.
+
+ @Param[in]     h_Dtsec     -   A handle to the Dtsec.
+*//***************************************************************************/
+void DtsecRestartTbiAN(t_Handle h_Dtsec);
+
+#endif /* __FM_MAC_EXT_H */
--- fmlib-fslsdk-v1.7/include/fmd/Peripherals/common/general.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/include/fmd/Peripherals/common/general.h	2022-05-26 11:28:31.058974312 -0700
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __GENERAL_H
+#define __GENERAL_H
+
+#include "std_ext.h"
+#if !defined(NCSW_LINUX)
+#include "errno.h"
+#endif
+
+
+extern uint32_t get_mac_addr_crc(uint64_t _addr);
+
+
+#define iowrite32be(val, addr)  WRITE_UINT32(*addr, val)
+#define ioread32be(addr)        GET_UINT32(*addr)
+
+#define ether_crc(len, addr)    get_mac_addr_crc(*(uint64_t *)(addr)>>16)
+
+
+#endif /* __GENERAL_H */
--- fmlib-fslsdk-v1.7/README.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/README	2022-05-26 11:28:31.058974312 -0700
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+This package contains Frame Manager user space library.
+
+The Frame Manager library provides an API on top of the Frame Manager driver
+ioctl calls, that provides a user space application with a simple way 
+to configure driver parameters and PCD (parse - classify - distribute) rules.
+
+The licensing information for this package is included in the COPYING file.
+
--- fmlib-fslsdk-v1.7/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/Makefile	2022-05-26 11:28:31.054974474 -0700
@@ -0,0 +1,171 @@
+#==============================================================================
+# Copyright 2010-2012 Freescale Semiconductor, Inc
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#       * Redistributions of source code must retain the above copyright
+# 	notice, this list of conditions and the following disclaimer.
+#       * Redistributions in binary form must reproduce the above copyright
+# 	notice, this list of conditions and the following disclaimer in the
+# 	documentation and/or other materials provided with the distribution.
+#       * Neither the name of Freescale Semiconductor nor the
+# 	names of its contributors may be used to endorse or promote products
+# 	derived from this software without specific prior written permission.
+#
+#
+# ALTERNATIVELY, this software may be distributed under the terms of the
+# GNU General Public License ("GPL") as published by the Free Software
+# Foundation, either version 2 of that License or (at your option) any
+# later version.
+#
+# This software is provided by Freescale Semiconductor "as is" and any
+# express or implied warranties, including, but not limited to, the implied
+# warranties of merchantability and fitness for a particular purpose are
+# disclaimed. In no event shall Freescale Semiconductor be liable for any
+# direct, indirect, incidental, special, exemplary, or consequential damages
+# (including, but not limited to, procurement of substitute goods or services;
+# loss of use, data, or profits; or business interruption) however caused and
+# on any theory of liability, whether in contract, strict liability, or tort
+# (including negligence or otherwise) arising in any way out of the use of
+# this software, even if advised of the possibility of such damage.
+#==============================================================================
+
+# WARNING!
+# Although invoking the all, archive targets in this Makefile from a Yocto-like
+# environment may succeed, you will end up with N different libraries that are
+# actually being built using the same compiler flags, i.e. the CFLAGS from the
+# environment. That is because Yocto builds the fm-lib for various platforms
+# one at a time, by invoking only the corresponding libfm-<arch>.a, then
+# install-<arch> targets for each platform that it's currently configured for.
+
+# Set this as appropriate for local builds
+CROSS_COMPILE?=powerpc-linux-gnu-
+
+# You must set KERNEL_SRC or the <DESTDIR, PREFIX> pair
+# before invoking this Makefile as standalone
+KERNEL_SRC?=$(DESTDIR)$(PREFIX)
+
+# These should be inherited from the environment with which Yocto invokes us,
+# but in case not, then here we're making sure that we're actually using
+# the cross-tools, and NOT the native ones:
+ifeq ($(CC),cc)
+CC=$(CROSS_COMPILE)gcc
+endif
+
+ifeq ($(AR),ar)
+AR=$(CROSS_COMPILE)ar
+endif
+
+INSTALL?=install
+
+LIB_DEST_DIR?=$(PREFIX)/lib
+
+# Add any collateral files that need to be included in the archive, here:
+FM_LIB_DOCFILES=COPYING INSTALL README
+
+# Don't touch these!
+FM_LIB_YOCTO_STAGING=$(KERNEL_SRC)/include/linux/fmd
+FM_IOCTL_INC?=$(KERNEL_SRC)/include/uapi/linux/fmd
+FM_LIB_INC?=./include/fmd
+FM_LIB_SRCDIR=./src
+FM_LIB_INCLUDE:=$(FM_IOCTL_INC) \
+		$(FM_IOCTL_INC)/Peripherals \
+		$(FM_IOCTL_INC)/integrations \
+		$(FM_LIB_INC) \
+		$(FM_LIB_INC)/Peripherals \
+		$(FM_LIB_INC)/integrations \
+		$(FM_LIB_YOCTO_STAGING) \
+		$(FM_LIB_YOCTO_STAGING)/Peripherals \
+		$(FM_LIB_YOCTO_STAGING)/integrations
+
+# These flags need to be passed to the compiler in any circumstance:
+EXTRA_CFLAGS=-DNCSW_LINUX -fPIC -shared -mlongcall
+
+# CFLAGS to use during out-of-Yocto (i.e. "local") build:
+LOCAL_CFLAGS=-O2 -g0 -Wall \
+	     -fexpensive-optimizations -frename-registers \
+	     -fomit-frame-pointer -maix-struct-return \
+	     -D__STDC_LIMIT_MACROS $(EXTRA_CFLAGS)
+
+
+%.a: %.o
+	@(echo "(AR) $(@)")
+	@($(AR) rcsv $@ $^)
+
+libfm-ppce500mc.o: EXTRA_CFLAGS+=-DP4080
+libfm-ppc32e5500.o libfm-ppc64e5500.o: EXTRA_CFLAGS+=-DP5020
+libfm-ppc32e6500.o libfm-ppc64e6500.o: EXTRA_CFLAGS+=-DB4860
+libfm-ppc32e5500-fmv3.o libfm-ppc64e5500-fmv3.o: EXTRA_CFLAGS+=-DB4860
+libfm-ppce500v2.o: EXTRA_CFLAGS+=-DP1023
+
+libfm-ppc32e5500-fmv3.o: CFLAGS?=-m32 -mhard-float -mcpu=e5500  $(LOCAL_CFLAGS)
+libfm-ppc64e5500-fmv3.o: CFLAGS?=-m64 -mhard-float -mcpu=e5500  $(LOCAL_CFLAGS)
+libfm-ppce500mc.o:  CFLAGS?=-m32 -mhard-float -mcpu=e500mc $(LOCAL_CFLAGS)
+libfm-ppc32e5500.o: CFLAGS?=-m32 -mhard-float -mcpu=e5500  $(LOCAL_CFLAGS)
+libfm-ppc64e5500.o: CFLAGS?=-m64 -mhard-float -mcpu=e5500  $(LOCAL_CFLAGS)
+libfm-ppce500v2.o:  CFLAGS?=-m32 -msoft-float -mcpu=8548   $(LOCAL_CFLAGS)
+libfm-ppc32e6500.o: CFLAGS?=-m32 -mhard-float -mcpu=e6500  $(LOCAL_CFLAGS)
+libfm-ppc64e6500.o: CFLAGS?=-m64 -mhard-float -mcpu=e6500  $(LOCAL_CFLAGS)
+libfm-ppce500v2.o:  CFLAGS?=-m32 -msoft-float -mcpu=8548   $(LOCAL_CFLAGS)
+
+CFLAGS+=$(EXTRA_CFLAGS) -isystem $(KERNEL_SRC)/include
+
+
+all: libfm-ppc32e5500.a libfm-ppc64e5500.a libfm-ppce500mc.a \
+		libfm-ppce500v2.a libfm-ppc64e6500.a libfm-ppc32e6500.a \
+		libfm-ppc32e5500-fmv3.a libfm-ppc64e5500-fmv3.a
+
+libfm-ppc32e5500.o libfm-ppc64e5500.o libfm-ppce500mc.o libfm-ppce500v2.o \
+		libfm-ppc32e6500.o libfm-ppc64e6500.o \
+		libfm-ppc32e5500-fmv3.o libfm-ppc64e5500-fmv3.o: \
+		$(FM_LIB_SRCDIR)/fm_lib.c $(wildcard $(addsuffix /*.h,$(FM_LIB_INCLUDE)))
+	@(echo "(CC)  $@")
+	@(echo "$(CC) $(CFLAGS) $(addprefix -I,$(FM_LIB_INCLUDE)) -c -o $@ $<" > .$@.cmd)
+	@($(CC) $(CFLAGS) $(addprefix -I,$(FM_LIB_INCLUDE)) -c -o $@ $<)
+
+archive: all .version
+	@(echo "Creating tarball for fmlib...")
+	@(tar -czf fm-lib-bi.tar.gz . \
+		--transform "s,\\.\\(.*\\),fm-lib\\1," \
+		--exclude=Makefile --exclude=.version --exclude-vcs --exclude=*.tar.gz)
+
+install-%: %.a
+	@(echo "Installing...")
+	@($(INSTALL) -d $(DESTDIR)$(LIB_DEST_DIR))
+	@($(INSTALL) $< $(DESTDIR)$(LIB_DEST_DIR))
+	@(ln -s $< $(DESTDIR)$(LIB_DEST_DIR)/libfm.a)
+	@(cp -r -p ./include $(DESTDIR)$(PREFIX))
+	@($(INSTALL) -d $(DESTDIR)$(PREFIX)/share/doc/fm-lib)
+	@($(INSTALL) $(FM_LIB_DOCFILES) $(DESTDIR)$(PREFIX)/share/doc/fm-lib)
+
+targets help:
+	@(echo)
+	@(echo "make all: build libraries for all platforms (local build)")
+	@(echo)
+	@(echo "make archive: build tarball with fm libraries")
+	@(echo)
+	@(echo "make libfm-<arch>.a (e.g. \"make libfm-ppce500mc.a\"):")
+	@(echo "	build library for specific platform <arch>")
+	@(echo)
+	@(echo "The available make libfm-<arch>.a targets are:")
+	@(echo "	libfm-ppce500mc.a		(P2, P3, P4)")
+	@(echo "	libfm-ppc32e5500.a		(P5 - 32b)")
+	@(echo "	libfm-ppc64e5500.a		(P5 - 64b)")
+	@(echo "	libfm-ppc32e6500.a		(B4/T4 - 32b)")
+	@(echo "	libfm-ppc64e6500.a		(B4/T4 - 64b)")
+	@(echo "	libfm-ppc32e5500-fmv3.a		(t1040 - 32b)")
+	@(echo "	libfm-ppc64e5500-fmv3.a		(t1040 - 64b)")
+	@(echo "	libfm-ppce500v2.a		(P1023)")
+	@(echo)
+	@(echo "make install-libfm-<arch> (e.g. \"make install-libfm-ppce500mc\"):")
+	@(echo "	install the library and headers to the location specified by DESTDIR, PREFIX")
+	@(echo)
+	@(echo "Please also mind the fact that the environment for invoking 'make' with this Makefile")
+	@(echo "needs also contain certain required variables, most notably KERNEL_SRC!")
+	@(echo)
+
+clean:
+	@(echo "Cleaning...")
+	@(rm -rf *.a *.o *.d .*.o.cmd)
+
+.PHONY: targets help clean
--- fmlib-fslsdk-v1.7/INSTALL.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/INSTALL	2022-05-26 11:28:31.054974474 -0700
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+Manual installation for FM library:
+   - set PATH and CROSS_COMPILE to point to the cross-toolchain on the host
+   - set KERNEL_SRC to point to the root dir. for the kernel/headers (i.e.
+   the Linux kernel that's contained in the SDK, not other kernel!)
+   - make all: will create the binaries for all platforms
+   - make archive: will create the tarball containing all fmlib binaries
+   - make install-xxx will:
+	* copy binary (libfm-xxx.a) to the ${PREFIX}/lib folder on the target
+	root filesystem pointed to by the ${DESTDIR} variable
+	* copy headers (include/fmd/ dir.) to the ${PREFIX}/include/fmd/ dir.
+	on target rfs
+	* copy doc. files to the ${PREFIX}/share/doc/fm-lib-<version> dir
+	of the same rfs
+
+'make targets' will display a short usage summary, along with the available
+"xxx" variants.
+
+An application that uses this package will have to link with the static
+library and include the necessary headers.
+
+
--- fmlib-fslsdk-v1.7/src/fm_lib.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ fmlib-fslsdk-v1.7/src/fm_lib.c	2022-05-26 11:28:31.142970877 -0700
@@ -0,0 +1,2328 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor, Inc
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      * Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      * Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      * Neither the name of Freescale Semiconductor nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+/**************************************************************************//**
+ @File          fm_lib.c
+
+ @Description   Frame Manager Linux User-Space library implementation.
+*//***************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <unistd.h>
+#include <termios.h>
+#include <sys/ioctl.h>
+#include <stdbool.h>
+
+#include "fm_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_port_ext.h"
+#include "fm_mac_ext.h"
+#if (DPAA_VERSION >= 11)
+#include "fm_vsp_ext.h"
+#endif
+
+#include "fm_ioctls.h"
+#include "fm_pcd_ioctls.h"
+#include "fm_port_ioctls.h"
+
+#define __ERR_MODULE__      MODULE_FM
+
+#define DEV_TO_ID(p) \
+    do { \
+        t_Device *p_Dev = (t_Device *)p; \
+        p = UINT_TO_PTR(p_Dev->id); \
+    } while(0)
+
+/* #define FM_LIB_DBG */
+
+#if defined(FM_LIB_DBG)
+    #define _fml_dbg(format, arg...) \
+        printf("fmlib [%s:%u] - " format, \
+            __func__, __LINE__, ##arg)
+#else
+    #define _fml_dbg(arg...)
+#endif
+
+/* Major and minor are in sync with FMD, respin is for fmlib identification */
+#define FM_LIB_VERSION_MAJOR    21
+#define FM_LIB_VERSION_MINOR     1 
+#define FM_LIB_VERSION_RESPIN    0
+
+#if (FMD_API_VERSION_MAJOR != FM_LIB_VERSION_MAJOR) || \
+    (FMD_API_VERSION_MINOR != FM_LIB_VERSION_MINOR)
+#warning FMD and FMLIB version mismatch
+#endif
+
+t_Error FM_GetApiVersion(t_Handle h_Fm, ioc_fm_api_version_t *p_version);
+
+/*******************************************************************************
+*  FM FUNCTIONS                                                                *
+*******************************************************************************/
+
+t_Handle FM_Open(uint8_t id)
+{
+    t_Device    *p_Dev;
+    int         fd;
+    char        devName[20];
+    static bool called = FALSE;
+    ioc_fm_api_version_t ver;
+
+    _fml_dbg("Calling...\n");
+
+    p_Dev = (t_Device*) malloc(sizeof(t_Device));
+    if (!p_Dev)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM device!!"));
+        return NULL;
+    }
+
+    memset(devName, 0, 20);
+    sprintf(devName, "%s%s%d", "/dev/", DEV_FM_NAME, id);
+    fd = open(devName, O_RDWR);
+    if (fd < 0)
+    {
+       free(p_Dev);
+       REPORT_ERROR(MAJOR, E_NO_DEVICE, ("Could not open FM. Ret code=%d, errno=%d. Aborting!!!",
+               fd,
+               errno));
+       return NULL;
+    }
+
+    p_Dev->id = id;
+    p_Dev->fd = fd;
+    if (!called)
+    {
+        called = TRUE;
+
+        FM_GetApiVersion((t_Handle)p_Dev, &ver);
+
+        if (FMD_API_VERSION_MAJOR != ver.version.major ||
+            FMD_API_VERSION_MINOR != ver.version.minor ||
+            FMD_API_VERSION_RESPIN != ver.version.respin)
+        {
+            printf("Warning:\nCompiled against FMD API version %u.%u.%u\n",
+                FMD_API_VERSION_MAJOR, FMD_API_VERSION_MINOR, FMD_API_VERSION_RESPIN);
+            printf("Running with FMD API version %u.%u.%u\n",
+                ver.version.major, ver.version.minor, ver.version.respin);
+            printf("Current fmlib version %u.%u.%u\n",
+                FM_LIB_VERSION_MAJOR, FM_LIB_VERSION_MINOR, FM_LIB_VERSION_RESPIN);
+        }
+    }
+    _fml_dbg("Called.\n");
+
+    return (t_Handle)p_Dev;
+}
+
+void FM_Close(t_Handle h_Fm)
+{
+    t_Device    *p_Dev = (t_Device*) h_Fm;
+
+    SANITY_CHECK_RETURN(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    close(p_Dev->fd);
+    free(p_Dev);
+
+    _fml_dbg("Called.\n");
+}
+
+t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBandwidth)
+{
+    t_Device    *p_Dev = (t_Device*) h_Fm;
+
+    ASSERT_COND(sizeof(t_FmPortsBandwidthParams) == sizeof(ioc_fm_port_bandwidth_params));
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_IOC_SET_PORTS_BANDWIDTH, p_PortsBandwidth))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error  FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
+{
+    t_Device    *p_Dev = (t_Device*) h_Fm;
+
+    ASSERT_COND(sizeof(t_FmRevisionInfo) == sizeof(ioc_fm_revision_info_t));
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_IOC_GET_REVISION, p_FmRevisionInfo))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
+{
+    t_Device                    *p_Dev = (t_Device*) h_Fm;
+    ioc_fm_counters_params_t    params;
+
+    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, 0);
+
+    _fml_dbg("Calling...\n");
+
+    params.cnt = (ioc_fm_counters) counter;
+
+    if (ioctl(p_Dev->fd, FM_IOC_GET_COUNTER, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return params.val;
+}
+
+t_Error  FM_SetCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
+{
+    t_Device                    *p_Dev = (t_Device*) h_Fm;
+    ioc_fm_counters_params_t    params;
+
+    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, 0);
+
+    _fml_dbg("Calling...\n");
+
+    params.cnt = (ioc_fm_counters) counter;
+    params.val = val;
+
+    if (ioctl(p_Dev->fd, FM_IOC_SET_COUNTER, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_ForceIntr(t_Handle h_Fm, e_FmExceptions exception)
+{
+    t_Device    *p_Dev = (t_Device*) h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_IOC_FORCE_INTR, (ioc_fm_exceptions) exception))
+        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error  FM_GetApiVersion(t_Handle h_Fm, ioc_fm_api_version_t *p_version)
+{
+    t_Device                    *p_Dev = (t_Device*) h_Fm;
+
+    _fml_dbg("Calling...\n");
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    if (ioctl(p_Dev->fd, FM_IOC_GET_API_VERSION, p_version))
+        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+/********************************************************************************************/
+/*  FM_PCD FUNCTIONS                                                                        */
+/********************************************************************************************/
+
+t_Handle FM_PCD_Open(t_FmPcdParams *p_FmPcdParams)
+{
+    t_Device    *p_Dev;
+    int         fd;
+    char        devName[20];
+
+    _fml_dbg("Calling...\n");
+
+    p_Dev = (t_Device*) malloc(sizeof(t_Device));
+    if (!p_Dev)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD device!!"));
+        return NULL;
+    }
+
+    memset(devName, 0, 20);
+    sprintf(devName, "%s%s%u-pcd", "/dev/", DEV_FM_NAME, (uint32_t)((t_Device*) p_FmPcdParams->h_Fm)->id);
+    fd = open(devName, O_RDWR);
+    if (fd < 0)
+    {
+       free(p_Dev);
+       REPORT_ERROR(MAJOR, E_NO_DEVICE, ("Could not open FM. Ret code=%d, errno=%d. Aborting!!!",
+               fd,
+               errno));
+       return NULL;
+    }
+
+    p_Dev->id = ((t_Device*) p_FmPcdParams->h_Fm)->id;
+    p_Dev->fd = fd;
+    p_Dev->owners = 0;
+
+    _fml_dbg("Called.\n");
+
+    return (t_Handle) p_Dev;
+}
+
+void FM_PCD_Close(t_Handle h_FmPcd)
+{
+    t_Device    *p_Dev = (t_Device*) h_FmPcd;
+
+    SANITY_CHECK_RETURN(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    close(p_Dev->fd);
+
+    if (p_Dev->owners) {
+        XX_Print("Trying to delete a pcd handler that has modules bound to (owners:%u)!!!",
+            p_Dev->owners);
+        return;
+    }
+
+    free(p_Dev);
+
+    _fml_dbg("Called.\n");
+}
+
+t_Error FM_PCD_Enable(t_Handle h_FmPcd)
+{
+    t_Device    *p_Dev = (t_Device*) h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PCD_IOC_ENABLE))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PCD_Disable(t_Handle h_FmPcd)
+{
+    t_Device    *p_Dev = (t_Device*) h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PCD_IOC_DISABLE))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
+{
+    t_Device    *p_Dev = (t_Device*) h_FmPcd;
+
+    ASSERT_COND(sizeof(t_FmPcdPrsSwParams) == sizeof(ioc_fm_pcd_prs_sw_params_t));
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PCD_IOC_PRS_LOAD_SW, p_SwPrs))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
+{
+    t_Device    *p_Dev = (t_Device*) h_FmPcd;
+    ioc_fm_pcd_kg_dflt_value_params_t params;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    params.value = value;
+    params.valueId = valueId;
+
+    if (ioctl(p_Dev->fd, FM_PCD_IOC_KG_SET_DFLT_VALUE, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset)
+{
+    t_Device    *p_Dev = (t_Device*) h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING, &payloadOffset))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable)
+{
+    t_Device                        *p_Dev = (t_Device*) h_FmPcd;
+    ioc_fm_pcd_exception_params_t   params;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    params.exception = exception;
+    params.enable = enable;
+
+    if (ioctl(p_Dev->fd, FM_PCD_IOC_SET_EXCEPTION, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
+{
+    t_Device                        *p_Dev = (t_Device*) h_FmPcd;
+    ioc_fm_pcd_counters_params_t    params;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    params.cnt = (ioc_fm_pcd_counters) counter;
+
+    if (ioctl(p_Dev->fd, FM_PCD_IOC_GET_COUNTER, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return params.val;
+}
+
+#if 0
+t_Error FM_PCD_SetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value)
+{
+    t_Device                        *p_Dev = (t_Device*) h_FmPcd;
+    ioc_fm_pcd_counters_params_t    params;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    params.cnt = (ioc_fm_pcd_counters) counter;
+    params.val = value;
+
+    if (ioctl(p_Dev->fd, FM_PCD_IOC_SET_COUNTER, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    return E_OK;
+}
+#endif
+
+t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
+{
+    t_Device    *p_Dev = (t_Device*) h_FmPcd;
+    int         intCast = (int) exception;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PCD_IOC_FORCE_INTR, &intCast))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams *p_NetEnvParams)
+{
+    t_Device *p_PcdDev = (t_Device*) h_FmPcd;
+    t_Device *p_Dev = NULL;
+    ioc_fm_pcd_net_env_params_t params;
+
+    SANITY_CHECK_RETURN_VALUE(p_PcdDev, E_INVALID_HANDLE, NULL);
+
+    _fml_dbg("Calling...\n");
+
+    memcpy(&params, p_NetEnvParams, sizeof(t_FmPcdNetEnvParams));
+    params.id = NULL;
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET, &params))
+    {
+        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+        return NULL;
+    }
+
+    p_Dev = (t_Device *)malloc(sizeof(t_Device));
+    if (!p_Dev)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD NetEnv Chrs device!!"));
+        return NULL;
+    }
+    memset(p_Dev, 0, sizeof(t_Device));
+    p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
+    p_PcdDev->owners++;
+    p_Dev->id = PTR_TO_UINT(params.id);
+
+    _fml_dbg("Called.\n");
+
+    return (t_Handle) p_Dev;;
+}
+
+t_Error FM_PCD_NetEnvCharacteristicsDelete(t_Handle h_NetEnv)
+{
+    t_Device *p_Dev = (t_Device*) h_NetEnv;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_obj_t id;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
+    id.obj = UINT_TO_PTR(p_Dev->id);
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE, &id)){
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+    }
+
+    p_PcdDev->owners--;
+    free(p_Dev);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Handle FM_PCD_KgSchemeSet (t_Handle h_FmPcd, t_FmPcdKgSchemeParams *p_Scheme)
+{
+    t_Device *p_PcdDev = (t_Device*) h_FmPcd;
+    t_Device *p_Dev = NULL;
+    ioc_fm_pcd_kg_scheme_params_t params;
+
+    SANITY_CHECK_RETURN_VALUE(p_PcdDev, E_INVALID_HANDLE, NULL);
+
+    _fml_dbg("Calling...\n");
+
+    memcpy(&params, p_Scheme, sizeof(t_FmPcdKgSchemeParams));
+    params.id = NULL;
+
+    if (params.modify)
+    {
+        if (params.scm_id.scheme_id)
+            DEV_TO_ID(params.scm_id.scheme_id);
+        else
+        {
+            REPORT_ERROR(MINOR, E_INVALID_HANDLE, NO_MSG);
+            return NULL;
+        }
+    }
+
+    /* correct h_NetEnv param from scheme */
+    if (params.net_env_params.net_env_id)
+        DEV_TO_ID(params.net_env_params.net_env_id);
+
+    /* correct next engine params handlers: cc*/
+    if (params.next_engine == e_IOC_FM_PCD_CC &&
+        params.kg_next_engine_params.cc.tree_id)
+            DEV_TO_ID(params.kg_next_engine_params.cc.tree_id);
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_KG_SCHEME_SET, &params))
+    {
+        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+        return NULL;
+    }
+
+    p_Dev = (t_Device *)malloc(sizeof(t_Device));
+    if (!p_Dev)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD KG Scheme device!!"));
+        return NULL;
+    }
+
+    memset(p_Dev, 0, sizeof(t_Device));
+    p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
+    p_PcdDev->owners++;
+    p_Dev->id = PTR_TO_UINT(params.id);
+
+    _fml_dbg("Called.\n");
+
+    return (t_Handle) p_Dev;
+}
+
+t_Error FM_PCD_KgSchemeDelete(t_Handle h_Scheme)
+{
+    t_Device *p_Dev = (t_Device*) h_Scheme;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_obj_t id;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev =  (t_Device *)p_Dev->h_UserPriv;
+    id.obj = UINT_TO_PTR(p_Dev->id);
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_KG_SCHEME_DELETE, &id)){
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+    }
+
+    p_PcdDev->owners--;
+    free(p_Dev);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdTreeParam)
+{
+    t_Device *p_PcdDev = (t_Device*) h_FmPcd;
+    t_Device *p_Dev = NULL;
+    ioc_fm_pcd_cc_tree_params_t params;
+    uint32_t i, j;
+
+    SANITY_CHECK_RETURN_VALUE(p_PcdDev, E_INVALID_HANDLE, NULL);
+
+    _fml_dbg("Calling...\n");
+
+    memcpy(&params, p_PcdTreeParam, sizeof(t_FmPcdCcTreeParams));
+    params.id = NULL;
+
+    /* correct net_env_id */
+    if (params.net_env_id)
+        DEV_TO_ID(params.net_env_id);
+
+    /* correct next engine kg and cc handlers: cc_node_id, p_direct_scheme */
+    for (i = 0; i < IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS; i++)
+        for (j = 0; j < IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP; j++){
+            if (params.fm_pcd_cc_group_params[i].next_engine_per_entries_in_grp[j].next_engine == e_IOC_FM_PCD_CC &&
+                params.fm_pcd_cc_group_params[i].next_engine_per_entries_in_grp[j].params.cc_params.cc_node_id)
+                    DEV_TO_ID(params.fm_pcd_cc_group_params[i].next_engine_per_entries_in_grp[j].params.cc_params.cc_node_id);
+
+            if (params.fm_pcd_cc_group_params[i].next_engine_per_entries_in_grp[j].next_engine == e_IOC_FM_PCD_KG &&
+                params.fm_pcd_cc_group_params[i].next_engine_per_entries_in_grp[j].params.kg_params.p_direct_scheme)
+                    DEV_TO_ID(params.fm_pcd_cc_group_params[i].next_engine_per_entries_in_grp[j].params.kg_params.p_direct_scheme);
+
+            /*TODO params.fm_pcd_cc_group_params[i].next_engine_per_entries_in_grp[j].manip_id*/
+        }
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_CC_ROOT_BUILD, &params))
+    {
+        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+        return NULL;
+    }
+
+    p_Dev = (t_Device *)malloc(sizeof(t_Device));
+    if (!p_Dev)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD CC Root device!!"));
+        return NULL;
+    }
+
+    memset(p_Dev, 0, sizeof(t_Device));
+    p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
+    p_PcdDev->owners++;
+    p_Dev->id = PTR_TO_UINT(params.id);
+
+    _fml_dbg("Called.\n");
+
+    return (t_Handle) p_Dev;
+}
+
+t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree)
+{
+    t_Device *p_Dev = (t_Device*) h_CcTree;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_obj_t id;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
+    id.obj = UINT_TO_PTR(p_Dev->id);
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_CC_ROOT_DELETE, &id)){
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+    }
+
+    p_PcdDev->owners--;
+    free(p_Dev);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
+{
+    t_Device *p_PcdDev = (t_Device*) h_FmPcd;
+    t_Device *p_Dev = NULL;
+    ioc_fm_pcd_cc_node_params_t params;
+    uint32_t i;
+
+    SANITY_CHECK_RETURN_VALUE(p_PcdDev, E_INVALID_HANDLE, NULL);
+
+    _fml_dbg("Calling...\n");
+
+    memcpy(&params, p_CcNodeParam, sizeof(t_FmPcdCcNodeParams));
+    params.id = NULL;
+
+    /*correct*/
+    for(i = 0; i < params.keys_params.num_of_keys;i++){
+        if (params.keys_params.key_params[i].cc_next_engine_params.next_engine == e_IOC_FM_PCD_CC &&
+            params.keys_params.key_params[i].cc_next_engine_params.params.cc_params.cc_node_id)
+                DEV_TO_ID(params.keys_params.key_params[i].cc_next_engine_params.params.cc_params.cc_node_id);
+
+        if (params.keys_params.key_params[i].cc_next_engine_params.next_engine == e_IOC_FM_PCD_KG &&
+            params.keys_params.key_params[i].cc_next_engine_params.params.kg_params.p_direct_scheme)
+                DEV_TO_ID(params.keys_params.key_params[i].cc_next_engine_params.params.kg_params.p_direct_scheme);
+
+        if (params.keys_params.key_params[i].cc_next_engine_params.manip_id)
+            DEV_TO_ID(params.keys_params.key_params[i].cc_next_engine_params.manip_id);
+
+#if (DPAA_VERSION >= 11)
+        if (params.keys_params.key_params[i].cc_next_engine_params.next_engine == e_IOC_FM_PCD_FR &&
+            params.keys_params.key_params[i].cc_next_engine_params.params.fr_params.frm_replic_id)
+            DEV_TO_ID(params.keys_params.key_params[i].cc_next_engine_params.params.fr_params.frm_replic_id);
+#endif /* DPAA_VERSION >= 11 */
+    }
+
+    if (params.keys_params.cc_next_engine_params_for_miss.next_engine == e_IOC_FM_PCD_CC &&
+        params.keys_params.cc_next_engine_params_for_miss.params.cc_params.cc_node_id)
+            DEV_TO_ID(params.keys_params.cc_next_engine_params_for_miss.params.cc_params.cc_node_id);
+
+    if (params.keys_params.cc_next_engine_params_for_miss.next_engine == e_IOC_FM_PCD_KG &&
+        params.keys_params.cc_next_engine_params_for_miss.params.kg_params.p_direct_scheme)
+            DEV_TO_ID(params.keys_params.cc_next_engine_params_for_miss.params.kg_params.p_direct_scheme);
+
+    if (params.keys_params.cc_next_engine_params_for_miss.manip_id)
+        DEV_TO_ID(params.keys_params.cc_next_engine_params_for_miss.manip_id);
+
+#if (DPAA_VERSION >= 11)
+    if (params.keys_params.cc_next_engine_params_for_miss.next_engine == e_IOC_FM_PCD_FR &&
+        params.keys_params.cc_next_engine_params_for_miss.params.fr_params.frm_replic_id)
+            DEV_TO_ID(params.keys_params.cc_next_engine_params_for_miss.params.fr_params.frm_replic_id);
+
+#endif /* DPAA_VERSION >= 11 */
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MATCH_TABLE_SET, &params))
+    {
+        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+        return NULL;
+    }
+
+    p_Dev = (t_Device *)malloc(sizeof(t_Device));
+    if (!p_Dev)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Match Table device!!"));
+        return NULL;
+    }
+    memset(p_Dev, 0, sizeof(t_Device));
+    p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
+    p_PcdDev->owners++;
+    p_Dev->id = PTR_TO_UINT(params.id);
+
+    _fml_dbg("Called.\n");
+
+    return (t_Handle) p_Dev;
+}
+
+t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode)
+{
+    t_Device *p_Dev = (t_Device *)h_CcNode;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_obj_t id;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
+    id.obj = UINT_TO_PTR(p_Dev->id);
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MATCH_TABLE_DELETE, &id)){
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+    }
+
+    p_PcdDev->owners--;
+    free(p_Dev);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
+                                      uint8_t                   grpId,
+                                      uint8_t                   index,
+                                      t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_Device *p_Dev = (t_Device*) h_CcTree;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_pcd_cc_tree_modify_next_engine_params_t  params;
+
+    ASSERT_COND(sizeof(t_FmPcdCcNextEngineParams) == sizeof(ioc_fm_pcd_cc_next_engine_params_t));
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
+
+    params.id = UINT_TO_PTR(p_Dev->id);
+    params.grp_indx = grpId;
+    params.indx = index;
+    memcpy(&params.cc_next_engine_params, p_FmPcdCcNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
+    if (p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) {
+        t_Device *p_NextDev = (t_Device*) p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode;
+
+        params.cc_next_engine_params.params.cc_params.cc_node_id = UINT_TO_PTR(p_NextDev->id);
+    }
+
+	if (p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_KG) {
+        t_Device *p_NextDev = (t_Device*) p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme;
+
+        params.cc_next_engine_params.params.kg_params.p_direct_scheme = UINT_TO_PTR(p_NextDev->id);
+    }
+
+	if (p_FmPcdCcNextEngineParams->h_Manip) {
+		t_Device *p_NextDev = (t_Device*) p_FmPcdCcNextEngineParams->h_Manip;
+		params.cc_next_engine_params.manip_id = UINT_TO_PTR(p_NextDev->id);
+	}
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle                  h_CcNode,
+                                          uint16_t                  keyIndex,
+                                          t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_Device *p_Dev = (t_Device*) h_CcNode;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_pcd_cc_node_modify_next_engine_params_t  params;
+
+    ASSERT_COND(sizeof(t_FmPcdCcNextEngineParams) == sizeof(ioc_fm_pcd_cc_next_engine_params_t));
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
+    params.id = UINT_TO_PTR(p_Dev->id);
+    params.key_indx = keyIndex;
+    memcpy(&params.cc_next_engine_params, p_FmPcdCcNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
+    if (p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) {
+        t_Device *p_NextDev = (t_Device*) p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode;
+
+        params.cc_next_engine_params.params.cc_params.cc_node_id = UINT_TO_PTR(p_NextDev->id);
+    }
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle                  h_CcNode,
+                                              t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_Device *p_Dev = (t_Device*) h_CcNode;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_pcd_cc_node_modify_next_engine_params_t  params;
+
+    ASSERT_COND(sizeof(t_FmPcdCcNextEngineParams) == sizeof(ioc_fm_pcd_cc_next_engine_params_t));
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
+
+    params.id = UINT_TO_PTR(p_Dev->id);
+    memcpy(&params.cc_next_engine_params, p_FmPcdCcNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
+    if (p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) {
+        t_Device *p_NextDev = (t_Device*) p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode;
+
+        params.cc_next_engine_params.params.cc_params.cc_node_id = UINT_TO_PTR(p_NextDev->id);
+    }
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
+                                uint16_t            keyIndex,
+                                uint8_t             keySize,
+                                t_FmPcdCcKeyParams  *p_KeyParams)
+{
+    t_Device *p_Dev = (t_Device*) h_CcNode;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t params;
+
+    ASSERT_COND(sizeof(t_FmPcdCcKeyParams) == sizeof(ioc_fm_pcd_cc_key_params_t));
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
+
+    params.id = UINT_TO_PTR(p_Dev->id);
+    params.key_indx = keyIndex;
+    params.key_size = keySize;
+    memcpy(&params.key_params, p_KeyParams, sizeof(t_FmPcdCcKeyParams));
+    if (p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_CC) {
+        t_Device *p_NextDev = (t_Device*) p_KeyParams->ccNextEngineParams.params.ccParams.h_CcNode;
+
+        params.key_params.cc_next_engine_params.params.cc_params.cc_node_id = UINT_TO_PTR(p_NextDev->id);
+    }
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MATCH_TABLE_ADD_KEY, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex)
+{
+    t_Device *p_Dev = (t_Device*) h_CcNode;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_pcd_cc_node_remove_key_params_t  params;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
+
+    params.id = UINT_TO_PTR(p_Dev->id);
+    params.key_indx = keyIndex;
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle            h_CcNode,
+                                                uint16_t            keyIndex,
+                                                uint8_t             keySize,
+                                                t_FmPcdCcKeyParams  *p_KeyParams)
+{
+    t_Device *p_Dev = (t_Device*) h_CcNode;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  params;
+
+    ASSERT_COND(sizeof(t_FmPcdCcKeyParams) == sizeof(ioc_fm_pcd_cc_key_params_t));
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device *)p_Dev->h_UserPriv;
+
+    params.id = UINT_TO_PTR(p_Dev->id);
+    params.key_indx = keyIndex;
+    params.key_size = keySize;
+    memcpy(&params.key_params, p_KeyParams, sizeof(t_FmPcdCcKeyParams));
+    if (p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_CC) {
+        t_Device *p_NextDev = (t_Device*) p_KeyParams->ccNextEngineParams.params.ccParams.h_CcNode;
+
+        params.key_params.cc_next_engine_params.params.cc_params.cc_node_id = UINT_TO_PTR(p_NextDev->id);
+    }
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
+{
+    t_Device *p_PcdDev = (t_Device*) h_FmPcd;
+    t_Device *p_Dev = (t_Device*) h_FmPcd;
+    ioc_fm_pcd_hash_table_params_t params;
+
+    SANITY_CHECK_RETURN_VALUE(p_PcdDev, E_INVALID_HANDLE, NULL);
+
+    _fml_dbg("Calling...\n");
+
+    memcpy(&params, p_Param, sizeof(t_FmPcdHashTableParams));
+    params.id = NULL;
+
+    if (params.cc_next_engine_params_for_miss.next_engine == e_IOC_FM_PCD_CC &&
+        params.cc_next_engine_params_for_miss.params.cc_params.cc_node_id)
+            DEV_TO_ID(params.cc_next_engine_params_for_miss.params.cc_params.cc_node_id);
+
+    if (params.cc_next_engine_params_for_miss.next_engine == e_IOC_FM_PCD_KG &&
+        params.cc_next_engine_params_for_miss.params.kg_params.p_direct_scheme)
+            DEV_TO_ID(params.cc_next_engine_params_for_miss.params.kg_params.p_direct_scheme);
+
+    if (params.cc_next_engine_params_for_miss.manip_id)
+        DEV_TO_ID(params.cc_next_engine_params_for_miss.manip_id);
+
+#if (DPAA_VERSION >= 11)
+    if (params.cc_next_engine_params_for_miss.next_engine == e_IOC_FM_PCD_FR &&
+        params.cc_next_engine_params_for_miss.params.fr_params.frm_replic_id)
+            DEV_TO_ID(params.cc_next_engine_params_for_miss.params.fr_params.frm_replic_id);
+
+#endif /* DPAA_VERSION >= 11 */
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_HASH_TABLE_SET, &params))
+    {
+        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+        return NULL;
+    }
+
+    p_Dev = (t_Device *)malloc(sizeof(t_Device));
+    if (!p_Dev)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Hash Table device!!"));
+        return NULL;
+    }
+    memset(p_Dev, 0, sizeof(t_Device));
+    p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
+    p_PcdDev->owners++;
+    p_Dev->id = PTR_TO_UINT(params.id);
+
+    _fml_dbg("Called.\n");
+
+    return (t_Handle) p_Dev;
+}
+
+t_Error FM_PCD_HashTableDelete(t_Handle h_HashTbl)
+{
+    t_Device *p_Dev = (t_Device*) h_HashTbl;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_obj_t id;
+
+    SANITY_CHECK_EXIT(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
+    id.obj = UINT_TO_PTR(p_Dev->id);
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_HASH_TABLE_DELETE, &id))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    p_PcdDev->owners--;
+    free(p_Dev);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PCD_HashTableAddKey(t_Handle            h_HashTbl,
+                               uint8_t             keySize,
+                               t_FmPcdCcKeyParams  *p_KeyParams)
+{
+    t_Device *p_Dev = (t_Device*) h_HashTbl;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_pcd_hash_table_add_key_params_t params;
+
+    SANITY_CHECK_EXIT(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
+
+    params.p_hash_tbl = UINT_TO_PTR(p_Dev->id);
+    params.key_size = keySize;
+    memcpy(&params.key_params, p_KeyParams, sizeof(t_FmPcdCcKeyParams));
+    if (p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_CC) {
+        t_Device *p_NextDev = (t_Device*) p_KeyParams->ccNextEngineParams.params.ccParams.h_CcNode;
+
+        params.key_params.cc_next_engine_params.params.cc_params.cc_node_id = UINT_TO_PTR(p_NextDev->id);
+    }
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_HASH_TABLE_ADD_KEY, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PCD_HashTableRemoveKey(t_Handle h_HashTbl,
+                                  uint8_t  keySize,
+                                  uint8_t  *p_Key)
+{
+    t_Device *p_Dev = (t_Device*) h_HashTbl;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_pcd_hash_table_remove_key_params_t params;
+
+    SANITY_CHECK_EXIT(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
+
+    params.p_hash_tbl = UINT_TO_PTR(p_Dev->id);
+    params.key_size = keySize;
+    params.p_key = p_Key;
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_HASH_TABLE_REMOVE_KEY, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
+                                   uint16_t keyIndex,
+                                   uint8_t  keySize,
+                                   uint8_t  *p_Key,
+                                   uint8_t  *p_Mask)
+{
+    t_Device *p_Dev = (t_Device*) h_CcNode;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_pcd_cc_node_modify_key_params_t params;
+    uint8_t                                key[IOC_FM_PCD_MAX_SIZE_OF_KEY];
+    uint8_t                                mask[IOC_FM_PCD_MAX_SIZE_OF_KEY];
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
+
+    params.id = UINT_TO_PTR(p_Dev->id);
+    params.key_indx = keyIndex;
+    params.key_size = keySize;
+    memcpy(key, p_Key, keySize);
+    if (p_Mask)
+        memcpy(mask, p_Mask, keySize);
+    params.p_key = key;
+    params.p_mask = mask;
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+
+t_Handle FM_PCD_PlcrProfileSet(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Profile)
+{
+    t_Device *p_PcdDev = (t_Device*) h_FmPcd;
+    t_Device *p_Dev = NULL;
+    ioc_fm_pcd_plcr_profile_params_t params;
+
+    SANITY_CHECK_RETURN_VALUE(p_PcdDev, E_INVALID_HANDLE, NULL);
+
+    _fml_dbg("Calling...\n");
+
+    memcpy(&params, p_Profile, sizeof(t_FmPcdPlcrProfileParams));
+    params.id = NULL;
+
+    if (!params.modify &&
+        (params.profile_select.new_params.profile_type
+                != (ioc_fm_pcd_profile_type_selection)e_FM_PCD_PLCR_SHARED))
+    {
+        params.profile_select.new_params.p_fm_port =
+            (ioc_fm_pcd_port_params_t*) (((t_Device*) p_Profile->id.newParams.h_FmPort)->h_UserPriv);
+    }
+
+    /* correct paramsOnGreen.h_Profile, paramsOnYellow.h_Profile, paramsOnRed.h_Profile
+     * if next engine is policer... that means that FM_PCD_PlcrProfileSet was called */
+    if (params.next_engine_on_green == e_IOC_FM_PCD_PLCR && params.params_on_green.p_profile)
+        DEV_TO_ID(params.params_on_green.p_profile);
+    if (params.next_engine_on_yellow == e_IOC_FM_PCD_PLCR && params.params_on_yellow.p_profile)
+        DEV_TO_ID(params.params_on_yellow.p_profile);
+    if (params.next_engine_on_red == e_IOC_FM_PCD_PLCR && params.params_on_red.p_profile)
+        DEV_TO_ID(params.params_on_red.p_profile);
+
+    /* correct paramsOnGreen.h_Profile, paramsOnYellow.h_Profile, paramsOnRed.h_Profile
+     * if next engine is kg... that means that FM_PCD_KgSchemeSet was called */
+    if (params.next_engine_on_green == e_IOC_FM_PCD_KG && params.params_on_green.p_direct_scheme)
+        DEV_TO_ID(params.params_on_green.p_direct_scheme);
+    if (params.next_engine_on_yellow == e_IOC_FM_PCD_KG && params.params_on_yellow.p_direct_scheme)
+        DEV_TO_ID(params.params_on_yellow.p_direct_scheme);
+    if (params.next_engine_on_red == e_IOC_FM_PCD_KG && params.params_on_red.p_direct_scheme)
+        DEV_TO_ID(params.params_on_red.p_direct_scheme);
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_PLCR_PROFILE_SET, &params))
+    {
+        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+        return NULL;
+    }
+
+    p_Dev = (t_Device *)malloc(sizeof(t_Device));
+    if (!p_Dev)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Policer Profile device!!"));
+        return NULL;
+    }
+
+    memset(p_Dev, 0, sizeof(t_Device));
+    p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
+    p_PcdDev->owners++;
+    p_Dev->id = PTR_TO_UINT(params.id);
+
+    _fml_dbg("Called.\n");
+
+    return (t_Handle) p_Dev;
+}
+
+t_Error FM_PCD_PlcrProfileDelete(t_Handle h_Profile)
+{
+    t_Device *p_Dev = (t_Device*) h_Profile;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_obj_t id;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
+    id.obj = UINT_TO_PTR(p_Dev->id);
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_PLCR_PROFILE_DELETE, &id)){
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+    }
+
+    p_PcdDev->owners--;
+    free(p_Dev);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_FmPcdManipParams)
+{
+    t_Device *p_PcdDev = (t_Device*) h_FmPcd;
+    t_Device *p_Dev = NULL;
+    ioc_fm_pcd_manip_params_t params;
+
+    SANITY_CHECK_RETURN_VALUE(p_PcdDev, E_INVALID_HANDLE, NULL);
+
+    _fml_dbg("Calling...\n");
+
+    memset(&params, 0, sizeof(ioc_fm_pcd_manip_params_t));
+    memcpy(&params, p_FmPcdManipParams, sizeof(t_FmPcdManipParams));
+    if (p_FmPcdManipParams->h_NextManip)
+    {
+        p_Dev = (t_Device*)p_FmPcdManipParams->h_NextManip;
+        params.p_next_manip = UINT_TO_PTR(p_Dev->id);
+    }
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MANIP_NODE_SET, &params)){
+        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+        return NULL;
+    }
+
+    p_Dev = (t_Device *)malloc(sizeof(t_Device));
+    if (!p_Dev)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Manip Node device!!"));
+        return NULL;
+    }
+
+    memset(p_Dev, 0, sizeof(t_Device));
+    p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
+    p_PcdDev->owners++;
+    p_Dev->id = PTR_TO_UINT(params.id);
+
+    _fml_dbg("Called.\n");
+
+    return (t_Handle) p_Dev;
+}
+
+t_Error FM_PCD_ManipNodeReplace(t_Handle h_ManipNode, t_FmPcdManipParams *p_FmPcdManipParams)
+{
+    t_Device *p_Dev = (t_Device*)h_ManipNode;
+    t_Device *p_PcdDev;
+    ioc_fm_pcd_manip_params_t params;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
+
+    memset(&params, 0, sizeof(ioc_fm_pcd_manip_params_t));
+    memcpy(&params, p_FmPcdManipParams, sizeof(t_FmPcdManipParams));
+    params.id = UINT_TO_PTR(p_Dev->id);
+    /* REMINDER:
+       Also take care of params.p_next_manip here, although it's currently
+       ignored by the LLD! */
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MANIP_NODE_SET, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error  FM_PCD_ManipNodeDelete(t_Handle h_HdrManipNode)
+{
+    t_Device *p_Dev = (t_Device*) h_HdrManipNode;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_obj_t id;
+
+    SANITY_CHECK_EXIT(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
+    id.obj = UINT_TO_PTR(p_Dev->id);
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_MANIP_NODE_DELETE, &id))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    p_PcdDev->owners--;
+    free(p_Dev);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+#ifdef FM_CAPWAP_SUPPORT
+#error CAPWAP feature not supported
+#endif
+
+typedef struct {
+    e_FmPortType            portType;           /**< Port type */
+    uint8_t                 portId;             /**< Port Id - relative to type */
+} t_FmPort;
+
+/********************************************************************************************/
+/*  FM_PORT FUNCTIONS                                                                       */
+/********************************************************************************************/
+
+t_Handle FM_PORT_Open(t_FmPortParams *p_FmPortParams)
+{
+    t_Device    *p_Dev;
+    int         fd;
+    char        devName[30];
+    t_FmPort    *p_FmPort;
+
+    _fml_dbg("Calling...\n");
+
+    p_Dev = (t_Device*) malloc(sizeof(t_Device));
+    if (!p_Dev)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Port device!!"));
+        return NULL;
+    }
+    memset(p_Dev, 0, sizeof(t_Device));
+
+    p_FmPort = (t_FmPort*) malloc(sizeof(t_FmPort));
+    if (!p_FmPort)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Port device!!"));
+        free(p_Dev);
+        return NULL;
+    }
+    memset(p_FmPort, 0, sizeof(t_FmPort));
+
+    memset(devName, 0, sizeof(devName));
+    switch (p_FmPortParams->portType)
+    {
+        case e_FM_PORT_TYPE_OH_OFFLINE_PARSING:
+            sprintf(devName, "%s%s%u-port-oh%d", "/dev/", DEV_FM_NAME,
+                    (uint32_t)((t_Device*)p_FmPortParams->h_Fm)->id, p_FmPortParams->portId);
+            break;
+        case e_FM_PORT_TYPE_RX:
+            sprintf(devName, "%s%s%u-port-rx%d", "/dev/", DEV_FM_NAME,
+                    (uint32_t)((t_Device*)p_FmPortParams->h_Fm)->id, p_FmPortParams->portId);
+            break;
+        case e_FM_PORT_TYPE_RX_10G:
+            sprintf(devName, "%s%s%u-port-rx%d", "/dev/", DEV_FM_NAME,
+                    (uint32_t)((t_Device*)p_FmPortParams->h_Fm)->id, FM_MAX_NUM_OF_1G_RX_PORTS+p_FmPortParams->portId);
+            break;
+        case e_FM_PORT_TYPE_TX:
+            sprintf(devName, "%s%s%u-port-tx%d", "/dev/", DEV_FM_NAME,
+                    (uint32_t)((t_Device*)p_FmPortParams->h_Fm)->id, p_FmPortParams->portId);
+            break;
+        case e_FM_PORT_TYPE_TX_10G:
+            sprintf(devName, "%s%s%u-port-tx%d", "/dev/", DEV_FM_NAME,
+                    (uint32_t)((t_Device*)p_FmPortParams->h_Fm)->id, FM_MAX_NUM_OF_1G_TX_PORTS+p_FmPortParams->portId);
+            break;
+        default:
+            free(p_FmPort);
+            free(p_Dev);
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("port id!"));
+            return NULL;
+    }
+
+    fd = open(devName, O_RDWR);
+    if (fd < 0)
+    {
+       free(p_FmPort);
+       free(p_Dev);
+       REPORT_ERROR(MAJOR, E_NO_DEVICE, ("Could not open FM-port %s. Ret code=%d, errno=%d. Aborting!!!",
+               devName,
+               fd,
+               errno));
+       return NULL;
+    }
+
+    p_FmPort->portType = p_FmPortParams->portType;
+    p_FmPort->portId = p_FmPortParams->portId;
+    p_Dev->id = p_FmPortParams->portId;
+    p_Dev->fd = fd;
+    p_Dev->h_UserPriv = (t_Handle) p_FmPort;
+
+    _fml_dbg("Called.\n");
+
+    return (t_Handle) p_Dev;
+}
+
+void FM_PORT_Close(t_Handle h_FmPort)
+{
+    t_Device    *p_Dev = (t_Device *)h_FmPort;
+
+    SANITY_CHECK_RETURN(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    close(p_Dev->fd);
+    if (p_Dev->h_UserPriv)
+        free(p_Dev->h_UserPriv);
+    free(p_Dev);
+
+    _fml_dbg("Called.\n");
+}
+
+t_Error FM_PORT_Disable(t_Handle h_FmPort)
+{
+    t_Device    *p_Dev = (t_Device *)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_DISABLE))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PORT_Enable(t_Handle h_FmPort)
+{
+    t_Device    *p_Dev = (t_Device *)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_ENABLE))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort)
+{
+    t_Device    *p_Dev = (t_Device*) h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_REMOVE_RATE_LIMIT))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
+{
+    t_Device    *p_Dev = (t_Device*) h_FmPort;
+
+    ASSERT_COND(sizeof(t_FmPortRateLimit) == sizeof(ioc_fm_port_rate_limit_t));
+    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_SET_RATE_LIMIT, p_RateLimit))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
+{
+    t_Device    *p_Dev = (t_Device*) h_FmPort;
+    int         intCast = (int) errs;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_SET_ERRORS_ROUTE, &intCast))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+uint32_t FM_PORT_AllocPCDFqids (t_Handle h_FmPort, uint32_t numFqids, uint8_t alignment)
+{
+    t_Device    *p_Dev = (t_Device*) h_FmPort;
+    ioc_fm_port_pcd_fqids_params_t  param;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    param.num_fqids  = numFqids;
+    param.alignment = alignment;
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_ALLOC_PCD_FQIDS, &param))
+    {
+        REPORT_ERROR(MINOR, E_INVALID_OPERATION,
+                ("Failed to allocate %d queue IDs!", numFqids));
+        return 0;
+    }
+
+    _fml_dbg("Called.\n");
+
+    return param.base_fqid;
+}
+
+t_Error FM_PORT_FreePCDFqids (t_Handle h_FmPort, uint32_t base_fqid)
+{
+    t_Device    *p_Dev = (t_Device*) h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_FREE_PCD_FQIDS, &base_fqid))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION,
+                ("Invalid base FQID %d or other error!", base_fqid));
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_FmPortPcd)
+{
+    t_Device *p_Dev = (t_Device*) h_FmPort;
+    ioc_fm_port_pcd_params_t params;
+
+    ASSERT_COND(sizeof(t_FmPortPcdParams) == sizeof(ioc_fm_port_pcd_params_t));
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    memcpy(&params, p_FmPortPcd, sizeof(t_FmPortPcdParams));
+
+    /* correct h_NetEnv param from t_FmPortPcdParams */
+    DEV_TO_ID(params.net_env_id);
+
+    /* correct pcd structures according to what support was set */
+    if (params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC ||
+        params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR ||
+        params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC) {
+
+        if (params.p_cc_params && params.p_cc_params->cc_tree_id)
+            DEV_TO_ID(params.p_cc_params->cc_tree_id);
+        else
+            XX_Print("fmlib warning (%s): Coarse Clasification not set ! \n", __func__);
+    }
+
+    if (params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG ||
+        params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC ||
+        params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR ||
+        params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR ){
+
+        if (params.p_kg_params){
+            uint32_t i;
+            for (i = 0; i < params.p_kg_params->num_of_schemes; i++)
+                if (params.p_kg_params->scheme_ids[i])
+                    DEV_TO_ID(params.p_kg_params->scheme_ids[i]);
+                else
+                    XX_Print("fmlib warning (%s): Scheme:%u not set!\n", __func__, i);
+
+            if (params.p_kg_params && params.p_kg_params->direct_scheme)
+                DEV_TO_ID(params.p_kg_params->direct_scheme_id);
+        } else
+            XX_Print("fmlib warning (%s): KeyGen not set ! \n", __func__);
+    }
+
+    if (params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY ||
+        params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR ||
+        params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR ||
+        params.pcd_support == e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR){
+
+        if (params.p_plcr_params)
+        {
+            if (params.p_plcr_params->plcr_profile_id)
+                DEV_TO_ID(params.p_plcr_params->plcr_profile_id);
+            else
+                XX_Print("fmlib warning (%s): Policer not set !\n", __func__);
+        }
+    }
+
+    if (params.p_ip_reassembly_manip)
+        DEV_TO_ID(params.p_ip_reassembly_manip);
+
+#if (DPAA_VERSION >= 11)
+    if (params.p_capwap_reassembly_manip)
+	DEV_TO_ID(params.p_capwap_reassembly_manip);
+#endif
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_SET_PCD, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
+{
+    t_Device *p_Dev = (t_Device*) h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_DELETE_PCD))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
+{
+    t_Device    *p_Dev = (t_Device*) h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_DETACH_PCD))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
+{
+    t_Device *p_Dev = (t_Device*) h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_ATTACH_PCD))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
+{
+    t_Device *p_Dev = (t_Device*) h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES, &numOfProfiles))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort)
+{
+    t_Device *p_Dev = (t_Device*) h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_PCD_PLCR_FREE_PROFILES))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PORT_PcdKgModifyInitialScheme(t_Handle h_FmPort, t_FmPcdKgSchemeSelect *p_FmPcdKgScheme)
+{
+    t_Device *p_Dev = (t_Device*) h_FmPort;
+
+    ASSERT_COND(sizeof(t_FmPcdKgSchemeSelect) == sizeof(ioc_fm_pcd_kg_scheme_select_t));
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME, p_FmPcdKgScheme))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_Profile)
+{
+    t_Device *p_Dev = (t_Device*) h_FmPort;
+    ioc_fm_obj_t id;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    id.obj = h_Profile;
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE, &id))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
+{
+    t_Device *p_Dev = (t_Device*) h_FmPort;
+    ioc_fm_obj_t id;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    id.obj = h_CcTree;
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_PCD_CC_MODIFY_TREE, &id))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
+{
+    t_Device *p_Dev = (t_Device*) h_FmPort;
+    ioc_fm_pcd_port_schemes_params_t params;
+    uint32_t i;
+
+    ASSERT_COND(sizeof(t_FmPcdPortSchemesParams) == sizeof(ioc_fm_pcd_port_schemes_params_t));
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    memcpy(&params, p_PortScheme, sizeof(t_FmPcdPortSchemesParams));
+    for (i = 0; i < params.num_of_schemes; i++)
+	    DEV_TO_ID(params.scheme_ids[i]);
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_PCD_KG_BIND_SCHEMES, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
+{
+    t_Device *p_Dev = (t_Device*) h_FmPort;
+    ioc_fm_pcd_port_schemes_params_t params;
+    uint32_t i;
+
+    ASSERT_COND(sizeof(t_FmPcdPortSchemesParams) == sizeof(ioc_fm_pcd_port_schemes_params_t));
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    memcpy(&params, p_PortScheme, sizeof(t_FmPcdPortSchemesParams));
+    for (i = 0; i < params.num_of_schemes; i++)
+	    DEV_TO_ID(params.scheme_ids[i]);
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PORT_PcdModifyPrsStart (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart)
+{
+    t_Device *p_Dev = (t_Device*) h_FmPort;
+
+    ASSERT_COND(sizeof(t_FmPcdPrsStart) == sizeof(ioc_fm_pcd_prs_start_t));
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET, p_FmPcdPrsStart))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPort)
+{
+    t_Device    *p_Dev = (t_Device *)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PCD_IOC_SET_ADVANCED_OFFLOAD_SUPPORT))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+#if (DPAA_VERSION >= 11)
+t_Handle FM_PCD_FrmReplicSetGroup(t_Handle h_FmPcd, t_FmPcdFrmReplicGroupParams *p_FrmReplicGroupParam)
+{
+    t_Device *p_PcdDev = (t_Device*) h_FmPcd;
+    t_Device *p_Dev = NULL;
+    ioc_fm_pcd_frm_replic_group_params_t params;
+
+    SANITY_CHECK_RETURN_VALUE(p_PcdDev, E_INVALID_HANDLE, NULL);
+
+    _fml_dbg("Calling...\n");
+
+    memcpy(&params, p_FrmReplicGroupParam, sizeof(t_FmPcdFrmReplicGroupParams));
+    params.id = NULL;
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_FRM_REPLIC_GROUP_SET, &params))
+    {
+        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+        return NULL;
+    }
+
+    p_Dev = (t_Device *)malloc(sizeof(t_Device));
+    if (!p_Dev)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD NetEnv Chrs device!!"));
+        return NULL;
+    }
+    memset(p_Dev, 0, sizeof(t_Device));
+    p_Dev->h_UserPriv = (t_Handle)p_PcdDev;
+    p_PcdDev->owners++;
+    p_Dev->id = PTR_TO_UINT(params.id);
+
+    _fml_dbg("Called.\n");
+
+    return (t_Handle) p_Dev;
+}
+
+t_Error FM_PCD_FrmReplicDeleteGroup(t_Handle h_FrmReplicGroup)
+{
+    t_Device *p_Dev = (t_Device*) h_FrmReplicGroup;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_obj_t id;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
+    id.obj = UINT_TO_PTR(p_Dev->id);
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_FRM_REPLIC_GROUP_DELETE, &id))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    p_PcdDev->owners--;
+    free(p_Dev);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PCD_FrmReplicAddMember(t_Handle h_ReplicGroup,
+                                  uint16_t memberIndex,
+                                  t_FmPcdCcNextEngineParams *p_MemberParams)
+{
+    t_Device *p_Dev = (t_Device*) h_ReplicGroup;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_pcd_frm_replic_member_params_t params;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
+
+    params.member.h_replic_group = UINT_TO_PTR(p_Dev->id);
+    params.member.member_index = memberIndex;
+    memcpy(&params.next_engine_params, p_MemberParams, sizeof(*p_MemberParams));
+    if (p_MemberParams->nextEngine == e_FM_PCD_CC) {
+        t_Device *p_NextDev = (t_Device*) p_MemberParams->params.ccParams.h_CcNode;
+
+        params.next_engine_params.params.cc_params.cc_node_id = UINT_TO_PTR(p_NextDev->id);
+    }
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_FRM_REPLIC_MEMBER_ADD, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PCD_FrmReplicRemoveMember(t_Handle   h_ReplicGroup,
+                                     uint16_t   memberIndex)
+{
+    t_Device *p_Dev = (t_Device*) h_ReplicGroup;
+    t_Device *p_PcdDev = NULL;
+    ioc_fm_pcd_frm_replic_member_t param;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_PcdDev = (t_Device*)p_Dev->h_UserPriv;
+
+    param.h_replic_group = UINT_TO_PTR(p_Dev->id);
+    param.member_index = memberIndex;
+
+    if (ioctl(p_PcdDev->fd, FM_PCD_IOC_FRM_REPLIC_MEMBER_REMOVE, &param))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    p_PcdDev->owners--;
+    free(p_Dev);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+#endif
+
+t_Error FM_MAC_AddHashMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
+{
+    t_Device    *p_Dev = (t_Device *)h_FmMac;
+
+    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_ADD_RX_HASH_MAC_ADDR, p_EnetAddr))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_MAC_RemoveHashMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
+{
+    t_Device    *p_Dev = (t_Device *)h_FmMac;
+
+    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_REMOVE_RX_HASH_MAC_ADDR, p_EnetAddr))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_MAC_SetTxPauseFrames(t_Handle h_FmMac, uint8_t  priority, uint16_t pauseTime, uint16_t threshTime)
+{
+    t_Device    *p_Dev = (t_Device *)h_FmMac;
+    ioc_fm_port_tx_pause_frames_params_t param;
+
+    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
+
+    _fml_dbg("Calling...\n");
+
+    param.priority = priority;
+    param.pause_time = pauseTime;
+    param.thresh_time = threshTime;
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_SET_TX_PAUSE_FRAMES, &param))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_MAC_GetStatistics (t_Handle h_FmMac, t_FmMacStatistics *p_Statistics)
+{
+    t_Device    *p_Dev = (t_Device *)h_FmMac;
+    ioc_fm_port_mac_statistics_t *param;
+
+    param = (ioc_fm_port_mac_statistics_t *)p_Statistics;
+
+    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
+    SANITY_CHECK_RETURN_VALUE(param, E_INVALID_HANDLE, E_OK);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_GET_MAC_STATISTICS, param))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle h_FmPort, t_FmBufferPrefixContent *p_Params)
+{
+    t_Device    *p_Dev = (t_Device*) h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_CONFIG_BUFFER_PREFIX_CONTENT, p_Params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+#if (DPAA_VERSION >= 11)
+
+t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_Params)
+{
+    t_Device    *p_Dev = (t_Device*) h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, E_OK);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_PORT_IOC_VSP_ALLOC, p_Params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Handle FM_VSP_Config(t_FmVspParams *p_FmVspParams)
+{
+    t_Device *p_Dev = NULL;
+    t_Device *p_VspDev = NULL;
+    ioc_fm_vsp_params_t param;
+
+    SANITY_CHECK_RETURN_VALUE((void *)p_FmVspParams, E_INVALID_HANDLE, NULL);
+    p_Dev = p_FmVspParams->h_Fm;
+    SANITY_CHECK_RETURN_VALUE(p_Dev, E_INVALID_HANDLE, NULL);
+
+    _fml_dbg("Calling...\n");
+
+    memcpy(&param, p_FmVspParams, sizeof(param));
+    param.p_fm = UINT_TO_PTR(p_Dev->id);
+    param.id = NULL;
+
+    if (ioctl(p_Dev->fd, FM_IOC_VSP_CONFIG, &param))
+    {
+        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+        return NULL;
+    }
+
+    p_VspDev = (t_Device *)malloc(sizeof(t_Device));
+    if (!p_VspDev)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM VSP Params!"));
+        return NULL;
+    }
+    memset(p_VspDev, 0, sizeof(t_Device));
+    p_VspDev->h_UserPriv = (t_Handle)p_Dev;
+    p_Dev->owners++;
+    p_VspDev->id = PTR_TO_UINT(param.id);
+
+    _fml_dbg("Called.\n");
+
+    return (t_Handle)p_VspDev;
+}
+
+t_Error FM_VSP_Init(t_Handle h_FmVsp)
+{
+    t_Device *p_Dev = NULL;
+    t_Device *p_VspDev = (t_Device *)h_FmVsp;
+    ioc_fm_obj_t id;
+
+    SANITY_CHECK_RETURN_ERROR(p_VspDev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_Dev = (t_Device*)p_VspDev->h_UserPriv;
+    id.obj = UINT_TO_PTR(p_VspDev->id);
+
+    if (ioctl(p_Dev->fd, FM_IOC_VSP_INIT, &id))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_VSP_Free(t_Handle h_FmVsp)
+{
+    t_Device *p_Dev = NULL;
+    t_Device *p_VspDev = (t_Device *)h_FmVsp;
+    ioc_fm_obj_t id;
+
+    SANITY_CHECK_RETURN_ERROR(p_VspDev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    p_Dev = (t_Device*)p_VspDev->h_UserPriv;
+    id.obj = UINT_TO_PTR(p_VspDev->id);
+
+    if (ioctl(p_Dev->fd, FM_IOC_VSP_FREE, &id))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    p_Dev->owners--;
+    free(p_VspDev);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_VSP_ConfigPoolDepletion(t_Handle h_FmVsp, t_FmBufPoolDepletion *p_BufPoolDepletion)
+{
+    t_Device *p_Dev = NULL;
+    t_Device *p_VspDev = (t_Device *)h_FmVsp;
+    ioc_fm_buf_pool_depletion_params_t params;
+
+    SANITY_CHECK_RETURN_VALUE(p_VspDev, E_INVALID_HANDLE, E_OK);
+
+    _fml_dbg("Calling...\n");
+
+    p_Dev = (t_Device*)p_VspDev->h_UserPriv;
+    params.p_fm_vsp = UINT_TO_PTR(p_VspDev->id);
+    memcpy(&params.fm_buf_pool_depletion, p_BufPoolDepletion, sizeof(*p_BufPoolDepletion));
+
+    if (ioctl(p_Dev->fd, FM_IOC_VSP_CONFIG_POOL_DEPLETION, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_VSP_ConfigBufferPrefixContent(t_Handle h_FmVsp, t_FmBufferPrefixContent *p_FmBufferPrefixContent)
+{
+    t_Device *p_Dev = NULL;
+    t_Device *p_VspDev = (t_Device *)h_FmVsp;
+    ioc_fm_buffer_prefix_content_params_t params;
+
+    SANITY_CHECK_RETURN_VALUE(p_VspDev, E_INVALID_HANDLE, E_OK);
+
+    _fml_dbg("Calling...\n");
+
+    p_Dev = (t_Device*)p_VspDev->h_UserPriv;
+    params.p_fm_vsp = UINT_TO_PTR(p_VspDev->id);
+    memcpy(&params.fm_buffer_prefix_content, p_FmBufferPrefixContent, sizeof(*p_FmBufferPrefixContent));
+
+    if (ioctl(p_Dev->fd, FM_IOC_VSP_CONFIG_BUFFER_PREFIX_CONTENT, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_VSP_ConfigNoScatherGather(t_Handle h_FmVsp, bool noScatherGather)
+{
+    t_Device *p_Dev = NULL;
+    t_Device *p_VspDev = (t_Device *)h_FmVsp;
+    ioc_fm_vsp_config_no_sg_params_t params;
+
+    SANITY_CHECK_RETURN_VALUE(p_VspDev, E_INVALID_HANDLE, E_OK);
+
+    _fml_dbg("Calling...\n");
+
+    p_Dev = (t_Device*)p_VspDev->h_UserPriv;
+    params.p_fm_vsp = UINT_TO_PTR(p_VspDev->id);
+    params.no_sg = noScatherGather;
+
+    if (ioctl(p_Dev->fd, FM_IOC_VSP_CONFIG_NO_SG, &params))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_FmPrsResult * FM_VSP_GetBufferPrsResult(t_Handle h_FmVsp, char *p_Data)
+{
+    t_Device *p_Dev = NULL;
+    t_Device *p_VspDev = (t_Device *)h_FmVsp;
+    ioc_fm_vsp_prs_result_params_t params;
+
+    SANITY_CHECK_RETURN_VALUE(p_VspDev, E_INVALID_HANDLE, NULL);
+
+    _fml_dbg("Calling...\n");
+
+    p_Dev = (t_Device*)p_VspDev->h_UserPriv;
+    params.p_fm_vsp = UINT_TO_PTR(p_VspDev->id);
+    params.p_data = p_Data;
+
+    if (ioctl(p_Dev->fd, FM_IOC_VSP_GET_BUFFER_PRS_RESULT, &params))
+    {
+        REPORT_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+        return NULL;
+    }
+
+    _fml_dbg("Called.\n");
+
+    return params.p_data;
+}
+#endif
+
+t_Error FM_CtrlMonStart(t_Handle h_Fm)
+{
+    t_Device    *p_Dev = (t_Device*) h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_IOC_CTRL_MON_START))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_CtrlMonStop(t_Handle h_Fm)
+{
+    t_Device    *p_Dev = (t_Device*) h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    if (ioctl(p_Dev->fd, FM_IOC_CTRL_MON_STOP))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+t_Error FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p_Mon)
+{
+    t_Device    *p_Dev = (t_Device*) h_Fm;
+    ioc_fm_ctrl_mon_counters_params_t param;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dev, E_INVALID_HANDLE);
+
+    _fml_dbg("Calling...\n");
+
+    param.fm_ctrl_index = fmCtrlIndex;
+    param.p_mon = (fm_ctrl_mon_t *)p_Mon;
+
+    if (ioctl(p_Dev->fd, FM_IOC_CTRL_MON_GET_COUNTERS, &param))
+        RETURN_ERROR(MINOR, E_INVALID_OPERATION, NO_MSG);
+
+    _fml_dbg("Called.\n");
+
+    return E_OK;
+}
+
+#ifdef P1023
+void Platform_is_P1023()
+{
+}
+#elif defined B4860 || defined T4240
+void Platform_is_B4860_T4240()
+{
+}
+#else
+void Platform_is_P3_P4_P5()
+{
+}
+#endif
